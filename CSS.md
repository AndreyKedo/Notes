
# Основы CSS
**Cascading Style Sheets (каскадные таблицы стилей)** -- *язык таблиц стилей* (stylesheet), используемый для *представления внешнего вида* HTML-документа. 

*Язык CSS* описывает, *как* элемент должен *отображаться* на экране.

*Документ* — текстовый файл, структурированный при помощи языка разметки HTML (SVG, XML).

## Основная структура CSS

*CSS код* состоит из *набора правил*. Одно такое *правило* (rule) имеет вид:

```css
selectors-list {
   properties-list
}
```
*Cелекторы отделяются* друг от друга *запятыми*, а *свойства* — *точками с запятой*:
```
 selectors-list := selector[, selectors-list]
 properties-list := [property : value][; properties-list]
```

## Основные типы элементов в CSS

### Блочные и строчные элементы

*Блочные элементы* — элементы высшего уровня (визуально выглядят как блоки), располагающиеся на странице *вертикально* и задающие её структуру. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину блока-родителя. 

*Блочные элементы* могут содержать как *строчные*, так и другие *блочные* элементы. 
*Исключением* является элемент *блочный* элемент *p*, который *не должен содержать* внутри себя *блочные* элементы (в том числе и *p*).

*Строчные (встроенные) элементы* используются для *форматирования текстовых фрагментов* (кроме area, img). Они *не формируют новые блоки контента*, *не создают разрыв строки* вокруг себя. Многие строчные элементы *не контролируют* поля, отступы, ширину и высоту. 

*Строчные элементы* могут содержать *только данные* и другие *строчные* элементы, они *не могут* содержать *блочные* элементы. (кроме *a*)

Также есть *блочно-строчные* элементы, которые обладают смешанной характеристикой: являются встроенным, но могут задавать поля, отступы, ширину и высоту.

Сделать элемент *блочным*, *строчным* или *блочно-строчным* в *CSS* можно с помощью:
```css
.block { display: block; }
.inline { display: inline; }
.inline-block { display: inline-block; }
```

### Замещаемые и незамещаемые элементы

*Замещаемым* является элемент, контент которого изначально не находится в документе. Такими элементами являются *изображения* (img), *плагины* (object) и *элементы управления форм* (button, textarea, input и select). Все *остальные типы элементов* можно отнести к *незамещаемым*.

*Внешний вид и размеры* замещаемых элементов могут определяться *извне*.  
Например, *img* без заданных свойств высоты и ширины, занимает свой *естественный* размер.  
При *изменении* одного из этих свойств, второе высчитается *автоматически*, с учётом пропорций.

## Типы отношений элементов в CSS

Подраздел относится скорее к *DOM* (представлению документа в виде дерева). Просто краткое напоминание, что даже у элементов есть отношения:
* **Элемент-предок (ancestor) и элемент-потомок  (descendant)**.  Элемент-потомок находится в элементе-предке, но при этом предок может не быть его родителем (потомок может быть вложен в другой элемент, тоже являющийся потомком для предка). В примере ниже такая связь наблюдается только между *div* и *span*, *div* и *img*.

* **Родительский (parent) и дочерний элементы (child)**.  Дочерний элемент находится в родительском и других элементов между ними нет. Ниже такая связь только между  *div* и *p*, *div* и *a*, *p* и *span*, *a* и *img*.

* **Элементы-братья (sibling)**.  Должны иметь одного и того же родителя. Называются смежными, если следуют прямо друг за другом. Ниже являются братьями (причём смежными) только *p* и *a*.

* **Элементы с дальней степенью родства**. Считаются безотносительными друг к другу. Ниже такими являются только *span* и *img*.

```html
<div>
	<p>
		<span></span>
	</p>
	<a>
		<img />
	</a>
</div>
```

## Селекторы

В CSS селекторы используются для идентицикафии элементов страницы, к которой применяется таблица стилей.

Селекторы подразделяют на простые и составные, а также добавляют к ним псевдо-классы и псевдо-селекторы.

### Простые селекторы

**Селектор по типу** выбирает DOM-элементы по *типу* узла:
```css
div, p, span, a { }
```
**Селектор по классу** выбирает элементы, соответствующие *атрибуту  class*
```css
.classname {}
```
**Селектор по id** выбирает элементы, соответствующие *атрибуту  id*
```css
#idname {}
```
**Универсальные селекторы**  выбирают элементы *всех* типов:
```css
* {}
```
**Селекторы атрибутов**  выбирают элементы на основании наличия указанного атрибута, а также соответствую значения атрибута, если оно указано:
```css
[attr operator value i] {}

a[href] {} /* <a> элементы с атрибутом href */

a[href="https://qq.com"] {}  /* ...точно соответствующим "https://qq.com" */

a[class^="qq"] {} /* ...начинающимся с подстроки 'qq' */

a[href*="qq"] {} /* ...содержащим подстроку 'qq' */

a[href*="qq" i] {} /* ...содержащим подстроку 'qq' (case insensitive благодаря флагу 'i') */

a[href~="qq" i] {} /* ...содержащим целое слово 'qq' (значение атрибута состоит из слов и пробелов) */

a[href$=".com"] {} /* ...заканчивающимся подстрокой '.com' */
```

### Комбинаторы (составные селекторы)
Комбинатор состоит из двух или более простых селекторов и различных комбинирующих операторов между ними, определяющими отношение между этими селекторами. 

В комбинаторах приоритеты и правила группировки операторов при выборке элементов отсутствуют, поэтому её составление осуществляется *строго справа налево*, от одного простого селектора к другому. 

**Комбинатор потомков (descendant) A B**  выбирает элементы, соответствующие *селектору B* и имеющие предка, соответствующего *селектору A*. 

Комбинатор потомков представлен одним или несколькими *пробельными символами* (возможно, с переходом на новую строку или даже с комментариями). 
```css
.grandfather .son {}
.father .son {}
```

Комбинатор потомков *сработает* лишь в том случае, если между селекторами *нет других комбинирующих операторов*. В следующем примере он не применяется, поэтому строки эквивалентны:
```css
 .father>.son {}
 .father > .son {}
```

Случай, когда селекторов три (например, *C A B*), означает лишь наличие *дополнительного условия*. Помимо сказанного выше про *A B*, у искомых элементов должен также имееться *элемент-предок*, соответствующий *селектору C*:
```css
.grandfather .father .son {}
```
Точно так же это определяется  как для *большего числа селекторов* (по индукции), так и для *комбинаторов других (в том числе и смешанных) типов*.

**Комбинатор детей (child) A > B** является частным случаем комбинатора потомков. Он выбирает элементы, соответствующие *селектору B* и имеющие родительский элемент, соответствующий *селектору A*:
```css
.grandfather > .father > .son {}
.father > .son {}
```
**Комбинатор смежных братьев (adjacent sibling) A + B** выбирает элементы, соответствующие *селектору B*, являющиеся *смежными братьями* с элементами, соответсвующими *селектору A*, и *следующие прямо за ними*.


**Комбинатор общих братьев (general sibling) A ~ B** выбирает элементы, соответствующие *селектору B*, являющиеся *братьями* с элементами, соответсвующими *селектору A*, и *следующие (не обязательно прямо, между ними могут быть и другие братья) за ними*.

Рассмотрим несколько примеров, чтобы понять, как работают *комбинаторы братьев*.
```html
<div class="row">
   <div class="cell white"></div>
   <div class="cell"></div>
   <div class="cell white"></div>
   <div class="cell"></div>
</div>
<style>
  .row { display: flex; width: fit-content; border: 1px solid; }
  .cell { width: 50px; height: 50px; }
</style>
<style>
  .white + .cell { background: black; } // Рис. 1
  .cell + .cell { background: black; } // Рис. 2
  .white + .white { background: black; } // Рис. 3

  .white ~ .cell { background: black; } // Рис. 4
  .cell ~ .cell { background: black; } // Рис. 5
  .white ~ .white { background: black; } // Рис. 6
</style>
```

![sibling-combinators](/assets/sibling-combinators.png)

*Рис. 1* Каждое поле, следующее за белым (*.white*), окрашивается в чёрный.  
*Рис. 2* Каждое поле, следующее за другим полем, окрашивается в чёрный (все, кроме первого).  
*Рис. 3* Не найдено белых полей, следующих за белыми.  
*Рис. 4* Каждое поле, если ранее встречалось хоть одно белое, окрашивается в чёрный.  
*Рис. 5* Каждое поле, если ранее встречалось хоть одно поле, окрашивается в чёрный.  
*Рис. 6* Каждое белое поле, если ранее встречалось хоть одно белое поле, окрашивается в чёрный.  
Всё это работает так, потому что все поля имеют *один класс cell* и у них *нет братьев другого класса*.  

Стоит отметить, что *комбинаторы* (не считая *комбинатора потомков*) используются *крайне редко*, так как могут стать причиной *довольно непредсказуемого поведения* кода. Ведь при их использовании добавление новых блоков будет сказываеться на стилях других блоков, что может быть особенно заметно, когда в ход вступает *специфичность*.

Если между селекторами *ничего не стоит* **AB**, то происходит их **объединение**: выбираются элементы, соответствующие *обоим* селекторам одновременно.

Если *хотя бы одна часть селектора* написана *неправильно*, то этот селектор *полностью игнорируется*, на другие селекторы это никак не влияет.

Если между селекторами *стоит запятая* **A, B** то они *не связаны* между собой *выбором элементов* (в этом случае выборка осуществляется для каждого селектора в отдельности), но ко всем найденным элементам применется *один набор стилей*. Такой тип связи называется **группой селекторов**.

### Псевдо-классы и псевдо-селекторы

*Псевдо-элементы* позволяют контролировать элементы, находящиеся *за пределами документа*; позволяют ссылаться на *недоступную* для получения *иным путём* информацию. Они должны всегда *начинаться с двух двоеточий*, хоть в большинство браузеров их разрешено использовать и с одним для обратной совместимости:
```css
.field::placeholder { color: #8ab7e5 } // изменение цвета замещающего текста для input и textarea
p::before, p::after { content: "♥"; } // вставка сердечка перед контентом каждого блока p и после него 
p::first-line { color: #8ab7e5 } // изменение первой строки блочного элемента (в данном случае p)
p::first-letter { font-size: 24px; } // изменение первой строки блочного элемента (в данном случае p)
*::selection { background: #8ab7e5 } // изменение цвета выделения текста
*::-webkit-scrollbar-thumb { background: #8ab7e5 } // изменение цвета ползунка полосы прокрутки в браузерах на движке webkit
```

*Псевдо-классы* выбирают элементы, находящиеся в определённом состоянии. Они всегда *начинаются с двоеточия*. Некоторые из них могут принимать *параметры*.
```css
input:focus {} // любое поле ввода, находящееся в фокусе
option:checked {} // каждая отмеченная опция
button:disabled {} // каждая недоступная кнопка
link:not(:visited) {} // каждая непосещённая ссылка
*:hover {} // любой элемент при наведении на него
```

Если *псевдо-класс* или *псевдо-элемент* применяются *ко всем элементам*, то не рекомендуется пропускать *универсальный селектор* **\***, иначе может возникнуть путаница.  
Селекторы ниже *похожи*, но выбирают *совершенно разные* элементы:  
```css
 div:hover {} // любой блок div, на который наведён курсор
 div :hover {} // ~ div *:hover (любой элемент, на который наведён курсор, располагающийся в блоке div)
```

С помощью *псевдо-классов* также можно работать с *родительскими и дочерними* элементами:
```css
div:empty {} // каждый блок без дочерних элементов
div:not(:empty) {} // каждый блок, имеющий дочерние элементы
div:first-child {} // каждый блок, являющийся первым ребёнком
div:nth-child(3) {} // каждый блок, являющийся третьим по счёту ребёнком
div:last-child {} // каждый блок, являющийся последним ребёнком
div:only-child {} // каждый блок, являющийся единственным ребёнком
```

*Псевдо-классы* могут идти *последовательно* друг за другом:
```css
div:first-child:last-child // эквивалентно :only-child
```

Стоит также отметить, что некоторые *псевдо-классы* совпадают с *атрибутами* элементов, поэтому их можно заменить *селектором атрибутов*. Следующие строки *эквивалентны*:
```css
button:disabled {}
button[disabled] {}
```

### Применение CSS-селекторов в JavaScript (Selectors API)

*Selectors API* предоставляет методы, с помощью которых можно быстро и просто получить список узлов документа путем сопоставления с *группой селекторов*:
```javascript
// возвращает первый найденный Element или null, если совпадений не найдено
const element = parentNode.querySelector('selectors'); 
// возвращает NodeList, содержащий все найденные элементы, или пустой NodeList
const elementList = parentNode.querySelectorAll('selectors'); 

const root = document.querySelector('#root');
const articleTitles = root.querySelectorAll('.article > .title');
```
Параметр *selectors*  всегда  должен быть *валидной строкой CSS-селекторов*, в противном случае выдаётся исключение *SyntaxError*.
