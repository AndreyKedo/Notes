
# Основы CSS
**Cascading Style Sheets (каскадные таблицы стилей)** — *язык таблиц стилей* (stylesheet), используемый для *представления внешнего вида* HTML-документа. 

*Язык CSS* описывает, *как* элемент должен *отображаться* на экране.

*Документ* — текстовый файл, структурированный при помощи языка разметки HTML (SVG, XML).

## Синтаксис CSS

*CSS код* состоит из *наборов правил* (ruleset), или же просто — *правил* (rule). Одно такое *правило* имеет вид:

```css
selector1, selector2 /*, ...*/ {
   property1: value1;
   property2: value2;
   /* ... */
}
```

*Cелекторы отделяются* друг от друга *запятыми*.

*Свойство* и *значение* отделяются друг от друга *двоеточием*.  
Пара *свойство-значение* называется *объявлением* (declaration). 

*Объявления* отделяются друг от друга *точками с запятой*.  
Если *пропущена точка с запятой*, то стили могут *примениться неправильно* или *не примениться* вовсе.

Всё, что находится *внутри фигурных скобок*, называется *блоком объявлений*.  
*Блоки объявлений* могут быть *пустыми*, но могут и *вложенными* (*at-rules*, начинающиеся с `@`):
```css
selector1 {}

@media (/*...*/) {
  selector2 {
    /*...*/
  }
}
```

## Основные типы элементов в CSS

### Блочные и строчные элементы

*Блочные элементы* — элементы высшего уровня (визуально выглядят как блоки), располагающиеся на странице *вертикально* и задающие её структуру. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину блока-родителя. 

*Блочные элементы* могут содержать как *строчные*, так и другие *блочные* элементы. 
*Исключением* является элемент *блочный* элемент *p*, который *не должен содержать* внутри себя *блочные* элементы (в том числе и *p*).

*Строчные (встроенные) элементы* используются для *форматирования текстовых фрагментов* (кроме area, img). Они *не формируют новые блоки контента*, *не создают разрыв строки* вокруг себя. Многие строчные элементы *не контролируют* поля, отступы, ширину и высоту. 

*Строчные элементы* могут содержать *только данные* и другие *строчные* элементы, они *не могут* содержать *блочные* элементы. (кроме *a*)

Также есть *блочно-строчные* элементы, которые обладают смешанной характеристикой: являются встроенным, но могут задавать поля, отступы, ширину и высоту.

Сделать элемент *блочным*, *строчным* или *блочно-строчным* в *CSS* можно с помощью:
```css
.block { display: block; }
.inline { display: inline; }
.inline-block { display: inline-block; }
```

### Замещаемые и незамещаемые элементы

*Замещаемым* является элемент, контент которого изначально не находится в документе. Такими элементами являются *изображения* (img), *плагины* (object) и *элементы управления форм* (button, textarea, input и select). Все *остальные типы элементов* можно отнести к *незамещаемым*.

*Внешний вид и размеры* замещаемых элементов могут определяться *извне*.  
Например, *img* без заданных свойств высоты и ширины, занимает свой *естественный* размер.  
При *изменении* одного из этих свойств, второе высчитается *автоматически*, с учётом пропорций.

## CSS Box Model

Каждому HTML элементу соответствует прямоугольная область, называемая боксом или блоком (box, block).  
Структура этой области называется блочной или боксовой моделью (box model).

Каждый бокс состоит из:
* margin

## Типы отношений элементов в CSS

Подраздел относится скорее к *DOM* (представлению документа в виде дерева). Просто краткое напоминание, что даже у элементов есть отношения:
* **Элемент-предок (ancestor) и элемент-потомок  (descendant)**.  Элемент-потомок находится в элементе-предке, но при этом предок может не быть его родителем (потомок может быть вложен в другой элемент, тоже являющийся потомком для предка). В примере ниже такая связь наблюдается только между *div* и *span*, *div* и *img*.

* **Родительский (parent) и дочерний элементы (child)**.  Дочерний элемент находится в родительском и других элементов между ними нет. Ниже такая связь только между  *div* и *p*, *div* и *a*, *p* и *span*, *a* и *img*.

* **Элементы-братья (sibling)**.  Должны иметь одного и того же родителя. Называются смежными, если следуют прямо друг за другом. Ниже являются братьями (причём смежными) только *p* и *a*.

* **Элементы с дальней степенью родства**. Считаются безотносительными друг к другу. Ниже такими являются только *span* и *img*.

```html
<div>
	<p>
		<span></span>
	</p>
	<a>
		<img />
	</a>
</div>
```

## Селекторы в СSS

В CSS *селекторы* используются для *идентификации элементов* страницы, к которой применяется таблица стилей.

Селекторы подразделяют на *простые* и *составные*, а также добавляют к ним *псевдоклассы* и *псевдоэлементы*.

### Простые селекторы

**Селектор по типу** выбирает элементы по *типу* узла:
```css
div, p, span, a { }
```
**Селектор по классу** выбирает элементы, соответствующие *атрибуту  class*
```css
.classname {}
```
**Селектор по id** выбирает элементы, соответствующие *атрибуту  id*
```css
#idname {}
```
**Универсальные селекторы**  выбирают элементы *всех* типов:
```css
* {}
```
**Селекторы атрибутов**  выбирают элементы на основании *наличия* указанного *атрибута*, а также *соответствия значения атрибута*, если оно указано:
```css
[attr operator value i] {}

a[href] {} /* <a> элементы с атрибутом href */

a[href="https://qq.com"] {}  /* ...точно соответствующим "https://qq.com" */

a[class^="qq"] {} /* ...начинающимся с подстроки 'qq' */

a[href*="qq"] {} /* ...содержащим подстроку 'qq' */

a[href*="qq" i] {} /* ...содержащим подстроку 'qq' (case insensitive благодаря флагу 'i') */

a[href~="qq" i] {} /* ...содержащим целое слово 'qq' (значение атрибута состоит из слов и пробелов) */

a[href$=".com"] {} /* ...заканчивающимся подстрокой '.com' */
```

### Комбинаторы (составные селекторы)
Комбинатор состоит из двух или более простых селекторов и различных комбинирующих операторов между ними, определяющими отношение между этими селекторами. 

В комбинаторах приоритеты и правила группировки операторов при выборке элементов отсутствуют, поэтому её составление осуществляется *строго справа налево*, от одного простого селектора к другому. 

**Комбинатор потомков (descendant) A B**  выбирает элементы, соответствующие *селектору B* и имеющие предка, соответствующего *селектору A*. 

Комбинатор потомков представлен одним или несколькими *пробельными символами* (возможно, с переходом на новую строку или даже с комментариями). 
```css
.grandfather .son {}
.father .son {}
```

Комбинатор потомков *сработает* лишь в том случае, если между селекторами *нет других комбинирующих операторов*. В следующем примере он не применяется, поэтому строки эквивалентны:
```css
 .father>.son {}
 .father > .son {}
```

Случай, когда селекторов три (например, *C A B*), означает лишь наличие *дополнительного условия*. Помимо сказанного выше про *A B*, у искомых элементов должен также имееться *элемент-предок*, соответствующий *селектору C*:
```css
.grandfather .father .son {}
```
Точно так же это определяется  как для *большего числа селекторов* (по индукции), так и для *комбинаторов других (в том числе и смешанных) типов*.

**Комбинатор детей (child) A > B** является частным случаем комбинатора потомков. Он выбирает элементы, соответствующие *селектору B* и имеющие родительский элемент, соответствующий *селектору A*:
```css
.grandfather > .father > .son {}
.father > .son {}
```
**Комбинатор смежных братьев (adjacent sibling, next sibling) A + B** выбирает элементы, соответствующие *селектору B*, являющиеся *смежными братьями* с элементами, соответсвующими *селектору A*, и *следующие прямо за ними*.


**Комбинатор общих братьев (general sibling, subsequent sibling) A ~ B** выбирает элементы, соответствующие *селектору B*, являющиеся *братьями* с элементами, соответсвующими *селектору A*, и *следующие (не обязательно прямо, между ними могут быть и другие братья) за ними*.

Рассмотрим несколько примеров, чтобы понять, *как* работают *комбинаторы братьев*:
```html
<div class="row">
   <div class="cell white"></div>
   <div class="cell"></div>
   <div class="cell white"></div>
   <div class="cell"></div>
</div>
<style>
  .row { display: flex; width: fit-content; border: 1px solid; }
  .cell { width: 50px; height: 50px; }
</style>
<style>
  .white + .cell { background: black; } /* Рис. 1 */
  .cell + .cell { background: black; } /* Рис. 2 */
  .white + .white { background: black; } /* Рис. 3 */

  .white ~ .cell { background: black; } /* Рис. 4 */
  .cell ~ .cell { background: black; } /* Рис. 5 */
  .white ~ .white { background: black; } /* Рис. 6 */
</style>
```

![sibling-combinators](/assets/sibling-combinators.png)

*Рис. 1* Каждое поле, следующее за белым (*.white*), окрашивается в чёрный.  
*Рис. 2* Каждое поле, следующее за другим полем, окрашивается в чёрный (все, кроме первого).  
*Рис. 3* Не найдено белых полей, следующих за белыми.  
*Рис. 4* Каждое поле, если ранее встречалось хоть одно белое, окрашивается в чёрный.  
*Рис. 5* Каждое поле, если ранее встречалось хоть одно поле, окрашивается в чёрный.  
*Рис. 6* Каждое белое поле, если ранее встречалось хоть одно белое поле, окрашивается в чёрный.  
Всё это работает так, потому что все поля имеют *один класс cell* и у них *нет братьев другого класса*.  

Стоит отметить, что *комбинаторы* (не считая *комбинатора потомков*) используются *крайне редко*, так как могут стать причиной *довольно непредсказуемого поведения* кода. Ведь при их использовании добавление новых блоков будет сказываеться на стилях других блоков, что может быть особенно заметно, когда в ход вступает *специфичность*.

Если между селекторами *ничего не стоит* **AB**, то происходит их **объединение**: выбираются элементы, соответствующие *обоим* селекторам одновременно.

Если *хотя бы одна часть селектора* написана *неправильно*, то этот селектор *полностью игнорируется*, на другие селекторы это никак не влияет.

Если между селекторами *стоит запятая* **A, B** то они *не связаны* между собой *выбором элементов* (в этом случае выборка осуществляется для каждого селектора в отдельности), но ко всем найденным элементам применется *один набор стилей*. Такой тип связи называется **группой селекторов**.

### Псевдоклассы и псевдоэлементы

*Псевдоэлементы* позволяют контролировать элементы, находящиеся *за пределами документа*; позволяют ссылаться на *недоступную* для получения *иным путём* информацию. Они должны всегда *начинаться с двух двоеточий*, хоть в большинство браузеров их разрешено использовать и с одним для обратной совместимости:
```css
.field::placeholder { color: #8ab7e5 } /* изменение цвета замещающего текста для input и textarea */
p::before, p::after { content: "♥"; } /* вставка сердечка перед контентом каждого блока p и после него */
p::first-line { color: #8ab7e5 } /* изменение первой строки блочного элемента (в данном случае p) */
p::first-letter { font-size: 24px; } /* изменение первой строки блочного элемента (в данном случае p) */
*::selection { background: #8ab7e5 } /* изменение цвета выделения текста */
*::-webkit-scrollbar-thumb { background: #8ab7e5 } /* изменение цвета ползунка полосы прокрутки в браузерах на движке webkit */
```

*Псевдоклассы* выбирают элементы, находящиеся в определённом состоянии. Они всегда *начинаются с двоеточия*. Некоторые из них могут принимать *параметры*.
```css
input:focus {} /* любое поле ввода, находящееся в фокусе */
option:checked {} /* каждая отмеченная опция */
button:disabled {} /* каждая недоступная кнопка */
link:not(:visited) {} /* каждая непосещённая ссылка */
*:hover {} /* любой элемент при наведении на него */
```

Если *псевдокласс* или *псевдоэлемент* применяются *ко всем элементам*, то не рекомендуется пропускать *универсальный селектор* **\***, иначе может возникнуть путаница.  
Селекторы ниже *похожи*, но выбирают *совершенно разные* элементы:  
```css
 div:hover {} /* любой блок div, на который наведён курсор */
 div :hover {} /* ~ div *:hover (любой элемент, на который наведён курсор, располагающийся в блоке div) */
```

С помощью *псевдоклассов* также можно работать с *родительскими и дочерними* элементами:
```css
div:empty {} /* каждый блок без дочерних элементов */
div:not(:empty) {} /* каждый блок, имеющий дочерние элементы */
div:first-child {} /* каждый блок, являющийся первым ребёнком */
div:nth-child(3) {} /* каждый блок, являющийся третьим по счёту ребёнком */
div:last-child {} /* каждый блок, являющийся последним ребёнком */
div:only-child {} /* каждый блок, являющийся единственным ребёнком */
```

*Псевдоклассы* могут идти *последовательно* друг за другом:
```css
div:first-child:last-child /* эквивалентно :only-child */
```

Стоит также отметить, что некоторые *псевдоклассы* совпадают с *атрибутами* элементов, поэтому их можно заменить *селектором атрибутов*. Следующие строки *эквивалентны*:
```css
button:disabled {}
button[disabled] {}
```

### Применение CSS-селекторов в JavaScript (Selectors API)

*Selectors API* предоставляет методы, с помощью которых можно быстро и просто получить список узлов документа путем сопоставления с *группой селекторов*:
```javascript
// возвращает первый найденный Element или null, если совпадений не найдено
const element = parentNode.querySelector('selectors'); 
// возвращает NodeList, содержащий все найденные элементы, или пустой NodeList
const elementList = parentNode.querySelectorAll('selectors'); 

const root = document.querySelector('#root');
const articleTitles = root.querySelectorAll('.article > .title');
```
Параметр *selectors*  всегда  должен быть *валидной строкой CSS-селекторов*, в противном случае выдаётся исключение *SyntaxError*.


## Специфичность селекторов

*Специфичность селекторов* (selector's specificity) определяет их *приоритетность* в таблице стилей. Чем *специфичнее* селектор, тем *выше* его *приоритет*. 

Eсли в выборку *несколькими селекторами* попадают одни и *те же элементы* и затрагиваются одни и *те же свойства в блоках объявлений*, в конечном итоге применяются *значения свойств* из объявлений *более специфичного* селектора.

### Правила специфичности
* *Атрибут style*. Специфичность: *1000*.
* *Атбрибут id*. Специфичность: *100*.
* *Остальные атрибуты* (в том числе и *class*), а также *псевдоклассы*. Специфичность: *10*.
* *Типы элементов* и *псевдоэлементы*. Специфичность: *1*.
* *Универсальные селекторы*. Специфичность: *0*.

В случае *комбинации селекторов* специфичность *суммируется*. *Комбинирующие операторы* на специфичность *не влияют*:
```css
 * body #root .container ul > li:last-child::after { content: "."; } /* 124 = 0 + 1 + 100 + 10 + 1 + 1 + 10 + 1 */
```

В случае *группы селекторов* специфичность считается для каждого селектора *отдельно* и *не идёт в общую сумму*:
```css
.cell.white, /* 20 = 10 + 10 */
div /* 1 */
{ background: #000; } 
```

В случае *совпадения специфичности* будет браться тот селектор, который позже определен в таблице стилей.

* *Ключевое слово !important* позволяет *перекрывать любую специфичность*.  
```css
* { box-sizing: border-box !important; }
```

Если два селектора выбирают тот же элемент и соответствующие им блоки объявлений содержат то же свойство, а в обоих значениях свойств используется ключевое слово !important, в результате применится то правило, которое определено позже в таблице стилей.
```css
#article { padding: 24px !important; }
.article { padding: 16px !important; } /* применится это правило несмотря на то, что специфичность меньше */
```

Стоит отметить, что *порядок расположения стилей в class-атрибуте не важен*. В примере ниже *результат одинаковый*:
```html
<p class="title text"></p>
<p class="text title"></p>
```

## Некоторые правила хорошего тона при написании CSS

### Общие правила

*Правила специфичности* не так сложны при рассмотрении какого-то *конкретного* селектора. Но когда их *сотни* в одном файле, трудно слёту рассчитать, *какой стиль* будет *применён в итоге* или *как* отельный *селектор повлияет* на элементы страницы.

Есть некоторые *правила*, соблюдение которых поможет не только значительно *улучшить читабильность* кода, но иногда тем или иным образом *оптимизировать* его:
* Стараться использовать *только самые распространённые простые селекторы*, покрывающие практически любые случаи - *селекторы по классу*.
```css
.content p {} /* не очень хорошо */
.content #title {} /* лучше, но есть недочёты (будет сказано дальше) */
.content .title {} /* хорошо */
```
* То же самое касается и *комбинаторов*: в большинстве случаев лучше *ограничиться комбинатором потомков*.
```css
.content ~ .title {} /* результат не очень то предсказуем */
.content > .title {} /* можно иногда использовать, но не все о нём помнят, что сказывается на читаемости кода */
.content .title {} /* хорошо */
```
* *Малая вложенность селекторов*. Желательно, *не более двух селекторов* по классу (.родитель .ребёнок). Это упрощает разбор селектора и поиск элементов по нему как для вас, так и для браузера.
```css
.page .content .text-block .title {} /* плохо */
.text-block .title {} /* хорошо */
.text-block .title:hover {} /* тоже хорошо */
```
* Как можно *меньше использовать inline стили* (ведь их практически невозможно переопределить), вынося css код в классы:
```css
<p class="title" style="color:red">Text</p> /* плохо */
<p class="title title--red">Test</p> /* хорошо */
```

### Почему лучше избегать использования селекторов по id и использовать селекторы по классу

* Один *элемент не может иметь два идентификатора*, но *может иметь сколь угодно классов*.
```html
<!-- это не будет работать! -->
<p id="title header-title"></p>
<!-- это тем более! игнорирование или ошибка --> 
<p id="title" id="header-title"></p> 
<!-- а это работает -->
<p class="title header-title"></p>
```

* *Селектор по id* выбирает *лишь первый элемент на странице*.
```html
<div>
    <p id="title"></p>
    <!-- игнорирование или ошибка (идентификатор должен быть уникален) -->
    <p id="title"></p>
</div>
```

* Если есть лишь *селекторы по классу*, *специфичность вычисляется* довольно *просто*.
```css
.page {} /* 10 */
.content .title {} /* 10 + 10 = 20 */
.content .title:hover {} /* 10 + 10 + 1 = 21 */
```
Более того, мы имеем относительное равенство между селекторами (если их одинаковое количество): в случае конфликтов стили перезаписываются по мере расположения селекторов в коде (кто последний, тот и прав).  
В примере ниже специфичность совпадает, поэтому применится стиль, располагающийся ниже в коде.
```css
.page .title {} /* 10 + 10 */
.content .title {} /* 10 + 10 = 20 (применится этот) */
```
В случае же использования идентификаторов, количество возможных комбинаций возрастает, а код частично теряет свою последовательность:
```css
#page #title {} /* 100 + 100 = 200 (может перезаписать все стили, располагающиеся ниже по коду) */
.page #title {} /* 10 + 100 = 110 */
 #page .title {} /* 100 + 10 = 110 */
.page .title {} /* 10 + 10 = 20 */
```

### Скорость выполнения селекторов браузерами

# Подходы к написанию CSS

## БЭМ

**Блок-Элемент-Модификатор** (БЭМ) - самая популярная *методология CSS* на данный момент.

* **Блок** - *переиспользуемый элемент* сайта.
* **Элемент** - некоторая *часть блока*, *не* имеющая *функционального смысла вне* блока.
* **Модификатор** - *свойство блока* или *элемента*, меняющие его *внешний вид* или *поведение*.

Возможный *синтаксис БЭМ*
```css
.block_element-modifier {}
/* или */
.block__element--modifier {}
```

### БЭМ в CSS
```css
.page {} /* блок */
.page__content {} /* элемент */

.content {} /* блок */

.articles {} /* блок */

.article {} /* блок */
.article__title {} /* элемент */
.article__title--bold {} /* модификатор */
.article__title--red {} /* модификатор */
.article__image {} /* элемент */
.article__image--small {} /* модификатор */
.article__image--large {} /* модификатор */
```
### БЭМ в SCSS
```scss
.page {
  /* any css for .page */
  
  &__content {
    /* any css for .page__content */
  }
}

.content {}

.articles {}

.article {
  /* any css for .article */

  &__title {
    /* any css for .article__title */

    &--bold {
      /* any css for .article__title--bold */
    }

    &--red {
      /* any css for .article__title--red */
    }
  }
}
```

Стоит отметить, что *любой DOM-элемент* в рамках БЭМ может быть и *блоком*, и *элементом* *одновременно*.  
В примере ниже *div* является *блоком article* и *элементом item блока content*
```html
<div class="content">
  <div class="content__item article">
    <p class="article__title"></p>
  </div>
</div>
```

### Преимущества и недостатки БЭМ
*Преимущества БЭМ*
* *Модульность* кода и *изолированность модулей* друг от друга.  
* *Простая специфичность*.  

*Недостатки БЭМ*
* Слишком *длинные названия классов*.

### Пример использования *БЭМ* с *React*
```js
import React from 'react';

const articles = [{ title: 'BEM' }, { title: 'React' }];

const renderArticle = (item, index) => (
  <div className="article" key={index}>
    <p className="article__title">
      <span className="article__title--red">{`Article #${index}:`}</span>
      {item.title}
    </p>
    <img className="article__image" />
  </div>
);

const Articles = () => (
  <div className="articles">
    {articles.map(renderArticle)}
  </div>
);

const render = () => (
  <div className="page">
    <div className="page__content content">
      <Articles />
    </div>
  </div>
);
```

## OOCSS

**Объектно-Ориентированный CSS** (Object Oriented CSS, OOCSS) — *подход*, использующий *преимущества ООП* в *CSS*.  

Основная *идея* заключается в *переиспользуемости кода*: *принцип Don't Repeat Yourself* (DRY).

**Объектом** в этом подходе выступает *любой визуально повторяющийся шаблон*, который можно выделить как *фрагмент кода*.

*Элементы* страницы задаются *объектными классами*, являющиеся *отдельными объектами* в таблицах стилей.

В отличие от многих, подход *OOCSS не устанавливает правил наименования* классов; *не запрещает* использовать тэги, id и прочее, что позволяет *сочетать* его с *другими подходами*.

### Первое правило подхода OOCSS: разделение Структуры и Оформления

**Структура** (Structure) — совокупность *невидимых* для пользователя *свойств* элемента.  
Пример *структурных свойств*: height, width, margin, padding, overflow (размер, позиционирование и прочее).

**Оформление** (Skin) — совокупность *видимых свойств* элемента.  
Пример *свойств оформления*: color, font, shadow, gradient.  

Другими словами: *структура* состоит из инструкций о том, *как* все *расположено*, а *оформление* определяет, *как выглядит* макет.

Такое *разделение* позволяет *размещать* копию объекта в *любое место* сайта, *не переопределяя* при этом *существующие стили*.  
Эта копия *расширяется дополнительными стилями* через *class-атрибут* (часто сразу *несколькими классами*).

### Второе правило подхода OOCSS: разделение Контейнера и Контента

**Контентом** является любой элемент, расположенный в каком-то другом элементе.  
**Контейнер** — этот другой элемент.
```css
.container .content
```
Суть заключается в том, чтобы *использовать комбинатор потомков* как можно *реже*.  
Если *контент не зависит* от конкретного *контейнера*, мы можем *переиспользовать код чаще*.

Например, вместо
```css
.sidebar {}
.sidebar .menu {}
.sidebar .menu .menu-item {}
```
можно *разделить контейнер и контент* следующим образом
```css
.sidebar {}
.menu {}
.menu-item {}
```
что даёт возможность использовать *меню* где-нибудь ещё.

### OOCSS в CSS
Ищем *повторяющиеся блоки кода*:
```css
.button {
  width: 100px;
  height: 40px;
  padding: 4px 8px;
  background-color: #000;
  border-radius: 4px;
  color: #fff;
}

.button-wide {
  width: 200px;
  height: 40px;
  padding: 4px 8px;
  background-color: #000;
  border-radius: 5px;
  color: #fff;
}
```
```html
<div class="button"></div>
<div class="button-wide"></div>
```
*Выносим* их в *классы*:
```css
.skin-button {
  background-color: #000;
  border-radius: 4px;
  color: #fff;
}

.structure-button {
  height: 40px;
  padding: 4px 8px;
}

.button {
  width: 100px;
}

.button-wide {
  width: 200px;
}
```
```html
<div class="button skin-button structure-button"></div>
<div class="button-wide skin-button structure-button"></div>
```
### OOCSS в SCSS
При использовании *OOCSS* с *чистым CSS*, *атрибут class* у DOM-элементов сильно *разрастается*, но что, если...
```scss
@mixin skin-button {
  background-color: #000;
  border-radius: 4px;
  color: #fff;
}

@mixin structure-button {
  height: 40px;
  padding: 4px 8px;
}

.button {
  @include skin-button;
  @include structure-button;
  width: 100px;
}

.button-wide {
  @include skin-button;
  @include structure-button;
  width: 200px;
}
```
```html
<div class="button"></div>
<div class="button-wide"></div>
```
Хотя, имея в арсенале *миксины*, можно сделать *ещё лучше* (не совсем OOCSS) в этом примере:
```scss
@mixin button-defaults {
  background-color: #000;
  border-radius: 4px;
  color: #fff;
  height: 40px;
  padding: 4px 8px;
}

.button {
  @include button-defaults;
  width: 100px;
}

.button {
  @include button-defaults;
  width: 200px;
}
```

### Преимущества и недостатки OOCSS
*Преимущества OOCSS*
* Хорошая *переиспользуемость кода*.  

*Недостатки OOCSS*
* *Сильная связанность кода ухудшает* его *поддержку*: *классы* достаточно *общие*, могут использоваться *повсеместно* (нельзя просто изменить их, скорее всего придётся менять разметку).

## SMACSS

**SMACSS** — *масштабируемая и модульная архитектура для CSS* (Scalable and Modular Architecture for CSS).

Идея заключается в *разбиении стилей на категории*, чтобы *уменьшить количество кода* и *улучшить* его *поддержку*.

Стили разбиваются на *5 категорий*:
* **Базовые стили** (base rules) — стили *основных элементов* страницы. Обычно *тэги* (body, div, input, ...), *псевдоклассы* и *псевдоэлементы*, *атрибуты кроме class и id* (изредка class: например, стилизация custom select).
```css
/* базовые стили */
input {}
input:focus {}
*:hover {}
*::selection {}
```
* **Стили макета** (layout rules) — стили *глобальных элементов* страницы (header, footer, sidebar, ...), *разбивающих страницу* на *блоки с контентом*, состоящие из *модулей*. Автор подхода предлагает *использовать id*, чтобы подчеркнуть *уникальность* элементов, но можно этого *не делать*. *Префикс*: `layout-`, `l-` или `grid-`.
```css
#main { width: 40%; } /* глобальный элемент */
#header { width: 100%; } /* глобальный элемент */

/* стили макета ниже навешивается на предков глобальных элементов (например, на body) */
.l-fixed #main { width: 320px; }
.l-fixed #header { width: 320px; }
```
* **Стили модулей** (modules rules) — стили *переиспользуемых блоков* страницы. Автор подхода советует *избегать* здесь *тэгов* и *id*. *Префикс*: `module-`, где *module* — *название модуля*.
```css
/* стили модуля */
.article {}
.article div {}
.article-title {}
.article-img
```
```html
<div class="article">
  <p class="article-title"></p>
  <img class="article-img" />
  <div></div>
</div>
```
* **Стили состояния** (state rules) — различные *состояния модулей* и *структуры* сайта. Автор *допускает* использование `!important` только в этом разделе. *Префикс*: `is-`.
```css
/* стили состояния */
.button.is-disabled {}
.tab.is-active {}
#sidebar.is-mobile {}
.is-hidden {}
```
* **Стили темы** (theme rules) — некоторые *дополнительные стили*, описывающие, *как модули* и *макет* могут *выглядеть*. Обычно *меняются* время от времени. *Необязательная категория* (стили могут быть уже учтены в других категориях). 
```css
/* article.css */
.article-title { color: #000; }

/* theme.css */
.article-title { color: #ff0000; } /* меняем цвет с чёрного на красный в честь какого-то события */
```
Обычно на *каждую категорию* отводится *отдельный файл*: `base.scss`, `layout.scss`, `module-name.scss`, `state.scss`, `theme.scss`.

## Atomic CSS

**Атом** является *мельчайшей частицей вещества*.

**Атомный CSS** (Atomic CSS) — подход, похожий на *OOCSS*, где в качестве объекта выступает *одно объявление* (свойство: значение), *отражающееся в названии класса*.
```css
.Mt-4 { margin-top: 8px; }
.Fs-16 { font-size: 16px; }
.W-320 { width: 320px; }
```
```html
<p class="mt-4 fs-16 w-320"></p>
```
*Атомный CSS* хорошо подходит для тех, кто хочет *писать макет* и *стили в одном месте*.

Тем не менее, *вручную* писать код с таким подходом *не* очень *удобно*, поэтому существует *инструмент* [Atomizer](https://github.com/acss-io/atomizer), который *рекурсивно обходит html* файлы и *генерирует* весь *необходимый css*.

*Классы*: [reference](https://acss.io/reference)  
*Псевдоклассы*: `a` — `:active`, `c` — `:checked`, `f` — `:focus`, `h` — `:hover`.  
*Псевдоэлементы*: `a` — `::after`, `b` — `::before`, `fl` — `::first-letter`, `fli` — `::first-line`, `ph` — `::placeholder`.  
*Комбинаторы*: `_` — комбинатор *потомков*, `>` — комбинатор *детей*, `+` — комбинатор *братьев*.  

### Atomic CSS и CSS

*Синтаксис html* в случае использования *Atomizer* следующий
```html
<div class="D(f) Jc(c) Op(0.8):h"></div>
<div class="article">
    <p class="article_C(red)"></p>
</div>
```
*Atomizer* при запуске просмотрит html и автоматически *сгенерирует* css
```css
.D\(f\) {
  display: f;
}

.Jc\(c\) {
  justify-content: center;
}

.Op\(0\.8\)\:h:hover {
  opacity: 0.8;
}

.article .C\(red\) {
  color: red;
}
```

### Преимущества и недостатки Atomic CSS
*Преимущества OOCSS*
* Относительно хорошая *переиспользуемость кода* (изменил значение в одном месте, изменилось везде).  
* *Специфичность*: лучше, чем использование inline стилей, поскольку здесь стили хранятся в сгенерированных css файлах.
* Можно настроить *пользовательские переменные* в Atomizer:
```JSON
{
  "1": "1px solid #000",
  "foo": "2px dotted #f00",
}
```


*Недостатки OOCSS*
* *Названия классов* содержат *описание объявления*, а не *суть элемента*, что усложняет разработку.
* К пункту выше можно добавить, что атрибуты *class* могут достигать *невероятных размеров* с *увеличением количества объявлений*.
* *Управление отображением* элемента находится в *HTML* (отвечающим за разметку), а должно оставаться в *CSS*.
* *Нет встроенной поддержки* некоторых вещей, в том числе и *grid* (нужно либо подключать дополнение или писать самому).

## AMCSS

**Модули атрибутов для CSS** (Attribute Modules for CSS, AMCSS) — подход, использующий *атрибуты и их значения вместо классов*.

Как и в многих других методологиях, идея AMCSS заключается в *логической группировке CSS* кода.  
* **Модули** (Modules) — замена классам; описываются атрибутами; похожи на блоки и элементы в БЭМ.
* **Вариации** (Variations) — различные состояния модулей; представлены значениями атрибутов; похожи на модификаторы в БЭМ. 
* **Черты** (Traits) — коллекция значений, имеющих одну цель; похожи на SUIT utils.

Одной из *целей* подхода является исправление проблемы БЭМ со слишком длинными названиями классов.
```html
<!-- /* БЭМ * / -->
<div class="button button--large button--primary"></div>
<!-- /* AMCSS * / -->
<div am-Button="large primary"></div>
```
Префикс `am-` добавляется для того, чтобы не было конфликтов с другими атрибутами.

### Синтаксис AMCSS

*Черты* пишутся в *camelCase*, *модули* — в *PascalCase*.

Отношение *родитель-ребёнок* обозначаются *дефисом*.

В качестве *селектора* используется *селектор по атрибуту* `~=`, выбирающий элементы, *содержащие* необходимый *атрибут* и *указанные слова* (разделённые пробелами) в *значении атрибута*.  
Это позволяет создать поведение, аналогичное классам.

*Значения атрибутов*, подобно классам, *разделяются пробелами*, но при этом имеют *более широкий спектр допустимых символов*.

```html
<div am-traitName="name name2 mobile:name3"></div>
<div am-ModuleName></div>
<div am-ModuleName-ChildElement></div>
<div am-ModuleName="variation"></div>
```
```css
[am-traitName~="name"] {}
[am-traitName~="name2"] {}
[am-traitName~="name3"], .breakpoint-mobile [am-traitName~="mobile:name3"] {}

[am-ModuleName] {
  /* Стили модуля (блока) */
}
[am-ModuleName~="variation"] {
  /* Стили вариации модуля ModuleName */
}

[am-ModuleName-ChildElement] {
  /* Стили дочернего элемента модуля ModuleName */
}
```

Стоит обратить внимание, что *вариация не может существовать без базовых стилей модуля*.  
*Любой* элемент, удовлетворающий второму селектору в примере ниже, удовлетворяет и первому тоже.
```css
[am-ModuleName] {} /* базовый атрибут и его стили */
[am-ModuleName~="variation"] {}
```
*Черта* же *не имеет стилей в базовом атрибуте*, но зато *черты* можно *смешивать* и *сочетать* в *любом* месте кода.
```css
[am-traitName~="name"] {}
```

Существует так же *другой синтаксис AMCSS*, более *близкий к БЭМ*, но *теряющий* некоторые *преимущества*:
```html
<div am-ModuleName am-ModuleName-variation></div>
```
```css
[am-ModuleName] {}
[am-ModuleName-variation] {}
```
### AMCSS и CSS
Модули и вариации
```html
<div am-Article>
  <p am-Article-Title="red translucent"></p>
</div>
```
```css
[am-Article] {
  display: flex;
}

[am-Article-Title] {
  margin: 0;
}

[am-Article-Title~="red"] {
  color: #ff0000;
}

[am-Article-Title~="translucent"] {
  opacity: 0.5;
}
```
Черты
```html
<p am-font="primary" am-color="red"></p>
```
```css
[am-font~="primary"] {
  font-size: 18px;
  font-weight: bold;
}

[am-color~="red"] {
  color: #c20606;
}
```
### Преимущества и недостатки AMCSS
Подход *похож на БЭМ*, поэтому обладает теми же *преимуществами*:

*Преимущества AMCSS*
* *Модульность* кода и *изолированность модулей* друг от друга.  
* *Простая специфичность*. (*специфичность* у *всех атрибутов*, в том числе и классов, одинаковая: *10*).  
* Решена проблема с *длинными названиями* классов, свойственная БЭМ.
```html
<div class="select__option select__option--first select__option--selected">
<div am-Select-Option="first selected">
```
* Информация о *разнородных стилях* не хранится в *одной строке*, теперь она *разбита по атрибутам*:
```html
<div class="list__item list__item--even article">
<div
  am-List-Item="even"
  am-Article
>
```
* Более *широкий спектр допустимых символов* в названиях вариаций.

*Недостатки AMCSS*
* Большая часть всего, что создавалось *ранее*, делалось на *классах*.  
Принципиально новый подход требует *других методов работы* не только с *CSS*, но и с *DOM* тоже.  
Может *пострадать поддержка* некоторых *библиотек*.  
* В случае использования *валидатора* для *проверки корректности кода*, нужно также добавлять *приставку* `data-`, что делает код длиннее.
```html
<div data-am-Article>
```

Если *рост количества классов* элемента *расширяет HTML в ширину*, то *рост количества атрибутов расширяет* его *в высоту*.  
Это *не является однозначным минусом или плюсом*, но код может сильно разрастить в случае активного использования черт, что может быть не просто исправить.  

## Динамический CSS

Многие *элементы DOM* имеют *больше одного класса*, причём некоторые из этих классов могут быть *динамическими* (появляются и исчезают из атрибутов *по условию*).  

Eсли ещё *несколько статических классов* можно записать в *строку*
```jsx
<div className="article__image article__image--large article__image--inverted">
```
то при появлении *условий* это может стать затруднительным (нужно не допускать появления лишних значений, пробельных символов и переносов строк).
```jsx
<div className={`article__image ${isLarge ? 'article__image--large' : ''} ${isInverted ? 'article__image--inverted' : ''}`}>
```
В этом случае можно прибегнуть к использованию *[библиотеки classnames](https://github.com/JedWatson/classnames)*
```js
import cx from 'classnames';
/* ... */
const articleImageClasses = cx({
  article__image: true,
  'article__image--large': isLarge,
  'article__image--inverted': isInverted,
});
/* или */
const articleImageClasses = cx('article__image', {
  'article__image--large': isLarge,
  'article__image--inverted': isInverted,
});
```
```jsx
<div className={articleImageClasses} />
```
*Функция cx* принимает *сколь угодно параметров*.  
Если в качестве *параметра* выступает *объект*, рассматриваются *его ключи и их значения*.  
*Ложные* (falsy) значения *игнорируются*.  
*Лишние пробельные символы убираются*.

# Препроцессоры и постпроцессоры CSS

## Препроцессоры

**Препроцессор** — компьютерная программа, принимающая данные на входе и выдающая данные, предназначенные для входа другой программы.

**CSS препроцессор** (CSS preprocessor) — программа, принимающая на входе свой собственный синтаксис (syntax) и генерирующая из него чистый CSS на выходе.  

Синтаксический сахар (от англ. syntactic sugar) — это дополнения синтаксиса языка программирования, которые не вносят каких-то существенных изменений или новых возможностей, но делают этот язык более читабельным для человека (альтернативное удобное использование того, что было доступно ранее).

Препроцессоры расширяют функционал чистого CSS, добавляя такие опции как: миксины, вложенные правила, селекторы наследования, переменные, функции, циклы и многое другие.  
Подобный дополнительный функционал упрощает написание, чтение и поддержку CSS кода.

Популярные препроцессоры:
* SASS
* LESS
* PostCSS
* Stylus

Для использования какого-либо CSS препроцессора нужно установить соответствующего CSS компилятор.

## Постпроцессоры

CSS постпроцессор делает практически то же самое, что и препроцессор, только на вход вместо специального синтаксиса поступает чистый css, а на выход его улучшенная версия.

На данный момент PostCSS является единственным постпроцессором.  
Без плагинов он ничего не делает, лишь возвращает данный на вход CSS файл.  
Каждый плагин каким-то образом изменяет CSS.

*Алгоритм работы PostCSS*
* CSS файл поступает на вход и парсится.
* Первый плагин как-то изменяет CSS.
* ...n-ый плагин как-то изменяет CSS...
* Последний плагин как-то изменяет CSS.
* Результат работы последнего плагина преобразуется в строку и записывается в выходной CSS файл.


### Плагины PostCSS

**Браузер** — *прикладное ПО*, созданное для *просмотра веб-страниц*, *веб-документов*, *файлов* и их *каталогов*; для *управления веб-приложениями* и многого другого.

**Поставщики браузеров** (browser vendors), **вендоры** — *создатели веб-браузеров*.

**Вендор префиксы** (vendor prefixes), **браузерные префиксы** *добавляют поддержку экспериментальных* браузерных *технологий*, которые на данный момент *не входят в стандарт*.

Самые *популярные браузеры* используют следующие *префиксы*:
* `-webkit-` — Chrome, Safari, новые версии Opera.  
* `-moz-` — Firefox.  
* `-o-` — старые версии Opera.
* `-ms-` — IE, Edge.

Стоит так же отметить, что каждый браузер реализует свойства с префиксами *по-своему*, поэтому *поведение* этих свойств в *различных* браузерах может *не совпадать*.

*Плагин* **Autoprefixer** добавляет *браузерные префиксы* к правилам CSS, используя значения сайта [Can I Use](https://caniuse.com/).
```css
.animated-element {
  -o-transition: all 4s ease;
  -webkit-transition: all 4s ease;
  -ms-transition: all 4s ease;
  -moz-transition: all 4s ease;
  transition: all 4s ease;
}
```
*Плагин* **Preset Env** позволяет конвертировать современный, ещё не поддерживаемый целевыми браузерами CSS код в то, что они смогут понять, определяя необходимые полифиллы на основании целевых браузеров или сред выполнения.

Ниже представлены возможности, которые ещё не попали в стандарт, но уже могут использоваться с плагином:
```css
a {
  all: initial; /* сбрасывает все свойства элементов a */
}

/* псевдонимы (aliases) для at-rules */
@custom-media --mobile (max-width: 420px);
@media (--narrow-window) {}
@custom-selector :--heading h1, h2, h3, h4, h5, h6;
article :--heading {}

/* пользовательские свойства */
.title {
  --size: 20px;
  font-size: var(--size);
}
```

*Плагин* **cssnano** позволяет значительно *оптимизировать CSS* код (иногда в несколько раз).
До работы плагина
```scss
h1::before, h1:before { /* normalize selectors */
  margin: 10px 20px 10px 20px; /* reduce shorthand even further */
  color: #ff0000; /* reduce color values */
  font-weight: 400;
  font-weight: 400; /* remove duplicated properties */
  background-position: bottom right; /* reduce position values */
  background: linear-gradient(to bottom, #ffe500 0%, #ffe500 50%, #121 50%, #121 100%); /* reduce gradient parameters */
  min-width: initial; /* replace initial values */
}
@charset "utf-8"; /* correct invalid placement */
```
После
```css
@charset "utf-8";h1:before{margin:10px 20px;color:red;font-weight:400;background-position:100% 100%;background:linear-gradient(180deg,#ffe500,#ffe500 50%,#121 0,#121);min-width:0}
```

*Плагин* **Pre CSS** — *пак PostCSS плагинов*, позволяющий использовать *SASS-подобный синтаксис*.  
```scss
$gray: #24292e;

.menu {
  &__bg {
    background: $gray;
  }
}
```

**Stylelint** — мощный *CSS линтер*, который предупреждает об *ошибках в CSS*, делает *замечания* о том, что можно сделать лучше, вносит *соглашения по стилю кода* внутри проекта.  
Данный линтер использует под капотом PostCSS для парсинга кода и существует в виде PostCSS плагина.  

Таким образом, *PostCSS* изначально *ближе* к *чистому CSS*, но с помощью определённых *плагинов* может обладать *той же* *функциональностью*, что и *препроцессоры*.

###
