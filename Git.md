- [Основные понятия Git](#основные-понятия-git)
	- [Состояния файлов](#состояния-файлов)
	- [Три области Git](#три-области-git)
	- [Ветвление](#ветвление)
- [Основные команды Git](#основные-команды-git)
	- [merge](#merge)
		- [Как работает merge](#как-работает-merge)
		- [Fast-forward merge](#fast-forward-merge)
		- [True merge](#true-merge)
		- [Конфликты при true merge и их разрешение](#конфликты-при-true-merge-и-их-разрешение)
	- [rebase](#rebase)
		- [Как работает rebase](#как-работает-rebase)
		- [rebase vs merge](#rebase-vs-merge)
		- [Другие возможности rebase и интерактивный режим](#другие-возможности-rebase-и-интерактивный-режим)
	- [pull и fetch](#pull-и-fetch)
	- [Откат изменений с reset, checkout, revert](#откат-изменений-с-reset-checkout-и-revert)
- [Полезные возможности Git](#полезные-возможности-git)
	- [Отмена последнего коммита](#отмена-последнего-коммита)
	- [Перенос коммитов из одной локальной ветки в другую](#перенос-коммитов-из-одной-локальной-ветки-в-другую)
- [Git flow](#git-flow)
- [SSH Github & Gitlab](#ssh-github--gitlab)
- [Git Config](#git-config)
- [Git Bash](#git-bash)

# Основные понятия Git

**Git** — система контроля версий, то есть такая система, которая следит за изменениями файлов, позволяет фиксировать определённые состояния изменений и возвращаться к этим состояниями к дальшейшем.

В сравнении со всеми другими системами контроля версий, Git имеет уникальный подход к работе со своими данными. Все эти системы хранят набор файлов и их изменения (дельты) с течением времени.

## Состояния файлов

Git делит все файлы на *отслеживаемые* и *неотслеживаемые**. 

**Отслеживаемые** (tracked) файлы — файлы, которые были в последнем снимке состояния проекта, **неотслеживаемые** (untracked) файлы — все остальные.

Это зависит от того, отслеживает ли Git изменения конкретного файла или нет.

Также имеются категория игнорируемых файлов. Изменения этих файлов Git игнорирует. Чтобы сделать файл (директорию) игнорируемым, необходимо его добавить в файл `.gitignore`.

### Состояния отслеживаемых файлов

* **Неизменённый** (Unmodified). Файл не изменён.
* **Изменённый** (Modified). Файл изменён локально.
* **Подготовленный** (Staged). Файл изменён локально и помечен для включения в следующий коммит.
* **Зафиксированный** (Committed). Версия файла сохранена в истории Git.

## Три области Git
* **Рабочая директория** (Working Directory). Файлы распаковываются из сжатой базы данных репозитория и располагаются на локальном диске для чтения и записи. Здесь происходит работа с ними до тех пор, а затем они переходят
* **Область подготовленных файлов** (Staging Area). Здесь содержатся сведения о подготовленных файлах и их изменениях, которые должны попасть в следующий коммит. Эта область является частью папки .git.
* **Папка .git** (.git directory, Repository). Здесь хранятся метаданные (данные о данных) и Git-объекты текущего проекта, в том числе история коммитов.

**Индекс** (Index) — снимок следующего намеченного коммита.

## Ветвление

Все системы контроля версий поддерживают возможность ветвления.

**Ветка** (Branch) — активная линия разработки проекта. 

**Базовый коммит ветки** (Base commit) — коммит, с которого началась (была создана) ветка.

Изначально выбирается **основная ветка**, которая будет хранить в себе всю историю коммитов приложения (обычно `master`). Это не обязательно должна быть ветка, в которой создавался первый коммит, но обычно это так. 

От основной ветки создаются новые ветки. Базовым коммитом новой ветки становится последний в момент создания коммит основной ветки.

Суть ветвления заключается в том, что ветки могут развиваться независимо от основной, а затем, при необходимости, их изменения попадают в основную ветку слиянием. После слияния с основной веткой второстепенные ветки обычно удаляются.

Для управления ветками используется команда `branch`.
```js
/* создание ветки */
git branch staging

/* переименование ветки */
git branch -m staging pre-production

/* удаление ветки */
git branch -D pre-production
```

Для переключения между ветками используется команда `checkout`.
```js
/* переключение на ветку develop */
git checkout develop
```

Для слияния веток используется команда `merge`, о которой будет рассказано позже.

По сути, сама ветка является указателем на последний коммит, сделанный в этой ветке. Поскольку последний коммит знает своего родителя, а тот — своего, по последнему коммиту можно восстановить всю историю коммитов любой ветки.

**HEAD** — указатель на текущую ветку.

 Можно сказать, что *HEAD* — указатель на последний коммит текущей ветки и родитель следующего коммита соответственно.

`HEAD` может быть только один в один момент времени для всего проекта. 

Если открыть файл `HEAD` в папке `.git`, то можно увидеть, что он содержит ссылку на текущую ветку.
```js
cat .git/HEAD
/* ref: refs/heads/master */

checkout develop
cat .git/HEAD
/* ref: refs/heads/develop */
```

Если открыть папку `refs/heads`, то там можно видеть, что Git хранит для каждой ветки отдельный файл, в котором хранится хэш последнего коммита ветки.
```js
cat ./git/refs/heads/master
/* 1ed2bf4eebbcd0515a638b48550a7eb81c7c01e5 */
```

**Верхушка ветки** (Branch tip, Branch head) — самый последний коммит ветки. У каждой ветки есть одна вершутка.

# Основные команды Git

## merge

**Команда merge** позволяет слить истории двух веток в одну.

Слияние происходит из целевой ветки (target branch) в текущую рабочую ветку (current branch).
```js
git merge <target_branch>
```

Изменения после слияния веток появляются лишь в текущей ветке и не затрагивают целевую ветку.

### Как работает merge

Для начала Git просматривает цепочку коммитов обеих веток, пытаясь найти их общий коммит. Обычно такой коммит имеется (как минимум, начальный коммит).

Очень редко бывают случаи, когда между двумя ветками нет ни одного общего коммита. По умолчанию Git отказывается сливать такие ветки в одну, но можно использовать флаг `--allow-unrelated-histories`, который позволит это сделать.

Если общий коммит между двумя ветками найден, то возможны два случая
* Только в одной ветке были новые коммиты с момента общего коммита. В таком случае одна ветка является логическим продолжением другой. Используется стратегия `fast-forward merge`.
* Обе ветки имеют новые коммиты после общего. Это означает, что они развивались параллельно, независимо. Используется стратегия `true merge`.

### Fast-forward merge

Поскольку одна ветка является продолжением другой, указатель на верхушку короткой ветки сдвигается на нужное количество коммитов и становится равным указателю головы длинной ветки. Таким образом все коммиты из длинной ветки становятся доступными в короткой.
```js
/* до слияния веток develop и master целевая ветка develop была
впереди на 2 коммита C и D */
develop          |          C —— D
	         |         /
master (current) |   A —— B
```
```js
git checkout master
git merge develop
```
```js
/* после слияния верхушки веток указывают на один и тот же коммит D */
develop          |          C —— D
	         |         /
master (current) |   A —— B —— C —— D
```
Если отменить последний коммит в ветке `master`, то отменится только коммит `D`.
```js
/* отмена последнего коммита при помощи git reset HEAD~ */
develop          |          C —— D
	         |         /
master (current) |   A —— B —— C
```
Таким образом, чтобы отменить изменения, появившиеся в текущей ветке после слияния, необходимо удалить ровно столько коммитов, сколько было новых коммитов в целевой ветке.

При попытке слить короткую (`master`) в более длинную ветку (`develop`) ничего не прозойдёт: уже используются актуальные изменения.
```
git checkout develop
git merge master
```

Стратегия `fast-forward merge` не будет применена при мерже, если использовать флаг `--no-ff`. В этом случае будет применёна стратегия `true merge`.
```js
git merge --no-ff branch_name
```

### True merge

Если обе ветки при слиянии имеют свои коммиты с момента их общего коммита или если стоит флаг `--no-ff`, то Git использует стратегию **true merge**. В этом случае создаётся особый тип коммита, имеющий сразу двух родителей, — **merge commit**. В нём содержатся все изменения, которые появились в обеих ветках с момента общего коммита (включая изменения, которые возникли при разрешении конфликтов между двумя ветками). 

```js
/* до слияния веток с момента общего коммита B целевая ветка develop 
имеет 2 коммита C и D, текущая ветка master имеет один коммит E */
develop          |          C —— D
	         |         /
master (current) |   A —— B —— E
```
```js
git checkout master
git merge develop
```
```js
/* после слияния в текущей ветке master появился merge commit H,
содержащий в себе все изменения коммитов C, D, E */
develop          |           C —— D
	         |         /       \
master (current) |   A —— B —— E —— H
```
Как и в случае `fast-forward merge`, изменения `true merge` затрагивают только текущую ветку, поэтому им `merge commit` создаётся только в текущей ветке (коммит `H` появился только в `master`).

Аналогичный результат бы получился, если бы в ветку `develop` сливалась ветка `master`. Разница лишь в том, что в этом случае коммит `H` хранился бы только в `develop`.

Если из `master` удалить последний коммит, то всё вернётся, как было до слияния. Таким образом, чтобы отменить все изменения при слиянии двух веток стратегией `true merge`, достаточно удалить один коммит.
```js
/* отмена последнего коммита при помощи git reset HEAD~ */
develop          |          C —— D
	         |         /
master (current) |   A —— B —— E
```

### Конфликты при true merge и их разрешение

Если новые коммиты сливающихся веток затрагивают одни и те же файлы и по-разному изменяют их, возникают **конфликты** (merge conflicts). Git не может автоматически разрешить их, поскольку изменения производились параллельно. Разработчик должен сам решить, какие изменения стоит принять.

Пример конфликта в одном из файлов (в коммите `C` в файле использована переменная `const`, в коммите `E` — `let`).
```js
<<<<<<< HEAD (Current Change)
let name = 'Notes';
=======
const name = 'Notes';
>>>>>>> develop (Incoming Change)
```
Для отображения конфликта Git использует 3 версии
* `===` — состояние до обоих коммитов.
* `<<<` — изменения коммита текущей ветки.
* `>>>` — изменения коммита целевой ветки.

Чтобы разрешить конфликт, следует выбрать необходимые изменения и убрать всё лишнее. Например можно оставить следующую строку.
```js
let name = 'Notes';
```
Разрешённые конфликты добавляются в `merge commit`.

## rebase

### Как работает rebase

**Базовый коммит ветки** (Base commit) — коммит, с которого началась (была создана) ветка.

**Перебазирование** (Rebasing) — перемещение последовательности коммитов к новому базовому коммиту. 
```js
git rebase <base>
```

Перебазирование переписывает историю текущей ветки.

```js
/* до перебазирования целевая ветка develop по сравнению с master
имеет новый коммиты C и D, базовым для неё является коммит B */
develop (current) |          C —— D
	          |         /
master            |   A —— B —— E
```
```js
git checkout develop
git rebase master
```
<!--
```js
/* после перебазирования базовым коммитом для develop стал коммит E,
C* и D* - копии коммитов C и D, но с новым хэшем */
develop (current) |   A —— B —— E —— C* —— D*
	          |
master            |   A —— B —— E
```
-->
```js
/* после перебазирования базовым коммитом для develop стал коммит E,
C* и D* - копии коммитов C и D, но с новым хэшем */
develop (current) |                C* —— D*
	          |               /
master            |   A —— B —— E
```

Если бы перебазировался не `develop`, а `master`, то изменились бы все коммиты ветки `master` с момента их общего коммита с `develop` (в данном случае это только коммит `E`).
```js
/* после перебазирования базовым коммитом для develop стал коммит E,
C* и D* - копии коммитов C и D, но с новым хэшем */
develop (current) |          C —— D
	          |         /
master            |   A —— B —— C —— D —— E*
```

По примерам выше понятно, что rebase переписывает историю: все новые коммиты перебазируемой ветки изменяются. Отменить последствия `rebase` невозможно (хэш старых коммитов уже утерян).

При перебазировании возможны такие же конфликты, как и при `true merge`. 

### rebase vs merge

Команда merge сохраняет историю
* True merge создаёт дополнительный merge commit, который объединяет две ветки.
* Fast-forward merge тожее сохраняет историю, копируя ссылки на коммиты из одной ветки в другую.  

Rebase перемещает базовый коммит ветки на другой коммит.

Merge при параллельном изменении нескольких веток создаёт merge коммиты, которые загрязняют историю Git. 

Rebase позволяет достигнуть линейной истории путём её постоянного изменения, всегда размещая новые ветки в конце базовой. А с линейной историей проще работать.

Основной проблемой rebase является то, что все изменения истории относится только в текущей ветке. Если rebase затронет коммиты, которые не были созданы в текущей ветке, то при слиянии с другой веткой Git увидит две разные истории и создаст большой merge commit, который использует обе версии (дублирование одних и тех же изменений).

Таким образом, rebase лучше использовать только для новых коммитов, если есть необходимость как-то подправить их. Если затрагиваются коммиты, которые имеются в других ветках и в будущем есть вероятность того, что эти ветки будут смержены с перебазируемой веткой, лучше не использовать rebase.

### Другие возможности rebase и интерактивный режим

## pull и fetch

**Команда git fetch** используется для того, чтобы получить информацию о последних изменениях на удалённой ветке (`origin/`). Таким образом можно узнать, были ли изменения вообще.
```js
git fetch
/*
From github.com:YourName/RepositoryName
   2eefe71..ac391ab  develop   -> origin/develop
   fca7c62..c31477c  feature/1 -> origin/feature/1
 * [new branch]      feature/2 -> origin/feature/2
 * [new branch]      feature/3 -> origin/feature/3
*/
````
Выше можно видеть, что ветки `develop` и `feature/1` отличаются от своих одноимённых удалённых веток хэшем последних коммитов, а ветки `feature/2` и `feature/3` новые и их нет локально.

Команда `git fetch` помимо информации об изменениях скачивает и сами изменения, но их не слияние с локальной веткой не происходит. Это можно проверить командой `git diff`.
```js
git diff origin/develop
/*
diff --git a/Git.md b/Git.md
index abe21d5..e207862 100644
+++ b/client/Dockerfile
- Hello
+ Hello, Notes!
*/
```

Повторный вызов команды `git fetch` ничего не выведет, поскольку изменения уже были подгружены.

**Команда git pull** также, как и `git fetch` получает изменения и информацию о них, но дополнительно сливает изменения в локальную ветку.

По сути, `git pull` объединяет в себе две команды: `git fetch` и `git merge`.

## Откат изменений с reset, checkout и revert

Обычно `HEAD` указывает на верхушку ветки (branch tip).

**Detached HEAD** — специальный тип HEAD, который может быть установлен пользователем, чтобы посмотреть, как выглядит изменения на определённом коммите в ветке.

Все три команды reset, checkout, revert позволяют откатывать (undo) изменения, но делают это по-разному.

**Команда checkout** перемещает указатель HEAD.

```js
/* до checkout HEAD ветки совпадал с верхушкой (tip) 
ветки master и указывал на коммит E */
                     (HEAD,
	             master)        
A ——— B ——— С ——— D ——— E
```
```js
git checkout B
```
```js
/* после checkout */
  (detached
     HEAD)           (master)
A ——— B ——— С ——— D ——— E
```
Если ввести `git branch`, то он выдаст ветку `(HEAD detached at B)`.

Если ввести `git log`, то коммит B в текущей ветке будет последним.
```js
/* git log */
    (HEAD)
A ——— B
```
Таким образом, при помощи команды `checkout` Git позволяет переключиться на определённый снимок проекта в прошлом, не изменяя при этом реальную ветку. Можно сделать какие-то тестовые изменения, посмотреть или скопировать какие-то файлы, а затем вернуться на полную версию ветки.

**Команда revert** выбирает коммит и создаёт новый коммит, который откатывате изменения выбранного коммита.
```js
/* до revert */
	        (HEAD,
	        master)        
A ——— B ——— С ——— D
```
```js
git revert C
```
```js
/* после revert создаётся коммит E, отменяющий все изменения коммита D,
и таким образом возвращающий состояние проекта на момент коммита B */
	              (HEAD,
	              master)        
A ——— B ——— С ——— D ——— E
```
Если при помощи `revert` откатывается не последний коммит (например, C), то могут появиться конфликты (поскольку коммит D зависеть от некоторых изменений коммита C).

Команда `revert` является безопасным вариантом для отката изменений в публичном репозитории, поскольку коммиты не удаляются, а создаются — история не перезаписывается.

**Команда reset** сбрасывает все изменения и историю до определённого коммита.
```js
/* до reset */
	        (HEAD,
	        master)        
A ——— B ——— С ——— D
```
```js
git reset B
```
```js
/* после reset */
   (HEAD,
   master)        
A ——— B
```
## Полезные возможности Git

<!--
### Команда reset
### Команда stash
-->

### Отмена последнего коммита
```sh
git reset HEAD~
```

### Перенос коммитов из одной локальной ветки в другую

Например, перенос N коммитов из локальной ветки A и локальную ветку B.
```sh
git checkout B
git merge from A
git checkout A
git reset --hard HEAD~N # удаление N коммитов из ветки A
```

## Git flow

**Фича** (Feature) — новая функциональность. 

### Разработка новой фичи
* Разработка новых фич начинается с ветки `develop`, от которой создаётся новая ветка `feature/name`, где `name` - название фичи.
* Разработчик переключается на новую ветку и начинает работать с ней.
* После завершения фичи создаётся Pull Request.
* Ветка `feature/name` сливается с (merge into) веткой `develop`. 
* Ветка `feature/name` удаляется.
* Разработчик переключается обратно на ветку `develop`.

### Релиз в production
* От ветки `develop` создаётся ветка `release/vX.X.X`.
* Ветка `release/vX.X.X` при необходимости помечается тэгом `vX.X.X`.
* Разрешены мелкие исправления (minor bug fixes) в ветке `release/vX.X.X`.
* Ветка `release/vX.X.X` сливается с веткой `master`.
* Ветка `release/vX.X.X` сливается обратно (back-merge) с веткой `develop`.
* Ветка `release/vX.X.X` удаляется.
* Разработчик переключается обратно на ветку `develop`.

## Hotfix в production
* Если в production найден серьёзный баг, который нужно быстро исправить, от ветки `master` создаётся ветка `hotfix/name`, в которой делаются необходимые исправления.
* Ветка `hotfix/name` сливается с веткой `master`.
* Ветка `hotfix/name` сливается с веткой `develop`.
* Ветка `hotfix/name` удаляется.


## SSH Github & Gitlab

* Открыть Bash.

### Генерация ключей
* Сгенерировать ключ для Github при помощи `ssh-keygen -t rsa -C "email" -f ~/.ssh/id_rsa_github`, где нужно заменить `email` на свой. `id_rsa_github` - название файла, где будет лежать приватный ключ. Команда также автоматически генерирует публичный ключ `id_rsa_github.pub` в той же папке.
* Ввести ключевую фразу и повторить её.

* Сгенерировать ключ для Gitlab при помощи `ssh-keygen -t rsa -C "email" -f ~/.ssh/id_rsa_gitlab`, где нужно заменить `email` на свой.
* Ввести ключевую фразу и повторить её.

### Cоздание ключа на Github
* Скопировать публичный ключ `~/.ssh/id_rsa_github.pub` для Github. Например, вывести его на экран при помощи `cat ~/.ssh/id_rsa_github.pub` и скопировать через `Ctrl + C`.
* Открыть на Github [Settings > SSH keys](https://github.com/settings/keys) и нажать на добавление нового ключа.
* Вставить скопированный ключ, придумать название для него и сохранить.

### Cоздание ключа на Gitlab
* Скопировать публичный ключ `~/.ssh/id_rsa_gitlab` для Gitlab.
* Открыть на Gitlab `Settings > SSH keys`.
* Вставить скопированный ключ, придумать название для него и сохранить.

### Добавление ключа в SSH-agent
* Добавить SSH-ключ для GitHub в SSH-agent `ssh-add ~/.ssh/id_rsa_github`. Если агент не запущен, то нужно сперва его запустить `eval $(ssh-agent -s)` или `ssh-agent bash`.
* Добавить SSH-ключ для GitLab в SSH-agent `ssh-add ~/.ssh/id_rsa_gitlab`.
* Проверить, что ключи добавлены через `ssh-add -L`.

Если для каждой новой консоли запускать агент и добавлять ключ приходиться заново, то можно настроить *псевдоним*.

**Псевдоним** (Alias) — аббревиатура, позволяющая избежать написания длинной последовательности команд.
* Создадим файл `.bashrc` в корневой папке (в Windows: `C:/Users/<USERNAME>/) и поместим там следующее.
```bash
alias sa="eval `ssh-agent -s` ssh-add ~/.ssh/id_rsa_gitlab"
```
Теперь каждый запуск команды `sa` в любой консоли Bash будет выполнять запуск агента и добавление ключа.

### Конфигурация

* Создать файл `touch ~/.ssh/config`.
* Вставить туда следующее
```
# config for github
Host github.com
   HostName github.com
   User git
   IdentityFile ~/.ssh/id_rsa_github
# config for gitlab
Host gitlab.com
   HostName gitlab.com
   User git
   IdentityFile ~/.ssh/id_rsa_gitlab
```
* Сохранить изменения.

### Проверка
* Попробовать сделать `git pull` через SSH.
* Дополнительная проверка для Github: `ssh -T git@github.com` (режим отладки: `ssh -T git@github.com`).
* Дополнительная проверка для Gitlab: `ssh -T git@gitlab.com` (режим отладки: `ssh -T git@gitlab.com`).

## Git Config

### Вывод конфига
```
git config -l
```

### Имя пользователя и почта
```js
/* имя пользователя */
git config --global user.name "Your Username"
/* электронная почта */
git config --global user.email "your@email"
```

## Git Bash
**Командная оболочка** (Shell) — терминальное приложение (terminal app), используемое для взаимодействия с ОС посредством письменных команд.

**Bash** (Bourne again shell, "Born again shell", "возрождённый" shell) — *усовершенствованная версия* ранней *командной оболочки Bourne shell*, исполняющей файлы формата `.sh` в `UNIX`. *Bash* является командной оболочкой *по умолчанию* для *Linux* и *macOS*.

**Git Bash** — пакет, *устанавливающий Bash*, некоторые *базовые утилиты* и *Git* на *Windows*.

### Убить запущенный процесс
Чтобы на *определённом порте* *убить запущенный процесс*, нужно узнать его **PID** (Process Identifier).
```css
netstat -ano | findstr :PORT /* например, :3000 */
/* Скопировать PID из последнего стобца результата и вставить в команду ниже */
tskill PID
```
