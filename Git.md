- [Основные понятия Git](#основные-понятия-git)
	- [Состояния файлов](#состояния-файлов)
	- [Три области Git](#три-области-git)
	- [Ветвление](#ветвление)
- [Основные команды Git](#основные-команды-git)
	- [merge](#merge)
		- [Как работает merge](#как-работает-merge)
		- [Fast-forward merge](#fast-forward-merge)
		- [True merge](#true-merge)
	- [rebase](#rebase)
		- [Как работает rebase](#как-работает-rebase)
		- [rebase vs merge](#rebase-vs-merge)
		- [Другие возможности rebase и интерактивный режим](#другие-возможности-rebase-и-интерактивный-режим)
	- [pull и fetch](#pull-и-fetch)
	- [Откат изменений с reset, checkout, revert](#откат-изменений-с-reset-checkout-и-revert)
- [Полезные возможности Git](#полезные-возможности-git)
	- [Отмена последнего коммита](#отмена-последнего-коммита)
	- [Перенос коммитов из одной локальной ветки в другую](#перенос-коммитов-из-одной-локальной-ветки-в-другую)
- [Git flow](#git-flow)
- [SSH Github & Gitlab](#ssh-github--gitlab)
- [Git Config](#git-config)
- [Git Bash](#git-bash)

# Основные понятия Git

**Git** — система контроля версий, то есть такая система, которая следит за изменениями файлов, позволяет фиксировать определённые состояния изменений и возвращаться к этим состояниями к дальшейшем.

В сравнении со всеми другими системами контроля версий, Git имеет уникальный подход к работе со своими данными. Все эти системы хранят набор файлов и их изменения (дельты) с течением времени.

## Состояния файлов

Git делит все файлы на *отслеживаемые* и *неотслеживаемые**. 

**Отслеживаемые** (tracked) файлы — файлы, которые были в последнем снимке состояния проекта, **неотслеживаемые** (untracked) файлы — все остальные.

Это зависит от того, отслеживает ли Git изменения конкретного файла или нет.

Также имеются категория игнорируемых файлов. Изменения этих файлов Git игнорирует. Чтобы сделать файл (директорию) игнорируемым, необходимо его добавить в файл `.gitignore`.

### Состояния отслеживаемых файлов

* **Неизменённый** (Unmodified). Файл не изменён.
* **Изменённый** (Modified). Файл изменён локально.
* **Подготовленный** (Staged). Файл изменён локально и помечен для включения в следующий коммит.
* **Зафиксированный** (Committed). Версия файла сохранена в истории Git.

## Три области Git
* **Рабочая директория** (Working Directory). Файлы распаковываются из сжатой базы данных репозитория и располагаются на локальном диске для чтения и записи. Здесь происходит работа с ними до тех пор, а затем они переходят
* **Область подготовленных файлов** (Staging Area). Здесь содержатся сведения о подготовленных файлах и их изменениях, которые должны попасть в следующий коммит. Эта область является частью папки .git.
* **Папка .git** (.git directory, Repository). Здесь хранятся метаданные (данные о данных) и Git-объекты текущего проекта, в том числе история коммитов.

**Индекс** (Index) — снимок следующего намеченного коммита.

## Ветвление

Все системы контроля версий поддерживают возможность отклонения (ответвления) от основной ветки и продолжать разработку независимо от неё. 

**Ветка** (Branch) — активная линия разработки проекта. 

Когда все необходимые изменения в новой ветке будут сделаны, она может снова слиться с основной веткой.

**HEAD** — указатель на текущую ветку. Текущая ветка является указателем на последний коммит, сделанный в этой ветке. Можно сказать, что *HEAD* — снимок последнего коммита текущей ветки и родитель следующего коммита. 

**Верхушка ветки** (Branch tip, Branch head) — самый последний коммит ветки. У каждой ветки есть одна вершутка.

# Основные команды Git

## merge

Команда `git merge` позволяет слить истории двух веток в одну.

Таким образом процесс разработки может происходить параллельно в разных ветках, затем эти ветки сливаются в какую-то одну, выбранную основную ветку, которая и определяет историю приложения.

### Как работает merge

Для начала Git просматривает цепочку коммитов обеих веток, пытаясь найти их общий коммит. Обычно такой коммит имеется (как минимум, начальный коммит).

Очень редко бывают ситуации, когда общего коммита не имеется. По умолчанию Git отказывается сливать такие ветки в одну, но можно использовать флаг `--allow-unrelated-histories`, который позволит это сделать.

Если общий коммит между двумя ветками найден, то возможны два случая:
* Только в одной ветке были новые коммиты после общего коммита. В таком случае одна ветка является продолжением другой. Используется стратегия `fast-forward merge`.
* Обе ветки имеют новые коммиты после общего. Это означает, что они развивались параллельно, независимо. Используется стратегия `true merge`.

### Fast-forward merge

Поскольку одна ветка является продолжением другой, указатель на голову короткой ветки сдвигается и становится равным указателю головы длинной ветки. Таким образом все коммиты из длинной ветки становятся доступными в короткой.
```js
/* до слияния веток, ветка develop была впереди на 2 коммита C и D */
develop          |          C —— D
	         |         /
master (current) |   A —— B
```
```js
git checkout master
git merge develop
```
```js
/* после слияния головы веток указывают на один и тот же коммит D */
develop          |          C —— D
	         |         /
master (current) |   A —— B —— C —— D
```

Стратегия `fast-forward merge` не будет применена при мерже, если использовать флаг `--no-ff`.
```js
git merge --no-ff branch_name
```

### True merge

Если обе ветки имеют изменения или используется флаг `--no-ff`, то Git используется стратегию `True merge`. В этом случае создаётся особый тип коммита, имеющий сразу двух родителей, — **merge commit**. В нём содержатся все изменения, которые появились в обеих ветках с момента общего коммита.

```js
/* до слияния веток, с момента общего коммита B develop имеет 2 коммита C и D,
master имеет один коммит E */
develop          |          C —— D
	         |         /
master (current) |   A —— B —— E
```
```js
/* после слияния в текущей ветке master создался merge commit H,
содержащий в себе все изменения коммитов C, D, E */
develop          |           C —— D
	         |         /       \
master (current) |   A —— B —— E —— H
```

## rebase

### Как работает rebase

**Базовый коммит** (Base commit) — коммит, с которого началась (была создана) ветка.

**Перебазирование** (Rebasing) — перемещение последовательности коммитов к новому базовому коммиту. Перебазирование переписывает историю текущей ветки.
```js
git rebase <base>
```

```js
/* до перебазирования ветка develop по сравнению с master
имеет новый коммиты C и D, базовым для неё является коммит B */
develop (current) |          C —— D
	          |         /
master            |   A —— B —— E
```
```js
git checkout develop
git rebase master
```
<!--
```js
/* после перебазирования базовым коммитом для develop стал коммит E,
C* и D* - копии коммитов C и D, но с новым хэшем */
develop (current) |   A —— B —— E —— C* —— D*
	          |
master            |   A —— B —— E
```
-->
```js
/* после перебазирования базовым коммитом для develop стал коммит E,
C* и D* - копии коммитов C и D, но с новым хэшем */
develop (current) |                C* —— D*
	          |               /
master            |   A —— B —— E
```

В примере выше видно, что rebase переписал историю: все коммиты ветки `develop` были изменены.

### rebase vs merge

Git merge сохраняет историю:
* True merge создаёт дополнительный merge commit, который соединяет вместе обе ветки.
* Fast-forward merge так же сохраняет историю, просто перемещая указатель головы одной ветки на другой коммит.  

Rebase перемещает базовый коммит ветки в другое место.

Merge при параллельном изменении нескольких веток создаёт merge коммиты, которые загрязняют историю Git. 

Rebase позволяет достигнуть линейной истории путём её постоянного изменения, всегда размещая новые ветки в конце базовой. А с линейной историей проще работать.

Основной проблемой rebase является то, что все изменения истории относится только в текущей ветке. Если rebase затронет коммиты, которые не были созданы в текущей ветке, то при слиянии с другой веткой Git увидит две разные истории и создаст большой merge commit, который использует обе версии (дублирование одних и тех же изменений).

Таким образом, rebase лучше использовать только для новых коммитов, если есть необходимость как-то подправить их. Если затрагиваются коммиты, которые имеются в других ветках и в будущем есть вероятность того, что эти ветки будут смержены с перебазируемой веткой, лучше не использовать rebase.

### Другие возможности rebase и интерактивный режим

## pull и fetch

**Команда git fetch** используется для того, чтобы получить информацию о последних изменениях на удалённой ветке (`origin/`). Таким образом можно узнать, были ли изменения вообще.
```js
git fetch
/*
From github.com:YourName/RepositoryName
   2eefe71..ac391ab  develop   -> origin/develop
   fca7c62..c31477c  feature/1 -> origin/feature/1
 * [new branch]      feature/2 -> origin/feature/2
 * [new branch]      feature/3 -> origin/feature/3
*/
````
Выше можно видеть, что ветки `develop` и `feature/1` отличаются от своих одноимённых удалённых веток хэшем последних коммитов, а ветки `feature/2` и `feature/3` новые и их нет локально.

Команда `git fetch` помимо информации об изменениях скачивает и сами изменения, но их не слияние с локальной веткой не происходит. Это можно проверить командой `git diff`.
```js
git diff origin/develop
/*
diff --git a/Git.md b/Git.md
index abe21d5..e207862 100644
+++ b/client/Dockerfile
- Hello
+ Hello, Notes!
*/
```

Повторный вызов команды `git fetch` ничего не выведет, поскольку изменения уже были подгружены.

**Команда git pull** также, как и `git fetch` получает изменения и информацию о них, но дополнительно сливает изменения в локальную ветку.

По сути, `git pull` объединяет в себе две команды: `git fetch` и `git merge`.

## Откат изменений с reset, checkout и revert

Обычно `HEAD` указывает на верхушку ветки (branch tip).

**Detached HEAD** — специальный тип HEAD, который может быть установлен пользователем, чтобы посмотреть, как выглядит изменения на определённом коммите в ветке.

Все три команды reset, checkout, revert позволяют откатывать (undo) изменения, но делают это по-разному.

**Команда checkout** перемещает указатель HEAD.

```js
/* до checkout HEAD ветки совпадал с верхушкой (tip) 
ветки master и указывал на коммит E */
                     (HEAD,
	             master)        
A ——— B ——— С ——— D ——— E
```
```js
git checkout B
```
```js
/* после checkout */
  (detached
     HEAD)           (master)
A ——— B ——— С ——— D ——— E
```
Если ввести `git branch`, то он выдаст ветку `(HEAD detached at B)`.

Если ввести `git log`, то коммит B в текущей ветке будет последним.
```js
/* git log */
    (HEAD)
A ——— B
```
Таким образом, при помощи команды `checkout` Git позволяет переключиться на определённый снимок проекта в прошлом, не изменяя при этом реальную ветку. Можно сделать какие-то тестовые изменения, посмотреть или скопировать какие-то файлы, а затем вернуться на полную версию ветки.

**Команда revert** выбирает коммит и создаёт новый коммит, который откатывате изменения выбранного коммита.
```js
/* до revert */
	        (HEAD,
	        master)        
A ——— B ——— С ——— D
```
```js
git revert C
```
```js
/* после revert создаётся коммит E, отменяющий все изменения коммита D,
и таким образом возвращающий состояние проекта на момент коммита B */
	              (HEAD,
	              master)        
A ——— B ——— С ——— D ——— E
```
Если при помощи `revert` откатывается не последний коммит (например, C), то могут появиться конфликты (поскольку коммит D зависеть от некоторых изменений коммита C).

Команда `revert` является безопасным вариантом для отката изменений в публичном репозитории, поскольку коммиты не удаляются, а создаются — история не перезаписывается.

**Команда reset** сбрасывает все изменения и историю до определённого коммита.
```js
/* до reset */
	        (HEAD,
	        master)        
A ——— B ——— С ——— D
```
```js
git reset B
```
```js
/* после reset */
   (HEAD,
   master)        
A ——— B
```
## Полезные возможности Git

<!--
### Команда reset
### Команда stash
-->

### Отмена последнего коммита
```sh
git reset HEAD~
```

### Перенос коммитов из одной локальной ветки в другую

Например, перенос N коммитов из локальной ветки A и локальную ветку B.
```sh
git checkout B
git merge from A
git checkout A
git reset --hard HEAD~N # удаление N коммитов из ветки A
```

## Git flow

**Фича** (Feature) — новая функциональность. 

### Разработка новой фичи
* Разработка новых фич начинается с ветки `develop`, от которой создаётся новая ветка `feature/name`, где `name` - название фичи.
* Разработчик переключается на новую ветку и начинает работать с ней.
* После завершения фичи создаётся Pull Request.
* Ветка `feature/name` сливается с (merge into) веткой `develop`. 
* Ветка `feature/name` удаляется.
* Разработчик переключается обратно на ветку `develop`.

### Релиз в production
* От ветки `develop` создаётся ветка `release/vX.X.X`.
* Ветка `release/vX.X.X` при необходимости помечается тэгом `vX.X.X`.
* Разрешены мелкие исправления (minor bug fixes) в ветке `release/vX.X.X`.
* Ветка `release/vX.X.X` сливается с веткой `master`.
* Ветка `release/vX.X.X` сливается обратно (back-merge) с веткой `develop`.
* Ветка `release/vX.X.X` удаляется.
* Разработчик переключается обратно на ветку `develop`.

## Hotfix в production
* Если в production найден серьёзный баг, который нужно быстро исправить, от ветки `master` создаётся ветка `hotfix/name`, в которой делаются необходимые исправления.
* Ветка `hotfix/name` сливается с веткой `master`.
* Ветка `hotfix/name` сливается с веткой `develop`.
* Ветка `hotfix/name` удаляется.


## SSH Github & Gitlab

* Открыть Bash.

### Генерация ключей
* Сгенерировать ключ для Github при помощи `ssh-keygen -t rsa -C "email" -f ~/.ssh/id_rsa_github`, где нужно заменить `email` на свой. `id_rsa_github` - название файла, где будет лежать приватный ключ. Команда также автоматически генерирует публичный ключ `id_rsa_github.pub` в той же папке.
* Ввести ключевую фразу и повторить её.

* Сгенерировать ключ для Gitlab при помощи `ssh-keygen -t rsa -C "email" -f ~/.ssh/id_rsa_gitlab`, где нужно заменить `email` на свой.
* Ввести ключевую фразу и повторить её.

### Cоздание ключа на Github
* Скопировать публичный ключ `~/.ssh/id_rsa_github.pub` для Github. Например, вывести его на экран при помощи `cat ~/.ssh/id_rsa_github.pub` и скопировать через `Ctrl + C`.
* Открыть на Github [Settings > SSH keys](https://github.com/settings/keys) и нажать на добавление нового ключа.
* Вставить скопированный ключ, придумать название для него и сохранить.

### Cоздание ключа на Gitlab
* Скопировать публичный ключ `~/.ssh/id_rsa_gitlab` для Gitlab.
* Открыть на Gitlab `Settings > SSH keys`.
* Вставить скопированный ключ, придумать название для него и сохранить.

### Добавление ключа в SSH-agent
* Добавить SSH-ключ для GitHub в SSH-agent `ssh-add ~/.ssh/id_rsa_github`. Если агент не запущен, то нужно сперва его запустить `eval $(ssh-agent -s)` или `ssh-agent bash`.
* Добавить SSH-ключ для GitLab в SSH-agent `ssh-add ~/.ssh/id_rsa_gitlab`.
* Проверить, что ключи добавлены через `ssh-add -L`.

Если для каждой новой консоли запускать агент и добавлять ключ приходиться заново, то можно настроить *псевдоним*.

**Псевдоним** (Alias) — аббревиатура, позволяющая избежать написания длинной последовательности команд.
* Создадим файл `.bashrc` в корневой папке (в Windows: `C:/Users/<USERNAME>/) и поместим там следующее.
```bash
alias sa="eval `ssh-agent -s` ssh-add ~/.ssh/id_rsa_gitlab"
```
Теперь каждый запуск команды `sa` в любой консоли Bash будет выполнять запуск агента и добавление ключа.

### Конфигурация

* Создать файл `touch ~/.ssh/config`.
* Вставить туда следующее
```
# config for github
Host github.com
   HostName github.com
   User git
   IdentityFile ~/.ssh/id_rsa_github
# config for gitlab
Host gitlab.com
   HostName gitlab.com
   User git
   IdentityFile ~/.ssh/id_rsa_gitlab
```
* Сохранить изменения.

### Проверка
* Попробовать сделать `git pull` через SSH.
* Дополнительная проверка для Github: `ssh -T git@github.com` (режим отладки: `ssh -T git@github.com`).
* Дополнительная проверка для Gitlab: `ssh -T git@gitlab.com` (режим отладки: `ssh -T git@gitlab.com`).

## Git Config

### Вывод конфига
```
git config -l
```

### Имя пользователя и почта
```js
/* имя пользователя */
git config --global user.name "Your Username"
/* электронная почта */
git config --global user.email "your@email"
```

## Git Bash
**Командная оболочка** (Shell) — терминальное приложение (terminal app), используемое для взаимодействия с ОС посредством письменных команд.

**Bash** (Bourne again shell, "Born again shell", "возрождённый" shell) — *усовершенствованная версия* ранней *командной оболочки Bourne shell*, исполняющей файлы формата `.sh` в `UNIX`. *Bash* является командной оболочкой *по умолчанию* для *Linux* и *macOS*.

**Git Bash** — пакет, *устанавливающий Bash*, некоторые *базовые утилиты* и *Git* на *Windows*.

### Убить запущенный процесс
Чтобы на *определённом порте* *убить запущенный процесс*, нужно узнать его **PID** (Process Identifier).
```css
netstat -ano | findstr :PORT /* например, :3000 */
/* Скопировать PID из последнего стобца результата и вставить в команду ниже */
tskill PID
```
