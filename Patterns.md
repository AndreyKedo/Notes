## MVC и его модификации

### Подлинный MVC (1979)
В 1970-ых обязанности не разделялись: смешивание HTML, CSS, бизнес-логики и работы с базой данных считалось нормальной практикой. С ростом таких приложений становилось понятно, что они очень запутанны и их невозможно поддерживать (тратится слишком много ресурсов), поэтому нередко разросшиеся приложения приходилось переписывать с нуля.

В 1979 появился шаблон проектирования **MVC** (Model-View-Controller), попытавшийся разрешить проблему, продвигая идею **разделения ответственности** (separation of concerns, SoC) между бэкендом и фронтендом, UI и бизнес-логикой.

MVC разделяет приложение на 3 концептуальные единицы
* **Модель** (Model) представляет бизнес-логику (данные и правила, методы работы с ними) приложения.
* **Представление** (View) - UI-компонента (кнопка, поле для ввода и прочее).
* **Контроллер** (Controller) выступает координатором между View и Model: решает, какие Views показывать и с какими данными, переводит действия пользователя (например, клик по кнопке) в бизнес-логику.

Модель может быть представлена объектом или структурой объектов.

*Особенности подлинного MVC*   
1) View использует объекты данных напрямую из Model, чтобы эти данные отобразить.  
2) Когда данные в Model меняются, срабатывает событие, которое немедленно обновляет View.  
3) Один View обычно привязан к одному Controller.  
4) Каждый экран может иметь несколько пар View-Controller.  
5) Controller может быть связан с несколькими Views. 

*Проблема подлинного MVC*  
Когда MVC прявился, HTTP ещё не было. Сейчас же при попытке описать полноценное приложение (HTTP-клиент + HTTP-сервер) понятно, что подлинный MVC работать не сможет: при обновлении данных в БД клиент не получает данные напрямую, а делает это по запросу к серверу (через Controller). Это можно решить при помощи веб-сокетов, но не всегда есть в этом необходимость

### Иерархическое MVC (2000), PAC (1987)

**HMVC** (Hierarchical MVC) увеличивает модульность в контексте виджетизации UI-блоков.

Существует мнение, что авторы HMVC переосмыслили другой паттерн: **PAC** (Presentation-Abstraction-Control).

HMVC разбивает уроверь клиента (client tier) на иерархию из MVC-слоёв. Это называется **проектированием клиентского уровня** (client-tier architecture) и должно увеличивать масштабируемость приложения: каждый MVC-слой независим от других и может работать при отсутствии любого другого.

Controller, обрабатывающий основной запрос, пересылает подзапросы другим Controllers, чтобы получить рендеринг виджетов и включить их в рендеринг основного View.

### MVP (1996)

*MVC* был хорош для приложений своего времени, но приложения выросли и настало время изменений.

**MVP** (Model-View-Presenter) видоизменяет MVC, разделяя View и Model и осуществляя их коммуникацию только через **Presenter**.

*Presenter* также называют **Supervisor Controller**.

*Особенности MVP*  
1) View пассивен (passive) и ничего не знает о Model. 
2) Presenter не содержит бизнес-логики, он просто вызывает методы Model, а затем передаёт необходимые данные во View.  
3) Только один Presenter для каждого View.  
4) Изменение данных в Model не вызывает немедленное обновление View: событие всегда проходит через Presenter, что позволяет в нём перед обновлением View проделывать дополнительную логику, связанную с представлением.


### MVVM (2005)
  
Сложность приложений продолжала расти и снова появилась необходимость изменений.

**MVVM** (Model-View-ViewModel) призван разделить UI-дизайн и бизнес-логику таким образом, чтобы за них могли отвечать разные люди, использующие разные технологии для этих целей.

*Особенности MVVM*  
1) Один ViewModel соответствует только одному View и наоборот.
2) Вся логика из View перемещается во ViewModel, чтобы упростить View и позволить ему выполнять свою задачу (визуализация).
3) Отношение один к одному установлено между данными во View и данными во ViewModel.
4) Изменение данных во ViewModel вызывает немедленное обновление View.

### Model View Controller (MVC)

*MVC* разделяет приложение на *3 компонента*.

**Модель** (Model) *представляет данные* и *правила* (методы) *работы* с ними.  

*Модель реагирует* на *запросы Контроллера*, *изменяя* своё *состояние*.  

*Модель не* содержит информации, *как* отобразить данные.

**Представление** (View) *отображает данные Модели пользователю*.  

*Представление реагирует* на *изменения Модели*, всегда *отображая* её *обновлённую версию*.

**Контроллер** (Controller) *обрабатывает данные пользователя через Модель* и затем *посылает* их *Представлению*.  

*Контроллер* выступает *промежуточным слоем* между *Моделью* и *Представлением*.


Пользователь видит Представление и совершает действие над ним.  
Действие передаётся Контроллеру.  
Контроллер обновляет данные Модели.  
Модель уведомляет Контроллер об изменении состояния.  
Контроллер посылает данные Представлению.  
Пользователь видит обновлённое Представнение.
