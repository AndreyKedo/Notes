# Тестирование

## Почему следует писать тесты?

Отсутствие тестов похоже на вынесение диагноза врачом без необходимых анализов.  

Без тестов ты не можешь быть уверен, всё в твоём приложении всё под контролем, что новый функционал не ломает старый.

## TDD

**Test-Driven Development** (TDD) — подход к разработке и тестированию, при котором сначала создаются тесты, которым должен удовлетворять код, затем его реализация.  

*TDD* имеет *итеративный процесс*. Сперва пишется тест на новый, ещё не реализованный функционал, а затем пишется минимальное количество кода (ничего лишнего) для его реализации. При успешном прохождении теста, можно задуматься о качестве кода и сделать его рефакторинг.

*Преимущества TDD*
- Полное покрытие кода тестами.
- Заранее задумываемся об использовании кода.
- Хорошие тесты являются неплохим примером использования кода (что-то вроде документации).

## BDD

**Behavior-Driven Development** (BDD) — расширение подхода TDD, при котором особое внимание уделяется поведению системы в терминах бизнеса. Такие тесты обычно иллюстрируют и тестируют сценарии, интересные заказчику системы. Поэтому для BDD-тестов используются фреймворки (Chai и Mocha, Jest) с синтаксисом, понятным не только программисту, но и представителю заказчика.

```js
const createArticle = title => ({ title, date: new Date() });

describe('createArticle', () => {
  const article = createArticle('Weather');
  it('should return an object', () => article.to.be.an('object'));
  it('the object should have a "date" and "title" properties', () => {
    expect(article).to.have.property('date'));
    expect(article).to.have.property('title'));
  });
});
```

### TDD vs BDD

TDD-тесты пишутся программистами для программистов.

BDD-тесты могут быть написаны техническими менеджерами или тестировщиками, что позволяет их использовать не только при формальной TDD-разработке, но и при формализации требований к системе.

# Тестовые объекты

Для достижения изолированности какого-то блока тестируемого кода внешние зависимости при его тестировании заменяются **тестовыми объектами**.

<!-- Тестовые объекты увеличивают переиспользуемость тестов и улучшают их поддержку. -->

## Пустышка

**Пустышка (Dummy)** — простейший тестовый объект, реализующий интерфейс, минимально совместимый с интерфейсом реального объекта. 

Код Dummy не содержит никакой логики.  

Dummy используется в тех случаях, когда обращение к реальному объекту в данном тесте не имеет значения или отсутствует.

Например, нам в контексте теста не нужна проверка авторизации, поэтому мы заменяем реальную функцию `checkAuth()` на тестовую, которая всегда возвращает истиное значение.
```js
const checkAuth = () => true;

checkAuth(); // true
```
В реальности же функция `checkAuth` могла иметь следующий интерфейс `(token: string) => boolean`.

## Заглушка

**Заглушка (Stub)** — тестовый объект, частично реализующий логику реального объекта (валидные данные на входе - валидные данные на выходе).

Stub обычно содержит тривиальную логику, имитирующую работу нескольких методов реального объекта.

<!-- функция или метод класса, которая подменяет реализацию оригинальной функции и не выполняет никакого осмысленного действия, возвращает пустой результат или тестовые данные. -->

Например, имитируем создание пользователя в базе данных: принимаем данные пользователя и сразу же возвращаем полученные данные вместе с сгенерированным id (должен был сгенерироваться в бд).
```js
const generateId = () => parseInt(Math.random() * 1000);

const createUser = userData => Promise.resolve({
  ...userData,
  _id: generateId(),
});
```

Перепишем пример для Dummy так, чтобы он смог стать Stub (принимает валидные данные и отдаёт тоже).
```js
const checkAuth = token => !!token;

checkAuth('qq'); // true
checkAuth(''); // false
```

## Макет 

**Макет (Mockup)** — модуль или класс, представляющий собой конкретную фиктивную реализацию определенного интерфейса. 

Макет, как правило, предназначен для подмены оригинального объекта системы исключительно для тестирования взаимодействия и изолированности тестируемого компонента.

## Page Object

**Объект-страница** (Page Object Model, POM) — модуль (класс), представляющий интерфейс отдельной страницы тестируемой системы. 

При использовании POM тесты оперируют с абстрактными объектами страниц и не завязаны на конкретную реализацию пользовательского интерфейса (его дизайн и вёрстку).

Тесты используют методы POM каждый раз, когда требуется взаимодействие с UI страницы. 

*Преимущества Page Object*
- Изменение дизайна и вёрстки страниц может потребовать изменения только во внутренней реализации объекта страницы, но оно не затрагивает тестовые сценарии, оперирующие данной страницей. 
- Абстрактность интерфейса позволяет переиспользовать тесты для различных девайсов.
различных устройств и разрешений экранов, что очень удобно.

## Шпион
**Шпион (Spy)**  —  объект-обертка (по типу прокси), которая слушает вызовы и сохраняет информацию об этих вызовах (аргументы, количество вызовов, контекст) оригинального объекта системы. Далее сохраненные шпионом данные используются в тестах.

## Испытательная Платформа

**Испытательная Платформа (TestBed)**  — это специально воссозданная тестовая среда, платформа для тестирования (может быть комплекс Макетов, Заглушек и Шпионов). Применяется для комплексного тестирования отдельных связок компонентов или всей системы. 

## Фикстура
**Фикстура (Fixture)**  —  это механизм, позволяющий привести объект или всю систему в определенное состояние и зафиксировать это состояние для тестов. Под фикстурой чаще всего понимают тестовые данные необходимые для корректного запуска тестов, а также механизмы загрузки/выгрузки этих данных в хранилище. Т.е. основное назначение фикстур  —  это привести данные системы к определенному состоянию (фиксированному), которое будет точно известно во время выполнения тестов.
