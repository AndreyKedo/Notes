#  Тестирование

## Почему следует писать тесты?

Отсутствие тестов похоже на вынесение диагноза врачом без необходимых анализов.  

Без тестов ты не можешь быть уверен, всё в приложении всё под контролем, что новый функционал не ломает уже написанный.

С ростом приложения и количества разработчиков вероятность возникновения непредвиденных ошибок и сложность их исправления возрастают. Тесты частично предотвращают эти ошибки.

## Ручное и автоматизированное тестирование

**Ручное тестирование** — прямое взаимодействие QA-инженера с приложением.  
QA ищет неисправности и недостатки, а затем информирует о них программиста.

### Плюсы ручного тестирования
* *Отчёт тестировщика* — первый отзыв потенциального пользователя, позволяющий увидеть приложение его глазами.
* *Обратная связь* (feedback) по **UI**. Протестировать UI приложения и выявить его недостатки пока позволяет только ручное тестирование.
* *Отсутствие затрат на написание тестов*. Это важно при быстром внедрении новой функциональности. На малых проектах написание и поддержку тестов может оказаться достаточно затратным.

### Минусы ручного тестирования
* *Человеческий фактор*. Часть ошибок может упускаться, некоторые результаты субъективны.
* *Трудозатраты и продолжительность*. Ручное тестирование обычно занимает много времени. Часто требуется тесное взаимодействие QA с программистом во время тестирования для разъяснения многих вопросов.
* *Отсутствие возможности моделирования большой нагрузки*. При ручном тестировании невозможно смоделировать большое количество пользователей.

**Автоматизированное тестирование** — написание кода для тестов.  
Ожидаемый сценарий описывается кодом, затем при запуске тестов он сравнивается с реальным и программа указывает расхождения.

### Плюсы автоматизированного тестирования
* *Отсутствие человеческого фактора*. Хорошо написанный тест не может забыть что-то проверить, он каждый раз последовательно проверяет действия.
* *Скорость выполнения*. Код для сценария пишется один раз, а его запуск обычно занимает несколько секунд.
* *Переиспользуемость*. Код автотестов может быть использован неоднократно, особенно при внедрении новой функциональности.
* *Возможность моделирования большой нагрузки*. Приближает тесты к реальной ситуации использования приложения.

### Минусы автоматизированного тестирования
* *Отсутствие тестирования глазами пользователя* (UX). Не всё можно покрыть автотестами.
* *Отсутствие обратной связи*. Автоматизированные тесты не предоставляют обратную связь о качестве продукта, они лишь выполняют запрограммированные сценарии.
* *Затраты на написание тестов и их поддержку*. Автоматизированные тесты трубуют написания большого количества кода. При изменении тестируемых частей приложения, нужно изменять и их тесты (иначе они станут бесполезными). Это может быть губительно для маленьких проектов и проектов, где всё меняется довольно быстро и непредсказуемо.

<!-- * Надежность. Автоматизированные тесты могут упасть по многим причинам, например, при большой загруженности тестовой машины или при проблемах с сетью. -->

# Виды тестов

## Пирамида тестирования

Майк Кон, автор книги "Scrum. Гибкая разработка ПО", представляет тестирование приложения в виде пирамиды.  

Чем выше по пирамиде, тем дольше и затратнее делать тесты.

По этой причине автор расставил следующие приоритеты: 80% - модульные тесты, 15% - интеграционные и API-тесты, 5% - UI-тесты (могут быть как автоматизированными, так и ручными).

![Пирамида тестирования](./assets/testing-pyramid.png)

# Подходы к написанию тестов

## TDD

**Test-Driven Development** (TDD) — разработка через тестирование; подход к разработке и тестированию, при котором сначала создаются тесты, которым должен удовлетворять код, затем его реализация.  

*TDD* имеет *итеративный процесс*. Сперва пишется тест на новый, ещё не реализованный функционал, а затем пишется минимальное количество кода (ничего лишнего) для его реализации. При успешном прохождении теста, можно задуматься о качестве кода и сделать его рефакторинг.

TDD-тесты пишутся программистами для программистов.

### Преимущества TDD
- Полное покрытие кода тестами.
- Заранее задумываемся об использовании кода.
- Хорошие тесты являются неплохим примером использования кода (что-то вроде документации).

### Пример TDD
Например, напишем тест для функции, которая должна возводить двойку в степень.
```js
const runTests = () => {
  assert.equal(pow2(0), 1, '2^0 = 1');
  assert.equal(pow2(1), 2, '2^1 = 2');
  assert.equal(pow2(2), 4, '2^2 = 4');
};
```
Теперь на основании теста пишется сама функция.
```js
const pow2 = (power) => {
  let result = 1;
  for (let i = 0; i < power; i++) {
    result *= 2;
  }
  return result;
}
```
Функция удовлетворяет тестам выше, добавим новые тесты.
```js
assert.equal(pow2(-1), 0.5, '2^(-1) = 0.5');
assert.equal(pow2(-2), 0.25, '2^(-2) = 0.25');
assert.equal(pow2(-3), 0.125, '2^(-3) = 0.125');
```
Дописываем нужный функционал.
```js
const pow2 = (power) => {
  let result = 1;
  if (power > 0) {
    for (let i = 0; i < power; i++) {
      result *= 2;
    }
  } else {
    for (let i = 0; i > power; i--) {
      result /= 2;
    }
  }
  return result;
}
```
Далее снова пишем тесты.

## BDD

**Behavior-Driven Development** (BDD) — разработка, основанная на поведении; расширение подхода TDD, где особое внимание уделяется поведению системы в терминах бизнеса. Такие тесты обычно иллюстрируют и тестируют сценарии, интересные заказчику системы. Поэтому для BDD-тестов используются фреймворки (Chai, Mocha, Jest) с синтаксисом, понятным не только программисту, но и представителю заказчика.

```js
const createArticle = title => ({ title, date: new Date() });

describe('createArticle', () => {
  const article = createArticle('Weather');
  it('should return an object', () => article.to.be.an('object'));
  it('the object should have a "date" and "title" properties', () => {
    expect(article).to.have.property('date'));
    expect(article).to.have.property('title'));
  });
});
```

BDD фокусируется на предметной области приложения, в то время как TDD фокусируется на сам код.

BDD-тесты могут быть написаны и поняты не только программистом, но и техническими менеджерами или тестировщиками, что позволяет убрать языковой барьер между всеми ними.

## DDT

**Data-Driven Testing (DDT)** — тестирование, управляемое данными; подход к архитектуре автоматизированных тестов, при котором тестовые данные хранятся отдельно от тестов (в файле или базе данных).

### Алгоритм DDT
* Часть тестовых данных извлекается из хранилища.
* Выполняется скрипт, в котором вызывается обычный тест с извлечёнными тестовыми данными.
* Сравниваются полученные (actual) результаты с ожидаемыми (expected).
* Алгоритм повторяется со следующим набором входных данных.

### Пример DDT

Перепишем функцию `pow2` из раздела TDD.
```js
const runTests = () => {
  assert.equal(pow2(0), 1, '2^0 = 1');
  assert.equal(pow2(1), 2, '2^1 = 2');
  assert.equal(pow2(2), 4, '2^2 = 4');
  /* ... */
};
```
Возводить двойку в степень можно до бесконечности (на самом деле не совсем, поскольку в JavaScript `MAX_SAFE_INTEGER = 2^53 - 1`), но писать все эти степени руками не хочется.  

Что можно сделать?  
Можно взять файл, содержащий степени двоек и подгружать данные из его.
```js
/* pow-data.txt */
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 ...
```
Пишем функционал, загружающий данные из файла и возвращающий их в виде массива.
```js
const fs = require('fs');

const readPowData = async (filename) => {
  const powData = await fs.readFile(filename, 'utf8'); // async, await доступны в fs с Node 11+
  return powData.split(' ');
};
```
Пишем функционал для тестов таким образом, чтобы можно было запускать их с массивом данных.
```js
const runTest = (power, expectedValue) => assert.equal(pow2(power, expectedValue), `2^${power} = ${expectedValue}`);

const runTests = (powDataArray) => {
  powDataArray.forEach((item, index) => {
    runTest(index, item);
  });
};
```
Считываем данные из файла и запустить тесты.
```js
let powDataArray = await readPowData('pow-data.txt');
runTests(powDataArray);
```
Загружаем данные из другого файла или же из другого источника, снова запускаем тесты.
```js
powDataArray = await readPowData('pow-data-2.txt');
runTests(powDataArray);

powDataArray = await getPowDataFromDB();
runTests(powDataArray);
```

## KDT

**Keyword-Driven Testing (KDT)** — тестирование, управляемое ключевыми словами; подход, использующий ключевые слова, описывающие набор действий, необходимых для выполнения определённого шага тестового сценария.

Для использования подхода нужно определить набор ключевых слов и сопоставить им действия (функции).

В KDT используется что-то вроде таблиц, чтобы ключевые слова могли иметь параметры, поэтому подход иногда называют **Table-Driven Testing (TDT)**.

### Алгоритм KDT
* Считываем ключевые слова вместе с их параметрами из таблицы.
* Последовательно вызываем связанные с ключевыми словами функции.

### Пример KDT

Сопоставим функции ключевым словам.
```js
/* keyword "Login" */
const login = (username, password) => { /* ... */ };

/* keyword "Send Email" */
const sendEmail = (receiver, message) => { /* ... */ };

/* keyword "Logout" */
const logout = () => { /* ... */ };
```
```js
Login         | user                  | pass123
Send Email    | another-user@mail.com | Hello!
Send Email    | my-friend@mail.com    | Hi!
Logout
```

# Тестовые объекты

Для достижения изолированности какого-то блока тестируемого кода внешние зависимости при его тестировании заменяются **тестовыми объектами**.

<!-- Тестовые объекты увеличивают переиспользуемость тестов и улучшают их поддержку. -->

## Пустышка

**Пустышка (Dummy)** — простейший тестовый объект, реализующий интерфейс, минимально совместимый с интерфейсом реального объекта. 

Код Dummy не содержит никакой логики.  

Dummy используется в тех случаях, когда обращение к реальному объекту в данном тесте не имеет значения или отсутствует.

Например, нам в контексте теста не нужна проверка авторизации, поэтому мы заменяем реальную функцию `checkAuth()` на тестовую, которая всегда возвращает истиное значение.
```js
const checkAuth = () => true;

checkAuth(); // true
```
В реальности же функция `checkAuth` могла иметь следующий интерфейс `(token: string) => boolean`.

## Заглушка

**Заглушка (Stub)** — тестовый объект, частично реализующий логику реального объекта (валидные данные на входе - валидные данные на выходе).

Stub обычно содержит тривиальную логику, имитирующую работу нескольких методов реального объекта.

<!-- функция или метод класса, которая подменяет реализацию оригинальной функции и не выполняет никакого осмысленного действия, возвращает пустой результат или тестовые данные. -->

Например, имитируем создание пользователя в базе данных: принимаем данные пользователя и сразу же возвращаем полученные данные вместе с сгенерированным id (должен был сгенерироваться в бд).
```js
const generateId = () => parseInt(Math.random() * 1000);

const createUser = userData => Promise.resolve({
  ...userData,
  _id: generateId(),
});
```

Перепишем пример для Dummy так, чтобы он смог стать Stub (принимает валидные данные и отдаёт тоже).
```js
const checkAuth = token => !!token;

checkAuth('qq'); // true
checkAuth(''); // false
```

## Макет 

**Макет (Mockup)** — модуль или класс, представляющий собой конкретную фиктивную реализацию определенного интерфейса. 

Макет, как правило, предназначен для подмены оригинального объекта системы исключительно для тестирования взаимодействия и изолированности тестируемого компонента.

# Шаблоны

## Объект-страница

**Объект-страница** (Page Object Model, POM) — модуль (класс), представляющий интерфейс отдельной страницы тестируемой системы. 

При использовании POM тесты оперируют с абстрактными объектами страниц и не завязаны на конкретную реализацию пользовательского интерфейса (его дизайн и вёрстку).

Тесты используют методы POM каждый раз, когда требуется взаимодействие с UI страницы. 

*Преимущества Page Object*
- Изменение дизайна и вёрстки страниц может потребовать изменения только во внутренней реализации объекта страницы, но оно не затрагивает тестовые сценарии, оперирующие данной страницей. 
- Абстрактность интерфейса позволяет переиспользовать тесты для различных девайсов.
различных устройств и разрешений экранов, что очень удобно.

## Шпион
**Шпион** (Spy)  —  объект-обертка (по типу прокси), которая слушает вызовы и сохраняет информацию об этих вызовах (аргументы, количество вызовов, контекст) оригинального объекта системы. Далее сохраненные шпионом данные используются в тестах.

## Испытательная Платформа

**Испытательная Платформа** (TestBed)  — это специально воссозданная тестовая среда, платформа для тестирования (может быть комплекс Макетов, Заглушек и Шпионов). Применяется для комплексного тестирования отдельных связок компонентов или всей системы. 

## Фикстура
**Фикстура** (Fixture)  —  механизм, позволяющий привести объект или всю систему в определенное состояние и зафиксировать это состояние для тестов. Под фикстурой чаще всего понимают тестовые данные необходимые для корректного запуска тестов, а также механизмы загрузки/выгрузки этих данных в хранилище. 

Основное назначение фикстуры: привести данные системы к определенному (фиксированному) состоянию, которое будет точно известно во время выполнения тестов.
