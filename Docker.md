- [Контейнеры и контейнеризация](#контейнеры-и-контейнеризация)
  - [Сравнение контейнера и виртуальной машины](#сравнение-контейнера-и-виртуальной-машины)
  - [Преимущества контейнеров](#преимущества-контейнеров)
- [Docker](#docker)
  - [Архитектура Docker](#архитектура-docker)
  - [Копирование файлов при помощи ADD И COPY](#копирование-файлов-при-помощи-add-и-copy)
  - [Запуск команд при помощи RUN и CMD](#запуск-команд-при-помощи-run-и-cmd)
  - [Аргументы ARG](#аргументы-arg)
  - [Переменные окружения ENV](#переменные-окружения-env)
  - [Хранение данных](#хранение-данных)
  - [Пример образа для NodeJS](#пример-образа-для-nodejs)
- [Композиция контейнеров (Docker Compose)](#композиция-контейнеров-docker-compose)

# Контейнеры и контейнеризация

**Контейнер** (Container) — стандартная единица ПО, в которую упаковывается приложение со всеми необходимыми для его полноценной работы зависимостями (кодом, средой запуска, библиотеками и настройками).

## Сравнение контейнера и виртуальной машины

*Контейнер* — *процесс* или *сервис*, который *напрямую запущен на машине*. 

*Docker-демон* следит за тем, чтобы контейнер запускался в полной изоляции от операционной системы машины. Ничего подобного виртуальной машине при этом не создаётся.

**Виртуальная машина** (Virtual Machine) — *изолированная операционная подсистема на машине*.

 С помощью виртуальной машины можно внутри Windows ОС запустить Linux и наоборот. Существует множество инструментов, чтобы работать с виртуальными машинами (например, Virtual Box).

## Преимущества контейнеров
* Возможность упаковать приложение вместе с его средой запуска. Это позволяет контейнеру запускаться одинаково в разных окружениях (операционных системах) и решает пооблему их настройки (подготовки к запуску приложения), а значит на каждом компьютере запуск контейнера происходит одинаково. 
* Поскольку в контейнерах содержится только самое необходимое (ничего лишнего), им свойственны легковесность, быстродействие и простота настройки.

# Docker

## Архитектура Docker

*Docker* использует *клиент-серверную архитектуру*. 

Клиент и сервер общаются между собой при помощи REST API поверх сокетов и сетевого интерфейса.

**Docker-клиент** (Docker client) использует CLI-команды, чтобы общаться с *Docker daemon*, выступающим в роли *сервера*.
```js
/* примеры CLI-команд */
docker run
docker build
docker pull
```
**Docker-демон** (Docker daemon) собирает, запускает и раздаёт (distribute) контейнеры.

**Образ** (Image) — доступный только для чтения шаблон с инструкциями о том, как запустить какой-то Docker-контейнер. 

Один образ может расширять другой.

Для создания образа необходимо создать *Dockerfile* для определения шагов, необходимых для создания образа и запустить этот файл. Каждая инструкция в Dockerfile создаёт новый слой (layer) в образе. Когда Dockerfile изменяется и образ пересобирается (rebuild), пересобираются только изменённые слои.

Образы хранятся в Docker-реестре (Docker registry). Одним из таких является Docker Hub - публичный реестр, который используется по умолчанию.
```js
// загрузить image из реестра
docker pull <image>
// загрузить image в реестр
docker push <image>
```

**Контейнер** (Container) — запускаемый экземпляр образа. Его можно создавать, запускать, останавливать, перемещать и удалять при помощи Docker API или CLI.

По умолчанию контейнер достаточно хорошо изолирован от маширы-хоста, но это можно контролировать, передавая в контейнер всё необходимое.

## Копирование файлов при помощи ADD И COPY

**Инструкция COPY** позволяет скопировать локальный файл или папку с машины в образ. Она принимает два параметра: относительный путь на машине, откуда копировать, и абсолютный путь, по которому данные будут доступны в контейнере.
```dockerfile
# Dockerfile
COPY ./package.json /app/
COPY ./src /app/src
```
**Инструкция ADD** может делать то же самое, но помимо этого она может принять URL как источник для копирования или разархивировать локальный `.tar` файл, а затем поместить в образ.
```dockerfile
# Dockerfile
ADD ./package.json /app/
ADD ./src /app/src

ADD archive.tar.gz /
ADD http://some_url.here /
```

Если нет явной необходимости в ADD, лучше использовать COPY.

## Запуск команд при помощи RUN и CMD

**Инструкция RUN** позволяет запускать команды внутри образа (image). Эти команды запускаются один раз во время сборки (build) и записываются в образ как новый слой (layer).
```dockerfile
# Dockerfile
RUN echo "Install modules"
RUN npm install
```

**Инструкция CMD** описывает *команду по умолчанию*, которая должна *запускаться при запуске готового образа, то есть контейнера*. 
```dockerfile
# Dockerfile
CMD npm start
```
Таким образом, несмотря на то, что CMD является инструкцией Dockerfile, он запускается не во время сборки, а уже в запущенном контейнере. Чаще всего командой в CMD выступает запуск сервера.

## Аргументы ARG
**Инструкция ARG** определяет переменную, которую можно передать во время сборки (build-time) контейнера.

* Объявление аргументов в Dockerfile.
```dockerfile
# Dockerfile
ARG argument_name
ARG another_argument_name=default_value # со значением по умолчанию
```
* Использование аргументов в Dockerfile.
```dockerfile
# Dockerfile
RUN echo ${argument_name}
RUN echo ${another_argument_name}
```
* Передача аргументов в команду сборки контейнера.
```cmd
docker-compose build --build-arg port=3000 --build-arg env="local"
```
```dockerfile
# Dockerfile
ARG port
ARG env
```

## Переменные окружения ENV

**Инструкция ENV** сохраняет переменную внутри контейнера. Таким образом переменная в контейнере доступна во время выполнения (run-time).
* Объявление переменных окружения в Dockerfile. 
```dockerfile
# Dockerfile
ENV env=production
```
* Передача в команду запуска контейнера.
```cmd
docker run -e env=production
```

Если есть необходимость передать аргумент как переменную окружения, то можно сделать это следующим образом.
```dockerfile
# Dockerfile
ARG port
ENV port=${port}
```

## Хранение данных

## Volume

**Volume** — предпочитительный механизм для хранения данных (persisting data), используемых в Docker-контейнере.

Volume даёт контейнеру доступ к какой-то локальной папке на машине-хосте, на которой этот контейнер запущен. Файлы из Volume нельзя использовать на этапе сборки (build-time), то есть в Dockerfile нельзя использовать файлы из Volume, они доступны лишь во время выполнения (run-time).

### Почему следует использовать Volume

Volume хранится вне контейнера. Поэтому он не увеличивает размер контейнера, а также не подвержен влиянию жизненного цикла контейнера.

## Пример образа для NodeJS
```Dockerfile
# Dockerfile
FROM node:12.13.1

ARG port
ARG env

EXPOSE ${port}
COPY ./package.json /app/
COPY ./src /app/src
COPY ./public /app/public
COPY ./webpack /app/webpack

WORKDIR /app

RUN npm install
RUN NODE_ENV=${env} npm run build

CMD npm run start
```
```cmd

```

# Композиция контейнеров (Docker Compose)

**Docker Compose** — инструмент, позволяющий запускать приложения, состоящие из нескольких контейнеров.

## Передача переменных в Docker

### ENVIRONMENT vs ARGS

**Перееменные окружения ENVIRONMENT** передаются в уже запущенные контейнеры.
```yaml
client:
  environment:
    - NODE_ENV: production
    - SERVER_URL: xxx
```

*Docker Compose* поддерживает объявление значений по умолчанию для переменных окружения в `.env` файле. 

**Переменные ARGS** доступны во время построения образа (build image).

```yaml
client:
  build:
    args:
      - port: 3000
      - env: production
```

### Пример конфигурации 3-уровнего приложения

Трёхуровневое (3-tier) приложение состоит из клиента, сервера и базы данных. Для каждого уровня необходим отдельный контейнер, а поскольку они связаны друг с другом, создаётся их композиция.

``` js
/* структура проекта */
- client/
  - Dockerfile
- server/
  - Dockerfile
- docker-compose.yml
```
```yaml
# docker-compose.yml
version: '3.7'
services:
  mongo:
    command: mongod
    image: mongo:3.6.3
    ports:
      - "27017:27017" # map port to none standard port, to avoid conflicts with locally installed mongodb
    volumes:
      - /var/run/docker.sock:/var/run/docker.sockt
  client:
    build:
      context: "./client"
      dockerfile: Dockerfile
    environment:
      NODE_ENV: development
    ports:
      - "4000:4000"
  server:
    build:
      context: "./server"
      dockerfile: Dockerfile
    volumes: 
      - "./shared-folder:/app/shared-folder"
    ports:
      - "4001:4001"
```
