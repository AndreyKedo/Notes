- [Контейнеризация](#контейнеризация)
- [Docker](#docker)
- [Композиция контейнеров (Docker Compose)](#композиция-контейнеров-docker-compose)

# Контейнеризация

**Контейнер** (Container) — стандартная единица ПО, в которую упаковывается приложение со всеми необходимыми для его полноценной работы зависимостями (кодом, средой запуска, библиотеками и настройками).

## Преимущества контейнеров
* Возможность упаковать приложение вместе с его средой запуска. Это позволяет контейнеру запускаться одинаково в разных окружениях (операционных системах) и решает пооблему их настройки (подготовки к запуску приложения), а значит на каждом компьютере запуск контейнера происходит одинаково. 
* Поскольку в контейнерах содержится только самое необходимое (ничего лишнего), им свойственны легковесность, быстродействие и простота настройки.

# Docker

## Архитектура Docker

*Docker* использует *клиент-серверную архитектуру*. 

Клиент и сервер общаются между собой при помощи REST API поверх сокетов и сетевого интерфейса.

**Docker-клиент** (Docker client) использует CLI-команды, чтобы общаться с *Docker daemon*, выступающим в роли *сервера*.
```js
/* примеры CLI-команд */
docker run
docker build
docker pull
```
**Docker-демон** (Docker daemon) собирает, запускает и раздаёт (distribute) контейнеры.

**Образ** (Image) — доступный только для чтения шаблон с инструкциями о том, как запустить какой-то Docker-контейнер. 

Один образ может расширять другой.

Для создания образа необходимо создать *Dockerfile* для определения шагов, необходимых для создания образа и запустить этот файл. Каждая инструкция в Dockerfile создаёт новый слой (layer) в образе. Когда Dockerfile изменяется и образ пересобирается (rebuild), пересобираются только изменённые слои.

Образы хранятся в Docker-реестре (Docker registry). Одним из таких является Docker Hub - публичный реестр, который используется по умолчанию.
```js
// загрузить image из реестра
docker pull <image>
// загрузить image в реестр
docker push <image>
```

**Контейнер** (Container) — запускаемый экземпляр образа. Его можно создавать, запускать, останавливать, перемещать и удалять при помощи Docker API или CLI.

По умолчанию контейнер достаточно хорошо изолирован от маширы-хоста, но это можно контролировать, передавая в контейнер всё необходимое.

## Хранение данных

## Volume

**Volume** — предпочитительный механизм для хранения данных (persisting data), используемых в Docker-контейнере.

Volume даёт контейнеру доступ к какой-то локальной папке на машине-хосте, на которой этот контейнер запущен. Файлы из Volume нельзя использовать на этапе сборки (build-time), то есть в Dockerfile нельзя использовать файлы из Volume, они доступны лишь во время выполнения (run-time).

### Почему следует использовать Volume

Volume хранится вне контейнера. Поэтому он не увеличивает размер контейнера, а также не подвержен влиянию жизненного цикла контейнера.

## Аргументы

* Объявление аргументов в Dockerfile.
```dockerfile
ARG argument_name
ARG another_argument_name=default_value # со значением по умолчанию
```
* Использование в Dockerfile.
```dockerfile
RUN echo ${argument_name}
RUN echo ${another_argument_name}
```
* Передача аргументов в команду.

# Композиция контейнеров (Docker Compose)

**Docker Compose** — инструмент, позволяющий запускать приложения, состоящие из нескольких контейнеров.

## Передача переменных в Docker

### ENVIRONMENT vs ARGS

**Перееменные окружения ENVIRONMENT** передаются в уже запущенные контейнеры.
```yaml
client:
  environment:
    - NODE_ENV: production
    - SERVER_URL: xxx
```

**Переменные ARGS** доступны во время построения образа (build image).

```yaml
client:
  build:
    args:
      - port: 3000
      - env: production
```

### Пример конфигурации 3-уровнего приложения

Трёхуровневое (3-tier) приложение состоит из клиента, сервера и базы данных. Для каждого уровня необходим отдельный контейнер, а поскольку они связаны друг с другом, создаётся их композиция.

```yaml
version: '3.7'
services:
  mongo:
    command: mongod
    image: mongo:3.6.3
    ports:
      - "27017:27017" # map port to none standard port, to avoid conflicts with locally installed mongodb
    volumes:
      - /var/run/docker.sock:/var/run/docker.sockt
  client:
    build:
      context: "./client"
      dockerfile: Dockerfile
    environment:
      NODE_ENV: development
    ports:
      - "4000:4000"
  server:
    build:
      context: "./server"
      dockerfile: Dockerfile
    volumes: 
      - "./shared-folder:/app/shared-folder"
    ports:
      - "4001:4001"
```
