- [Контейнеры и контейнеризация](#контейнеры-и-контейнеризация)
  - [Сравнение контейнера и виртуальной машины](#сравнение-контейнера-и-виртуальной-машины)
  - [Преимущества контейнеров](#преимущества-контейнеров)
- [Docker](#docker)
  - [Архитектура Docker](#архитектура-docker)
  - [Использование образов с помощью FROM](#использование-образов-с-помощью-from)
  - [Копирование файлов с помощью ADD И COPY](#копирование-файлов-с-помощью-add-и-copy)
  - [Запуск команд с помощью RUN и CMD](#запуск-команд-с-помощью-run-и-cmd)
  - [Аргументы ARG](#аргументы-arg)
  - [Переменные окружения ENV](#переменные-окружения-env)
  - [Хранение данных в Volume](#хранение-данных-в-volume)
  - [Пример Dockerfile для NodeJS](#пример-dockerfile-для-nodejs)
- [Docker Compose для композиции контейнеров](#docker-compose-для-композиции-контейнеров)
  - [Пример композиции контейнеров трёхуровнего приложения](#пример-композиции-контейнеров-трёхуровнего-приложения)

# Контейнеры и контейнеризация

**Контейнер** (Container) — стандартная единица ПО, в которую упаковывается приложение со всеми необходимыми для его полноценной работы зависимостями (кодом, средой запуска, библиотеками и настройками).

## Сравнение контейнера и виртуальной машины

*Контейнер* — *процесс* или *сервис*, который *напрямую запущен на машине*. 

*Docker-демон* следит за тем, чтобы контейнер запускался в полной изоляции от операционной системы машины. Ничего подобного виртуальной машине при этом не создаётся.

**Виртуальная машина** (Virtual Machine) — *изолированная операционная подсистема на машине*.

 С помощью виртуальной машины можно внутри Windows ОС запустить Linux и наоборот. Существует множество инструментов, чтобы работать с виртуальными машинами (например, Virtual Box).

## Преимущества контейнеров
* Возможность упаковать приложение вместе с его средой запуска. Это позволяет контейнеру запускаться одинаково в разных окружениях (операционных системах) и решает пооблему их настройки (подготовки к запуску приложения), а значит на каждом компьютере запуск контейнера происходит одинаково. 
* Поскольку в контейнерах содержится только самое необходимое (ничего лишнего), им свойственны легковесность, быстродействие и простота настройки.

# Docker

## Архитектура Docker

*Docker* использует *клиент-серверную архитектуру*. 

Клиент и сервер общаются между собой при помощи REST API поверх сокетов и сетевого интерфейса.

**Docker-клиент** (Docker client) использует CLI-команды, чтобы общаться с *Docker daemon*, выступающим в роли *сервера*.
```js
/* примеры CLI-команд */
docker run
docker build
docker pull
```
**Docker-демон** (Docker daemon) собирает, запускает и раздаёт (distribute) контейнеры.

**Образ** (Image) — доступный только для чтения шаблон с инструкциями о том, как запустить какой-то Docker-контейнер. 

Один образ может расширять другой.

Для создания образа необходимо создать *Dockerfile* для определения шагов, необходимых для создания образа и запустить этот файл. Каждая инструкция в Dockerfile создаёт новый слой (layer) в образе. Когда Dockerfile изменяется и образ пересобирается (rebuild), пересобираются только изменённые слои.

Образы хранятся в Docker-реестре (Docker registry). Одним из таких является Docker Hub - публичный реестр, который используется по умолчанию.
```js
// загрузить image из реестра
docker pull <image>
// загрузить image в реестр
docker push <image>
```

**Контейнер** (Container) — запускаемый экземпляр образа. Его можно создавать, запускать, останавливать, перемещать и удалять при помощи Docker API или CLI.

По умолчанию контейнер достаточно хорошо изолирован от маширы-хоста, но это можно контролировать, передавая в контейнер всё необходимое.

## Использование образов с помощью FROM

**Инструкция FROM** инициализирует новый этап сборки и устанавливает *базовый образ*, функциональность которого может быть использована в последующих инструкциях. 
```dockerfile
# Dockerfile
FROM ubuntu:latest
```
```dockerfile
# Dockerfile

# образ для NodeJS
FROM node:latest 

# ...

# npm доступен благодаря образу node
RUN npm i 
```

*Валидный Dockerfile* должен *содержать* как минимум *одну инструкцию FROM* и она должна быть *первой инструкцией* в файле.

**Базовый образ** (Base Image) *не имеет родительского образа*. Для этого используется инструкция `FROM scratch`.

## Копирование файлов с помощью ADD И COPY

**Инструкция COPY** позволяет скопировать локальный файл или папку с машины в образ. Она принимает два параметра: относительный путь на машине, откуда копировать, и абсолютный путь, по которому данные будут доступны в контейнере.
```dockerfile
# Dockerfile
COPY ./package.json /app/
COPY ./src /app/src
```
**Инструкция ADD** может делать то же самое, но помимо этого она может принять URL как источник для копирования или разархивировать локальный `.tar` файл, а затем поместить в образ.
```dockerfile
# Dockerfile
ADD ./package.json /app/
ADD ./src /app/src

ADD archive.tar.gz /
ADD http://some_url.here /
```

Если нет явной необходимости в ADD, лучше использовать COPY.

## Запуск команд с помощью RUN и CMD

**Инструкция RUN** позволяет запускать команды внутри образа (image). Эти команды запускаются один раз во время сборки (build) и записываются в образ как новый слой (layer).
```dockerfile
# Dockerfile
RUN echo "Install modules"
RUN npm install
```

**Инструкция CMD** описывает *команду по умолчанию*, которая должна *запускаться при запуске готового образа, то есть контейнера*. 
```dockerfile
# Dockerfile
CMD npm start
```
Таким образом, несмотря на то, что CMD является инструкцией Dockerfile, он запускается не во время сборки, а уже в запущенном контейнере. Чаще всего командой в CMD выступает запуск сервера.

## Аргументы ARG
**Инструкция ARG** определяет переменную, которую можно передать во время сборки (build-time) контейнера.

* Объявление аргументов в Dockerfile.
```dockerfile
# Dockerfile
ARG argument_name
ARG another_argument_name=default_value # со значением по умолчанию
```
* Использование аргументов в Dockerfile.
```dockerfile
# Dockerfile
RUN echo ${argument_name}
RUN echo ${another_argument_name}
```
* Передача аргументов в команду сборки контейнера.
```cmd
docker-compose build --build-arg port=3000 --build-arg env="local"
```
```dockerfile
# Dockerfile
ARG port
ARG env
```

## Переменные окружения ENV

**Инструкция ENV** сохраняет переменную внутри контейнера. Таким образом переменная в контейнере доступна во время выполнения (run-time).
* Объявление переменных окружения в Dockerfile. 
```dockerfile
# Dockerfile
ENV env=production
```
* Передача в команду запуска контейнера.
```cmd
docker run -e env=production
```

Если есть необходимость передать аргумент как переменную окружения, то можно сделать это следующим образом.
```dockerfile
# Dockerfile
ARG port
ENV port=${port}
```

## Хранение данных в Volume

**Volume** — предпочитительный механизм для хранения данных (persisting data), используемых в Docker-контейнере.

Volume даёт контейнеру доступ к какой-то локальной папке на машине-хосте, на которой этот контейнер запущен. Файлы из Volume нельзя использовать на этапе сборки (build-time), то есть в Dockerfile нельзя использовать файлы из Volume, они доступны лишь во время выполнения (run-time).

### Почему следует использовать Volume

* Volume хранится вне контейнера, поэтому он не увеличивает размер контейнера и не подвержен влиянию жизненного цикла контейнера.

## Пример Dockerfile для NodeJS
```Dockerfile
# Dockerfile
FROM node:12.13.1

ARG port
ARG env

EXPOSE ${port}
COPY ./package.json /app/
COPY ./src /app/src

WORKDIR /app

RUN npm install
RUN NODE_ENV=${env} npm run build

CMD npm run start
```
```cmd

```

# Docker Compose для композиции контейнеров

Чаще всего приложения можно разделить на несколько контейнеров, которые зависят друг от друга. Понятно, что, чтобы приложение заработало, эти контейнеры нужно запускать вместе, причём в определённом порядке. Такой запуск называется **композицией контейнеров**.

**Docker Compose** — инструмент, позволяющий *составлять композицию контейнеров* (запускать приложения, состоящие из нескольких контейнеров).

Docker Compose использует файлы формала YAML (`.yml`).

## Пример композиции контейнеров трёхуровнего приложения

*Трёхуровневое* (3-tier) *приложение* состоит из клиента, сервера и базы данных. Для каждого уровня необходим отдельный контейнер, а поскольку они связаны друг с другом, создаётся их композиция.

Первым подключается база данных (сервис `db`), поскольку её может использовать сервер. Вторым подключается сервер (сервис `server`), поскольку его может использовать клиент. Последним подключается клиент (сервис `client`).

В docker-compose может указываться уже собранный образ (builded image) вместе с командой, которая должна быть запущена в контейнере; или `Dockerfile`, по котому образ будет создаваться.
```yaml
# docker-compose.yml
version: '3.7'
services:
  db:
    command: mongod
    image: mongo:3.6.3
    ports:
      - "27017:27017"
  server:
    build:
      context: "./server"
      dockerfile: Dockerfile
    ports:
      - "4001:4001"
  client:
    build:
      context: "./client"
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
```

## ENVIRONMENT и ARGS

**Перееменные окружения ENVIRONMENT** передаются в уже запущенные контейнеры.
```yaml
client:
  environment:
    - NODE_ENV: production
    - SERVER_URL: xxx
```

<!-- *Docker Compose* поддерживает объявление значений по умолчанию для переменных окружения в `.env` файле. -->

**Переменные ARGS** доступны во время построения образа (build image).

```yaml
client:
  build:
    args:
      - port: 3000
      - env: production
```

## Переменных в Docker Compose
* Передача переменных.
```cmd
ENV=production CLIENT_PORT=3000 docker-compose up --build
```
* Использование переменных.
```yml
version: '3.3'
services: 
  client:
    build:
      context: "./client"
      dockerfile: Dockerfile
      args:
        port: ${CLIENT_PORT}
        env: ${ENV}
    environment:
      NODE_ENV: ${ENV}
    ports:
      - "${CLIENT_PORT:-3000}:${CLIENT_PORT:-3000}" # default 3000:3000
```
