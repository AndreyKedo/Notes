- [Аутентификация, Авторизация и Идентификация](#аутентификация-авторизация-и-идентификация)
- [Разновидности идентификаторов. `ID`, `UID`, `UUID` и `GUID`](#разновидности-идентификаторов-id-uid-uuid-и-guid)
- [Виды аутентификации](#виды-аутентификации)
  - [Базовая (`Basic`)](#базовая-basic)
  - [`Bearer`](#bearer)
- [Сессии (`Sessions`) и `Cookie`](#сессии-sessions-и-cookie)
- [`JSON Web Token` (`JWT`)](#json-web-token-jwt)
  - [Виды токенов](#виды-токенов)
- [`OAuth`](#oauth)

## Аутентификация, Авторизация и Идентификация

**Идентификация** (англ. `identification`, лат. `identifico` — отождествлять) — *процедура распознавания объекта* (субъекта) по его *идентификатору*.  

Например, можно *идентифирировать* человека по имени, электронной почте, номеру телефона или паспорта.

**Аутентификация** (англ. `authentication`, греч. `αυθεντικός` — подлинный) — процедура проверки подлинности.

Например, можно определить подлинность проверкой пароля, отпечатка пальца, наличием пропуска или ключа от двери.

**Авторизация** (англ. `authorization` - разрешение, уполномочивание) – предоставление доступа к какому-либо ресурсу.

### Взаимосвязь
Стандартная последовательность действий на любом сайте.
* *Установление личности* (username, email, phone) – *идентификация*.
* *Проверка подлинности* (password) – *аутентификация*.
* *Предоставление доступа* – *авторизация*.

## Объект и субъект
**Объект** (лат. objectum — предмет) — философская категория, обозначающая вещь, явление или процесс, на которые направлена предметно-практическая, управляющая и познавательная деятельность субъекта (наблюдателя); при этом в качестве объекта может выступать и сам субъект.

## Разновидности идентификаторов. `ID`, `UID`, `UUID` и `GUID`

**Идентификатор** (англ. `identifier`, `ID`) — уникальный признак объекта (субъекта), позволяющий отличать его от других объектов (идентифицировать). 

Поле `ID` обычно является главным ключом (англ. `primary key`), по которому можно найти конкретный объект в коллекции объектов.

Поле `ID` чаще всего представлено в виде некоторого хэша, сгенерированного в заданном формате по некоторому алгоритму. Существует множество форматов ID, при этом для генерации могут использовать индексы (последовательное инкрементирование - самый простой случай), даты (англ. `timestamps`), рандомные числа, другие поля объекта, которые тоже по некоторому алгоритму становятся хэшем. Далее рассмотрим некоторые варианты `ID`.

`UUID` (англ. `Universally Uique IDentifier`) — *стандарт идентификации*, стандартизированный Open Software Foundation как часть среды распределённых вычислений (DCE). 

UUID позволяет уникально идентифицировать информацию, не имея при этом центра координации.  
То есть любой может создать `UUID` и использовать его для идентификации чего-либо с достаточным уровнем уверенности, что этот идентификатор не будет использован для чего-либо ещё непреднамеренно.

`UUID` имеет *несколько версий*, в которых используются:
* **Версии 1 и 2** - *время* и *MAC-адрес*.
* **Версия 3** - *хеширование* алгоритмом *MD5*.
* **Версия 4** - генерация *случайным образом*.
* **Версия 5** - *хеширование* алгоритмом *SHA-1*.

Библиотека в `npm`, позволяющая создавать и проверять валидность `UUID`:
```bash
npm i uuid
```

# Виды аутентификации

Для *проверки подлинности* (аутентификации) пользователя обычно на сервер вместе с запросом передаётся заголовок `Authorization`, в котором размещают тип аутентификации и соответствующие ей данные.
```http
Authorization: <type> <credentials>
```

## Базовая (`Basic`)

**Базовая** (Basic) **аутентификация** подразумевает передачу в заголовок имени пользователя и пароля в виде строки следующего вида `username:password`, зашифрованной в Base64.
```http
Authorization: Basic <encodedCredentials>
```
В JavaScript можно кодировать и декорировать Base64 следующим образом.
```js
const credentials = 'admin:admin';
/* кодировка */
const encodedCredentials = btoa('admin:admin');
console.log(encodedCredentials); // 'YWRtaW46YWRtaW4='
/* декодировка */
const decodedCredentials = atob('YWRtaW46YWRtaW4=');
console.log(decodedCredentials); // 'admin:admin'
```

## `Bearer`

```http
Authorization: Basic <encodedCredentials>
```

# Сессии (`Sessions`) и `Cookie`

```js
/* получение Cookie */
       /* Auth request
       with credentials */
Client --------------------> Server

        /* Set-Cookie 
        response header */
Client <-------------------- Server

        /* Cookie 
        request header */
Client --------------------> Server
```
Когда Cookie устаревают, они удаляются и на клиенте, и на сервере, поэтому описанный выше алгоритм повторяется.
```js
/* обновление auth_token */

        /* Cookie is
        missing (401) */
Client <-------------------- Server
```

<!-- Когда появляется внешний сервер аутентификации (другой url), -->

# `JSON Web Token (JWT)`

## Содержимое токена
```js
/* header.payload.signature */
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImdhcnJ5QGl0ZWNoYXJ0LWdyb3VwLmNvbSIsInN1YiI6MSwiaWF0IjoxNTgxMzUzMTk1LCJleHAiOjE1ODEzNjM5OTV9.sIAg18cc66dLi4PyLGzITOou8nppH056pxVVH0pgWMs
```
## Виды токенов

### Токен доступа

```js
/* получение или обновление refresh_token */

       /* Auth request
       with credentials */
Client --------------------> Auth Server

        /* auth_token,
        refresh_token */
Client <-------------------- Auth Server

        /* Authorization
        request header with
        auth_token */
Client --------------------> Server
```

**Токены доступа** (Access Tokens) представляют собой учётные данные (credentials), которые используеются для доступа к защищенным ресурсам.

Токен доступа отправляется на сервер с каждым запросом в `Authorization` заголовке запроса.

*Токены доступа* можно использовать неограниченное количество раз, но они обычно имеют *короткую продолжительность жизни* (обычно устанавливают ~15 минут), чтобы их нельзя было украсть и постоянно использовать.

Таким образом, если токен доступа украдут, то им можно будет пользоваться не более указанного в нём времени (например, не более 15 минут).

Время истечения токена может быть определено по полям  `exp` (expiration time), определяющим время жизни токена и `iat` (issued at), определяющим дату создания токена. Подделать это время нельзя, поскольку формула формирования токена нарушится и он станет невалидным.

Токены доступа не хранятся на сервере, на клиенте чаще всего хранятся в Local Storage (и берутся оттуда, чтобы их можно было отправить в заголовке запроса).

### Токен обновления

```js
/* обновление auth_token */

        /* auth_token is
        expired (401) */
Client <-------------------- Auth Server

        /* Auth request
       with refresh_token */
Client --------------------> Auth Server

        /* auth_token,
        refresh_token */
Client <-------------------- Server
```

Когда токен доступа истекает и требуется новый для доступа к ресурсу, клиенту необходимо обратиться к серверу аутентификации (Auth Server) для получения нового токена.

**Токен обновления** (Refresh Token) содержит информацию, необходимую для получения нового токена доступа.

Серверу аутентификации отсылается токен обновления и возвращается токен доступа.

Токены обновления одноразовые и обычно имеют долгую продолжительность жизни. 

Если токен обновления украден, его можно использовать только один раз, а значит получить только один токен доступа.

Если клиент видит, что его токен доступа невалиден (им уже воспользовались), он может перелогиниться. Таким образом сгенерируется новый токен обновления, а старый станет невалидным.

Токены обновления не хранят в себе какую-то информацию, как JWT-токены, и обычно представляют обычную хеш-строку. Токены обновления необходимо хранить на сервере.

В отличие от токенов доступа токены обновления хранятся на сервере. Они также хранятся и на клиенте.

# `OAuth`
