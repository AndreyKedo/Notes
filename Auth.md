- [Аутентификация vs Авторизация vs Идентификация](#аутентицикация-vs-авторизация-vs-идентификация)
- [Виды идентификаторов](#виды-идентификаторов)
- [Виды аутентификации](#виды-аутентификации)
  - [Базовая](#basic)
  - [Bearer](#bearer)
- [Сессии](#сессии)
- [JWT](#jwt)
  - [Виды токенов](#виды-токенов)

## Аутентификация vs Авторизация vs Идентификация

**Идентификация** (лат. identifico — отождествлять) — *процедура распознавания объекта* (субъекта) по его *идентификатору*.  

Например, можно *идентифирировать* человека по имени, электронной почте, номеру телефона или паспорта.

**Аутентификация** (греч. αυθεντικός — подлинный) — процедура проверки подлинности.

Например, можно определить подлинность проверкой пароля, отпечатка пальца, наличием пропуска или ключа от двери.

**Авторизация** (англ. authorization «разрешение; уполномочивание») – предоставление доступа к какому-либо ресурсу.

### Взаимосвязь
Стандартная последовательность действий на любом сайте.
* Установление личности (username, email, phone) – идентификация.
* Проверка подлинности (password) – аутентификация.
* Предоставление доступа – авторизация.

## Объект и субъект
**Объект** (лат. objectum — предмет) — философская категория, обозначающая вещь, явление или процесс, на которые направлена предметно-практическая, управляющая и познавательная деятельность субъекта (наблюдателя); при этом в качестве объекта может выступать и сам субъект.

## Виды идентификаторов. ID, UID, UUID и GUID

**Идентификатор** (identifier, ID) — уникальный признак объекта (субъекта), позволяющий отличать его от других объектов (идентифицировать).

**UUID (universally unique identifier)** — *стандарт идентификации*, стандартизированный Open Software Foundation как часть среды распределённый вычислений (DCE). 

UUID позволяет уникально идентифицировать информацию, не имея при этом центра координации.  
То есть любой может создать UUID и использовать его для идентификации чего-либо с достаточным уровнем уверенности, что этот идентификатор не будет использован для чего-либо ещё непреднамеренно.

*UUID* имеет *несколько версий*, в которых используются:
* **Версии 1 и 2** - *время* и *MAC-адрес*.
* **Версия 3** - *хеширование* алгоритмом *MD5*.
* **Версия 4** - генерация *случайным образом*.
* **Версия 5** - *хеширование* алгоритмом *SHA-1*.

*UUID* в Node.js:
```bash
npm i uuid
```

# Виды аутентификации

Для *проверки подлинности* (аутентификации) пользователя обычно на сервер вместе с запросом передаётся заголовок `Authorization`, в котором размещают тип аутентификации и соответствующие ей данные.
```http
Authorization: <type> <credentials>
```

## Базовая

**Базовая** (Basic) **аутентификация** подразумевает передачу в заголовок имени пользователя и пароля в виде строки следующего вида `username:password`, зашифрованной в Base64.
```http
Authorization: Basic <encodedCredentials>
```
В JavaScript можно кодировать и декорировать Base64 следующим образом.
```js
const credentials = 'admin:admin';
/* кодировка */
const encodedCredentials = btoa('admin:admin');
console.log(encodedCredentials); // 'YWRtaW46YWRtaW4='
/* декодировка */
const decodedCredentials = atob('YWRtaW46YWRtaW4=');
console.log(decodedCredentials); // 'admin:admin'
```

## Bearer

```http
Authorization: Basic <encodedCredentials>
```

# Сессии

```js
/* получение Cookie */
       /* Auth request
       with credentials */
Client --------------------> Server

        /* Set-Cookie 
        response header */
Client <-------------------- Server

        /* Cookie 
        request header */
Client --------------------> Server
```
Когда Cookie устаревают, они удаляются и на клиенте, и на сервере, поэтому описанный выше алгоритм повторяется.
```js
/* обновление auth_token */

        /* Cookie is
        missing (401) */
Client <-------------------- Server
```

<!-- Когда появляется внешний сервер аутентификации (другой url), -->

# JWT

## Виды токенов

### Токен доступа

```js
/* получение или обновление refresh_token */

       /* Auth request
       with credentials */
Client --------------------> Auth Server

        /* auth_token,
        refresh_token */
Client <-------------------- Auth Server

        /* Authorization
        request header with
        auth_token */
Client --------------------> Server
```

**Токены доступа** (Access Tokens) представляют собой учётные данные (credentials), которые используеются для доступа к защищенным ресурсам.

Токен доступа отправляется на сервер с каждым запросом в `Authorization` заголовке запроса.

*Токены доступа* можно использовать неограниченное количество раз, но они обычно имеют *короткую продолжительность жизни* (обычно устанавливают ~15 минут), чтобы их нельзя было украсть и постоянно использовать.

Таким образом, если токен доступа украдут, то им можно будет пользоваться не более указанного в нём времени (например, не более 15 минут).

Время истечения токена может быть определено по полям  `exp` (expiration time), определяющим время жизни токена и `iat` (issued at), определяющим дату создания токена. Подделать это время нельзя, поскольку формула формирования токена нарушится и он станет невалидным.

### Токен обновления

```js
/* обновление auth_token */

        /* auth_token is
        expired (401) */
Client <-------------------- Auth Server

        /* Auth request
       with refresh_token */
Client --------------------> Auth Server

        /* auth_token,
        refresh_token */
Client <-------------------- Server
```

Когда токен доступа истекает и требуется новый для доступа к ресурсу, клиенту необходимо обратиться к серверу аутентификации (Auth Server) для получения нового токена.

**Токен обновления** (Refresh Token) содержит информацию, необходимую для получения нового токена доступа.

Серверу аутентификации отсылается токен обновления и возвращается токен доступа.

Токены обновления одноразовые и обычно имеют долгую продолжительность жизни. 

Если токен обновления украден, его можно использовать только один раз, а значит получить только один токен доступа.

Если клиент видит, что его токен доступа невалиден (им уже воспользовались), он может сгенерировать новый и тогда старый станет невалидным.

Токены обновления не хранят в себе какую-то информацию, как JWT-токены, и обычно представляют обычную хеш-строку. Токены обновления необходимо хранить на сервере.
