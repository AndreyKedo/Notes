- [HTTP](#http)
  - [Связь между URI, URL и URN](#связь-между-uri-url-и-urn)
  - [Формат сообщений](#формат-сообщений)

# HTTP

**HyperText Transfer Protocol** (HTTP, протокол передачи гипертекста) — *протокол прикладного уровня передачи данных*.
В *основу* данного протокола входит технология **Клиент-Сервер**.  
*Клиенты* и *серверы обмениваются* *сообщениями* по схеме **запрос-ответ** (request–response): *клиент отправляет запрос*, *сервер возвращает ответ*.

*HTTP* является *общим языком* и *набором правил* для *клиента* и *сервера*.

*HTTP* определяет
* *синтаксис* (формат данных и кодирование),
* *семантику* (смысловое значение, связанное с синтаксисом),
* *время* (скорость и последовательность).  

*Каждый HTTP-запрос и ответ* считается отдельной **HTTP-транзакцией**.

*HTTP* основан на **текстовых данных** — **сообщениях**, состоящих из *битов текста*.  
*Каждое сообщение* состоит из *заголовка* (header) и *тела* (body).

*HTTP* — протокол *прикладного* уровня: *уровень абстракции*, стандартизирующий взаимодействие хостов.  
Сам *HTTP не передаёт данные*, а обращается за помощью к протоколу TCP / IP, чтобы получить запрос и ответ.  

Основным объектом манипуляции в HTTP является ресурс, на который указывает URI в запросе клиента.  

Одной из важных особенностей HTTP является то, что есть возможность задавать параметры в запросах и ответах: формат, кодировку и прочее.  
Несмотря на то, что HTTP является текстовым протоколом, он может обмениваться двоичными данными благодаря возможности кодировки.

Для идентификации ресурсов HTTP использует глобальные URI.  

*HTTP не хранит своё состояние* в отличие от многих других протоколов.  
Это означает, что сохранение промежуточного состояния между парами запрос-ответ отсутствует и HTTP не осведомлён о предыдущих запросах и ответах.  

Клиент, сервер и браузер могут самостоятельно хранить состояние, опираясь на данные последних запросов и ответов.  
Например, на стороне клиента могут храниться токены или куки.  
Сервер может хранить IP-адреса клиентов.  
Браузер может отслеживать задержки ответов.  

Обычные *HTTP-запрос* и *HTTP-ответ* *не зашифрованы и уязвимы* для различных типов атак.  
Эту проблему решает HTTPS (HTTP Secure) — безопастная версия протокола, использующая протол TLS или SSL для шифрования.

**SSL** - это **протокол безопасности**, который позволяет клиенту и серверу безопасно  
обмениваться данными по сети, предотвращая подслушивание и фальсификацию, в то  
время как сообщение передается по сети.

Другие протоколы прикладного уровня: FTP, SMTP.

## Связь между URI, URL и URN

**Uniform Resource Identifier** (URI) — символьная строка, позволяющая идентифицировать какой-либо ресурс: документ, изображение, электронную почту и прочее.   
Прежде всего, речь идёт о ресурсах сети Интернет и Всемирной паутины.    
URI предоставляет простой и расширяемый способ идентификации ресурсов.  

**Uniform Resource Locator** (URL) — URI, предоставляющий информацию о местонахождении ресурса.  

**Uniform Resource Name** (URN) — URI, который только идентифицирует ресурс в определённом пространстве имён (в определённом контексте), но не указывает его местонахождение.  
Пример: urn:ISBN:0-395-36341-1 — URI, указывающий на ресурс (книгу) 0-395-36341-1 в пространстве имён ISBN.

Поскольку URI не всегда указывает на то, как получить ресурс, в отличие от URL, а только идентифицирует его, это даёт возможность описывать с помощью RDF (Resource Description Framework) ресурсы, которые не могут быть получены через Интернет (например, личность, автомобиль, город и проч.).

## Формат сообщений

Как отмечалось ранее, клиент и сервер общаются сообщениями. 

Клиент посылает запросы и получает ответы от сервера.

Каждое сообщение содержит 

### Заголовок сообщения

**HTTP-заголовки** (HTTP Headers) обычно содержат **метаданные** (metadata), то есть *данные о данных*.  

*Метаданные* включают в себя:
- Тип запроса (request type): `GET`, `POST`, `PUT`, `DELETE` и другие.
- Путь запроса (URL): ссылка.
- Код статуса запроса (status code): `100` - `5xx`.
- Тип контента в запросе (content-type).
- Данные с клиента (User-agent): браузер, ОС и прочее.
- Куки (Cookie): текущая сессия.

### Тело сообщения

**Тело сообщения** (Message body) содержит данные. 

В зависимости от HTTP-метода тело может отсутствовать.

## HTTP-методы

**HTTP-глаголы** (verbs), **HTTP-методы** (methods) сообщают серверу, что делать с указанными в URL данными.  

*URL* всегда *идентифицируют определенный ресурс*.  

Когда клиент использует URL в сочетании с методом HTTP, он сообщает серверу, какое действие должно произойти с каким ресурсом.

Когда **клиент делает запрос**, он **указывает тип запроса**, используя один из этих глаголов.  

**Наиболее важными** из них являются **GET, POST, PUT и DELETE**.

### GET

**Метод GET** используется для **чтения информации для данного URL с сервера**.

GET-запросы доступны только для чтения, что означает, что данные никогда не должны  
изменяться на сервере - сервер должен просто получать данные без изменений. 

Таким образом, запросы GET считаются безопасными операциями, потому что вызов его один  
раз или вызов 20 раз будет иметь тот же эффект.

Кроме того, **запросы GET являются идемпотентными**.  
Это означает, что отправка нескольких запросов GET на один и тот же URL-адрес должна  
вызывать тот же эффект, что и один запрос GET, поскольку запрос GET просто запрашивает  
данные у сервера и фактически не изменяет какие-либо данные на сервере.

**GET-запросы отвечают кодом состояния 200 (ОК)**, если ресурс был успешно **найден**,  
и **404 (NOT FOUND)**, если ресурс **не был найден**.

### POST

**POST** используется для **создания нового ресурса**.  

Вы используете POST, когда хотите создать подчиненный ресурс (например, нового  
пользователя) для родительского ресурса.  

Ваше сообщение для этого родительского ресурса идентифицируется URL-адресом,  
а сервер обрабатывает новый ресурс и связывает его с родительским ресурсом.

**POST не является ни безопасным, ни идемпотентным**. Это связано с тем, что выполнение  
двух или более одинаковых запросов POST может привести к созданию двух новых идентичных  
ресурсов.

**POST-запросы отвечают кодом состояния 201 (CREATED)** вместе с заголовком местоположения  
со ссылкой на вновь созданный ресурс.

### PUT 

PUT используется для обновления ресурса, идентифицируемого URL-адресом, с  
использованием информации в теле запроса. PUT также может быть использован  
для создания нового ресурса.  

Запросы PUT не считаются безопасными операциями, поскольку они изменяют состояние на сервере.  
Однако PUT идемпотентен, потому что несколько идентичных запросов PUT на обновление ресурса  
должны иметь тот же эффект, что и первый.

PUT запросы отвечают статусом 200 если запрос успешно обновлён и 404 если ресурс не найден.

### DELETE

DELETE используется для удаления ресурса, указанного в URL.  

Запросы DELETE являются идемпотентными, потому что если вы удаляете ресурс,  
он удаляется, и даже если вы делаете несколько идентичных запросов DELETE,  
результат остается тем же: удаленный ресурс.

Скорее всего, вы просто получите сообщение об ошибке 404, если отправите запрос  
DELETE более одного раза для одного и того же ресурса, потому что сервер не сможет  
найти его после его удаления.

На запросы DELETE в ответ удаляется код состояния 200 (ОК), если он был успешно  
удален, или 404 (НЕ НАЙДЕН), если удаляемый ресурс не может быть найден.

https://medium.freecodecamp.org/how-the-web-works-part-iii-http-rest-e61bc50fa0a

## Что такое REST?

REST (Representational State Transfer) - архитектурный стиль для разработки  
приложений.

Его автор, Рой Филдинг, выступал за использование стандартных HTTP методов так,  
чтобы придать запросам определённый смысл. А также за то, что между кодами ответов
и самими ответами должен быть определённый смысл.

Основная идея заключается в том, что вы используете протокол «без сохранения  
состояния», «клиент-сервер», «кэшируемый» для выполнения вызовов между компьютерами  
- и чаще всего этот протокол является HTTP. 

Это просто причудливый способ сказать, что REST дает вам набор ограничений для  
разработки приложения. Эти ограничения помогают сделать систему более производительной,  
масштабируемой, прозрачной и надежной.

**Список ограничений**:
* **Uniform interface (единый интерфейс)**.
* **Stateless (отсутствие состояния)**. То есть все данные о состоянии, необходимые  
для обработки клиентского запроса, должны содержаться в самом запросе, и сервер должен  
отправлять все необходимые данные состояния обратно клиенту через сам ответ. 

Наличие такой системы без сохранения состояния делает приложения намного более  
масштабируемыми, потому что ни одному серверу не нужно беспокоиться о том, чтобы  
поддерживать одно и то же состояние сеанса в течение нескольких запросов.  
Все необходимое для получения данных о состоянии доступно в самом запросе и ответе.
