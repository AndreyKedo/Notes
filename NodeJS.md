- [Что такое NodeJS](#что-такое-nodejs)
- [Операции ввод-вывода](#операции-ввода-вывода)
- [Однопоточность и многопоточность](#однопоточность-и-многопоточность)
- [Синхронное и асинхронное программирование](#синхронное-и-асинхронное-программирование)
- [Блокирующие и неблокирующие операции ввода-вывода](#блокирующие-и-неблокирующие-операции-ввода-вывода)
- [Функция обратного вызова](#функция-обратного-вызова)
  - [Error-first callback](#error-first-callback)
  - [Callback hell](#callback-hell)
- [Промиссификация](#промиссификация)
- [Цикл событий NodeJS](#цикл-событий-nodejs)

## Что такое NodeJS

**NodeJS** — асинхронная, управляемая событиями (event-driven) серверная среда выполнения JavaScript, построенная на JavaScript-движке V8, который используется в Google Chrome.

В NodeJS используется кроссплатформенная библиотека `libuv`, нацеленная на асинхронный ввод-вывод.

## Однопоточность и многопоточность

NodeJS, как и JavaScript, имеет *только один поток*, называемый **основным потоком** (main thread). Это означает, что *в один момент времени* может исполняться *только одна операция*. 

Несмотря на то, что большинство языков программирования, нацеленных на серверную разработку, являются многопоточными (Java, Go, C#, Rust), создатели NodeJS считают, что разработка с использованием нескольких потоков неэффективна и довольно сложна. 

Использование нескольких потоков заставляет решать программистов проблемы блокировки потоков (только один поток может использовать определённый ресурс в один момент времени), при которой одни потоки ждут освобождения ресурсов другими.

## Операции ввода-вывода

**Ввод-вывод** (Input/Output, I/O) — взаимодействие обработчика информации (компьютера) с окружающим миром (человеком или другим компьютером).

**Ввод** (Input) — данные или сигналы, получаемые компьютером (системой). 

Ввод можно рассматривать как команду, которую получает система. Например, создание текстового файла.
```js
const fs = require('fs');
fs.writeFileSync('./NodeJS.md', 'Notes', 'utf-8');
```
**Вывод** (Output) — данные или сигналы, посланные системой.

Вывод можно рассматривать как результат действия системы. Например, данные прочитанного системой файла.
```js
const fs = require('fs');
const data = fs.readFileSync('./NodeJS.md', 'utf-8');
console.log(data.toString()); // 'Notes'
```

Фактически, любые действия в коде можно рассматривать как операции ввода-вывода (создание переменных, арифметические операции, логирование, отправка данных из одного места в другое и так далее).

В контексте NodeJS понятие операций ввода-вывода в основном относятся к взаимодействиям с системным диском и сетью (network), которые поддерживаются библиотекой `libuv`.

## Синхронное и асинхронное программирование

**Синхронное программирование** подразумевает синхронное (последовательное) выполнение операций в порядке их указания в коде. Следующая операция не может начать выполняться, пока не завершится текущая.

Большинство операций выполняется синхронно.
```js
console.log('start');
const sum = (a, b) => a + b;
console.log(sum(1, 7));
console.log('end');
// выведется 'start', 8, 'end'
```

**Асинхронное программирование** подразумевает последовательный запуск операций в порядке их указания в коде, при котором следующая операция не дожидается завершения предыдущей перед своим запуском (выполнение текущей операции не препятствует запуску следующей).

В следующем примере результат будет `1, 3, 2` несмотря на порядок в коде. Выполнение `setTimeout()` не препятствует запуску `console.log()`. Об подробнее будет рассказано далее.
```js
console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3');
// выведет 1, 3, 2
```

Понятие **асинхронный** (asyncronous, async) подразумевает, что *операция займёт какое-то время*, *выполнится в будущем, не прямо сейчас*.

## Блокирующие и неблокирующие операции ввода-вывода

**Блокировка** (Blocking) — ситуация, при которой блок JavaScript-кода не может быть запущен, поскольку основной поток находится в ожидании выполнения блока не JavaScript-кода.

Некоторые операции могут занимать довольно долгое время, что приводит к *блокировке основного потока*, поэтому их называют **блокирующими операциями ввода-выввода** (Blocking I/O). Операции, выполняющиеся достаточно быстро (арифметические операции, `console.log()` и многие другие), называют **неблокирующими операциями ввода-вывода** (Non-blocking I/O), поскольку они не блокируют основной поток.

Чаще всего блокирующими операциями (Input/Output, I/O): работа с файлами (пример ниже), с базами данных, асинхронные запросы и так далее.
```js
const fs = require('fs');

fs.writeFileSync('./input.txt', 'Hello!', 'utf8');
const data = fs.readFileSync('./input.txt', 'utf8');
console.log(data);
fs.unlinkSync('./input.txt');
```

С учётом того, что JavaScript ориентирован на события, одни из которых могут быть намного важнее других, очень важно не терять время на ожидание завершения запущенной операции, потому что во время ожидания могут быть выполнены другие, более важные вещи.

## Функция обратного вызова

**Функция обратного вызова** (Callback, cb) — *функция*, *передающаяся аргументом* в *другую функцию*. 

*Функции обратного вызова* могут быть использованы как *алгоритмы* для *решения задач*, имеющих *несколько способов решения*. Одной из таких задач является сортировка. 

В JavaScript метод `Array.prototype.sort(compareFunction)` принимает функцию обратного вызова `compareFunction`, использующуюся как алгоритм сравнения двух элементов массива.
```js
const compareFunction = (a, b) => a - b;
[1, 3, 2].sort(compareFunction); // [1, 2, 3]
```
Аналогично работают методы `find`, `filter` (поиск, фильтрация по заданному алгоритму) и многие другие.

Чаще всего *функции обратного вызова* используются как какой-то *набор инструкций*, который нужно *выполнить после совершения* какого-то *действия* или *наступления события*.

*Параметры Promise executor* `resolve` и `reject` являются *функциями обратного вызова*.
```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('resolved'), 3000);
});

promise.then(result => console.log(result)); // resolved (через ~3 секунды)
```
Функция `setTimeout(callback, delay)` принимает *функцию обратного вызова*, которая вызовется *не ранее*, чем *через* `delay` *миллисекунд*.
```js
setTimeout(() => console.log('Notes', 300);
// выведется строка 'Notes' не ранее, чем через 300мс
```

<!--

Код ниже отработает синхронно, последовательно.
```js
console.log('before');
console.log('after');
// выведет "before", "after"
```
Следующие два примера отработают асинхронно, непоследовательно.
```js
Promise.resolve('before').then(console.log);
console.log('after');
// выведет "after", "before"
```
```js
setTimeout(() => console.log('before'), 0);
Promise.resolve('after').then(console.log);
// выведет "after", "before"
```
Чтобы симулировать синхронное поведение (выполнить инструкции с логированием в правильном порядке), можно написать следующее.
```js
const after = () => console.log('after');

Promise.resolve('before')
  .then(console.log)
  .then(after);
// выведет "before", "after"

setTimeout((after) => {
  console.log('before');
  after();
}, 0, after);
// выведет "before", "after"
```
-->

## Error-first callback

Большинство асинхронных методов в *NodeJS* следуют *идиоматическому* (свойственному языку) *паттерну* **Error-first callback** (сперва ошибка).

*Идея паттерна* заключается в следующем
* *Функция обратного вызова* *передаётся последним аргументом* в метод, производящий некоторую *асинхронную операцию*.
* Если *операция завершается ошибкой*, *первым аргументом функции обратного вызова* станет *экземпляр* `Error`. 
* Если *операция завершается успешно*, *первым аргументом* станет `null`, а *результат операции* (данные) будет передан *вторым аргументом*.

*Обработка ошибок* и *данных* выглядит следующим образом
```js
const fs = require('fs');

const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
    /* обработать ошибку здесь */
  } else {
    console.log(data);
    /* обработать данные здесь */
  }
};

/* асинхронное чтение файла */
fs.readFile('/* ... */', readFileCallback);
```

Попытка выбросить ошибку `err` из функции обратного вызова является распространённой ошибкой, поскольку к моменту вызова `readFileCallback` код вокруг `fs.readFile` завершит своё выполнение. Ошибка не попадёт в `try..catch` и, скорее всего, приведёт к краху всего приложения.
```js
const readFileCallback = (err, data) => {
  if (err) {
    throw err; // так лучше не делать
  } else {
    console.log(data);
  }
};

try {
  fs.readFile('/* ... */', readFileCallback);
} catch (err) {
  /* ошибка сюда не попадёт */
  console.log(err);
}
```
Аналогичная ситуация с данными `data`. Их возврат при помощи `return` ничего не даст. Функция `fs.readFile` просто вызовет операцию чтения, но код не будет ждать её выполнения и пойдёт дальше. Поэтому возвращённое значение будет `undefined`.
```js
const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
  } else {
    console.log(data);
    return data;
  }
};

const data = fs.readFile('/* ... */', readFileCallback);
console.log(data); // undefined
```

## Callback hell

Как мы уже выяснили, использование функций обратного вызова помогает сделать код асинхронным: асинхронные операции вызываются, но дальнейший код не ждёт их завершения, продолжая свою работу. В итоге ошибки и данные из функций обратного вызова не могут быть возвращены: их необходимо обрататывать на месте.

Операции, которые должны выполниться после асинхронной операции, должны быть переданы в неё в функции обратного вызова, иначе правильная последовательность их выполнения не гарантируется.

Если есть несколько асинхронных последовательных операций, то появляется цепочка вложенных функций обратного вызова, что порождает своеобразное ветвление кода.

Например, асинхронное последовательное создание, чтение, удаление файла выглядит следующим образом.
```js
const fs = require('fs');

fs.writeFile('./input.txt', 'Hello!', 'utf8', (writeErr) => {
  if (writeErr) {
    console.error('White file error occured: ', writeErr);
  } else {
    fs.readFile('./input.txt', 'Hello!', 'utf8', (readErr, data) => {
      if (readErr) {
        console.error('Read file error occured: ', readErr);
      } else {
        console.log(data.toString());
        fs.unlink('./input.txt', (removeError) => {
          if (removeError) {
            console.error('Remove file error occured: ', readErr);
          }
        });
      }
    });
  }
});
```
Такое ветвление называют **Callback Hell**, а в других языках программирования можно встретить аналогичное понятие **Pyramid of doom**. Чем больше последовательных асинхронных операций, тем сложнее работать с таким кодом.


## Промиссификация

Есть *другой способ*: *промиссифицировать асинхронную функцию*. Например, промиссифицируем функции чтения и удаления файла.
```js
const fs = require('fs');

const readFile = filePath => new Promise((resolve, reject) => {
  fs.readFile(filePath, (err, data) => err ? reject(err) : resolve(data));
});

const removeFile = filePath => new Promise((resolve, reject) => {
  fs.unlink(filePath, err => err ? reject(err) : resolve());
});
```
```js
(async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
  } catch (e) {
    console.log(e);
  }
})();
```
Начиная с Node v11.0.0 можно использовать встроенное решение.
```js
const fs = require('fs').promises;

(async () => {
  try {
    const data = await fs.readFile('input.txt');
    await fs.unlink('input.txt');
  } catch (e) {
    console.log(e);
  }
})();
```

## Цикл событий NodeJS


