- [Что такое NodeJS](#что-такое-nodejs)
- [Операции ввод-вывода](#операции-ввода-вывода)
- [Однопоточность и многопоточность](#однопоточность-и-многопоточность)
- [Синхронное и асинхронное программирование](#синхронное-и-асинхронное-программирование)
- [Блокирующие и неблокирующие операции ввода-вывода](#блокирующие-и-неблокирующие-операции-ввода-вывода)
- [Функция обратного вызова](#функция-обратного-вызова)
  - [Error-first callback](#error-first-callback)
  - [Callback hell](#callback-hell)
- [Промиссы](#промиссы)
- [async..await](#asyncawait)
- [Цикл событий NodeJS](#цикл-событий-nodejs)

## Что такое NodeJS

**NodeJS** — асинхронная, управляемая событиями (event-driven) серверная среда выполнения JavaScript, построенная на JavaScript-движке V8, который используется в Google Chrome.

В NodeJS используется кроссплатформенная библиотека `libuv`, нацеленная на асинхронный ввод-вывод.

Несмотря на то, что NodeJS является однопоточным, он может использовать возможности нескольких ядер при помощи дочерних процессов из модуля `child_process` и модуля `cluster`.

## Однопоточность и многопоточность

NodeJS, как и JavaScript, является **однопоточным** (single-threaded), то есть имеет *только один поток*, называемый **основным потоком** (main thread). 

Наличие единственного потока означает, что *в один момент времени* может исполняться *только одна операция*.

Большинство языков программирования, нацеленных на серверную разработку, являются **многопоточными** (multi-threaded), что означает использование нескольких потоков. Примеры многопоточных языков: Java, Go, C#, Rust.

Тем не менее, создатели NodeJS считают, что разработка с использованием нескольких потоков неэффективна и довольно сложна. 

Использование нескольких потоков заставляет решать программистов проблемы параллелизма (concurrency issues), в том числе проблему блокировки потоков (dead-locking): только один поток может использовать определённый ресурс в один момент времени, другие потоки должны ожидать освобождения ресурса.

## Операции ввода-вывода

**Ввод-вывод** (Input/Output, I/O) — взаимодействие обработчика информации (компьютера) с окружающим миром (человеком или другим компьютером).

**Ввод** (Input) — данные или сигналы, получаемые компьютером (системой). 

Ввод можно рассматривать как команду, которую получает система. Например, создание текстового файла.
```js
const fs = require('fs');
fs.writeFileSync('./NodeJS.md', 'Notes', 'utf-8');
```
**Вывод** (Output) — данные или сигналы, посланные системой.

Вывод можно рассматривать как результат действия системы. Например, данные прочитанного системой файла.
```js
const fs = require('fs');
const data = fs.readFileSync('./NodeJS.md', 'utf-8');
console.log(data.toString()); // 'Notes'
```

Фактически, любые действия в коде можно рассматривать как операции ввода-вывода (создание переменных, арифметические операции, логирование, отправка данных из одного места в другое и так далее).

В контексте NodeJS понятие операций ввода-вывода в основном относятся к взаимодействиям с системным диском и сетью (network), которые поддерживаются библиотекой `libuv`.

## Синхронное и асинхронное программирование

**Синхронное программирование** подразумевает синхронное (последовательное) выполнение операций в порядке их указания в коде. Следующая операция не может начать выполняться, пока не завершится текущая.

Большинство операций выполняется синхронно.
```js
console.log('start');
const sum = (a, b) => a + b;
console.log(sum(1, 7));
console.log('end');
// выведется 'start', 8, 'end'
```

**Асинхронное программирование** подразумевает последовательный запуск операций в порядке их указания в коде, при котором следующая операция не дожидается завершения предыдущей перед своим запуском (выполнение текущей операции не препятствует запуску следующей).

В следующем примере результат будет `1, 3, 2` несмотря на порядок в коде. Выполнение `setTimeout()` не препятствует запуску `console.log()`. Об подробнее будет рассказано далее.
```js
console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3');
// выведет 1, 3, 2
```

Понятие **асинхронной** (asyncronous, async) **операции** подразумевает, что *операция займёт какое-то время*, *выполнится в будущем, не прямо сейчас*.

## Блокирующие и неблокирующие операции ввода-вывода

**Блокировка** (Blocking) — ситуация, при которой блок JavaScript-кода не может быть запущен, поскольку основной поток находится в ожидании результата выполнения другого кода (обычно не JavaScript-кода).

Операции, которые приводят к *блокировке основного потока* называют **блокирующими операциями ввода-выввода** (Blocking I/O). Такими операциями являются операции работы с файлами, базой данных, сетью и другие подобные.

Например, следующий код NodeJS работает с файлами синхронно.
```js
const fs = require('fs');

fs.writeFileSync('./input.txt', 'Hello!', 'utf8');
const data = fs.readFileSync('./input.txt', 'utf8');
console.log(data);
fs.unlinkSync('./input.txt');
```

В браузере основной поток может быть заблокирован функцией `alert` до тех пор, пока пользователь не закроет всплывшее окно.

Операции, которые не блокируют основной поток, называют **неблокирующими операциями ввода-вывода** (Non-blocking I/O). К ним относятся арифметические операции, логирование и прочее.

JavaScript-код выполняется довольно быстро и обычно не блокирует основной поток. Тем не менее, такая ситуация возможна, если код выполняется бесконечно (например, бесконечный цикл или бесконечная рекурсия). 

Например, код ниже никогда не завершится. 
```js
while (true) { /* ... */ }
```

JavaScript в браузере и NodeJS на сервере ориентированны на события. На клиенте важно быстро реагировать на действия пользователя, на сервере — отвечать на запросы клиента. Нельзя терять время на ожидание завершения операций, которые выполняются вне основного скрипта. Поэтому очень важно стремиться использовать асинхронные операции: они не блокируют основной поток.

Например, есть запрос, который обрабатывается 100 миллисекунд, из которых 80 уходят на выполнение блокирующих операций. В синхронном режиме эти 80 секунд сервер простаивает, в асинхронном он может потратить это время на обработку других запросов. И так каждый запрос.

Но просто так сделать все функции асинхронными не получится, некоторые блоки кода должны выполняться последовательно. Если так поступить с примером выше, то удаление файла может начаться раньше, чем закончится чтение, а вывод результата может произойти раньше его вычисления. 
```js
writeFile('./input.txt', 'Hello!', 'utf8');
const data = readFile('./input.txt', 'utf8');
console.log(data);
unlink('./input.txt');
```
Тут требуется особый подход: использование *функции обратного вызова*.

## Функция обратного вызова

**Функция обратного вызова**, **колбэк** (Callback, cb) — *функция*, *передающаяся аргументом* в *другую функцию*. 

*Функции обратного вызова* могут быть использованы как *алгоритмы* для *решения задач*, имеющих *несколько способов решения*. Одной из таких задач является сортировка. 

В JavaScript метод `Array.prototype.sort(compareFunction)` принимает функцию обратного вызова `compareFunction`, использующуюся как алгоритм сравнения двух элементов массива.
```js
const compareFunction = (a, b) => a - b;
[1, 3, 2].sort(compareFunction); // [1, 2, 3]
```
Аналогично работают методы `find`, `filter` (поиск, фильтрация по заданному алгоритму) и многие другие.

Но чаще всего *функции обратного вызова* используются как какой-то *набор инструкций*, который нужно *выполнить после совершения* какого-то *действия* или *наступления события*.

Именно такой вариант использования колбэков позволяет реализовать асинхронность в NodeJS. Использование колбэков позволяет убедиться, что код внутри них выполнится не раньше, чем асинхронная функция завершит своё выполнение. 

Сам подход появился в функциональном программировании ещё задолго до появления NodeJS и назывался **Continuation-passing Style** (CPS) и подразумевал, что *управление* (какой-то набор инструкций) *передавалось* далее *в форме продолжения* (continuation). То есть одна функция могла принять другую функцию — **функцию продолжения** (continuation function). По завершению своей работы вместо возвращения стандартного результата она вызывала функцию продолжения, передавая ей результат в качестве аргумента.

Большинство возможностей NodeJS сейчас использует функции продолжения (колбэки). Когда асинхронная, блокирующая операция поступает на вход и запускается, колбэк сохраняется в памяти и его выполнение откладывается, последующий код может продолжить своё выполнение. Как только основной код и асинхронная функция завершают своё выполнение, колбэк достаётся из памяти и выполняетсся в том же потоке, в котором выполнялся основной код. Такой подход весьма эффективен, поскольку значительно увеличивает пропускную способность и скорость NodeJS-приложений.

Пример асинхронной функции `setTimeout(callback, delay)`, принимающей *колбэк*, который вызовется *не ранее*, чем *через* `delay` *миллисекунд*.
```js
setTimeout(() => console.log('Notes'), 300);
// выведется строка 'Notes' не ранее, чем через 300мс
```

<!--

Пример асинхронной функции `Promise`, принимающей колбэк.
```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('resolved'), 3000);
});

promise.then(result => console.log(result)); // resolved (через ~3 секунды)
```

-->

## Error-first callback

Большинство асинхронных методов в *NodeJS* следуют *идиоматическому* (свойственному языку) *паттерну* **Error-first callback** (сперва ошибка), позволяющий довольно просто узнать, произошла ли ошибка при выполнении операции. 

Если паттерн не используется, пользователь самостоятельно должен по аргументам колбэка выяснять, была ли ошибка или нет, что значительно сложнее.

*Идея паттерна* заключается в следующем
* *Функция обратного вызова* *передаётся последним аргументом* в метод, производящий некоторую *асинхронную операцию*.
* Если *операция завершается ошибкой*, *первым аргументом функции обратного вызова* станет *экземпляр* `Error`. 
* Если *операция завершается успешно*, *первым аргументом* станет `null`, а *результат операции* (данные) будет передан *последующими аргументами аргументом* (чаще всего только вторым аргументом).
```js
const asyncFn = (param1, param2, /* ... */, callback) => {
  if (/* error occurs */) {
    return callback(new Error('reason'));
  }
  /* ... */
  const data = { /* ... */ };
  callback(null, data, /* ... */);
}
```
```js
const callback = (err, data, /* ... */) => { /* ... */ };
asyncFn(1, 2, /* ... */, callback);
```

*Обработка ошибок* и *данных* на примере *асинхронного чтения файла*
```js
const fs = require('fs');

const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
    /* обработать ошибку здесь */
  } else {
    console.log(data);
    /* обработать данные здесь */
  }
};

/* асинхронное чтение файла */
fs.readFile('/* ... */', readFileCallback);
```

Попытка выбросить ошибку `err` из функции обратного вызова является распространённой ошибкой, поскольку к моменту вызова `readFileCallback` код вокруг `fs.readFile` завершит своё выполнение. Ошибка не попадёт в `try..catch` и, скорее всего, приведёт к краху всего приложения.
```js
const readFileCallback = (err, data) => {
  if (err) {
    throw err; // так лучше не делать
  } else {
    console.log(data);
  }
};

try {
  fs.readFile('/* ... */', readFileCallback);
} catch (err) {
  /* ошибка сюда не попадёт */
  console.log(err);
}
```
Аналогичная ситуация с данными `data`. Их возврат при помощи `return` ничего не даст. Функция `fs.readFile` просто вызовет операцию чтения, но код не будет ждать её выполнения и пойдёт дальше. Поэтому возвращённое значение будет `undefined`.
```js
const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
  } else {
    console.log(data);
    return data;
  }
};

const data = fs.readFile('/* ... */', readFileCallback);
console.log(data); // undefined
```

## Callback hell

Как мы уже выяснили, использование функций обратного вызова помогает сделать код асинхронным: асинхронные операции вызываются, но дальнейший код не ждёт их завершения, продолжая свою работу. В итоге ошибки и данные из функций обратного вызова не могут быть возвращены: их необходимо обрататывать на месте.

Операции, которые должны выполниться после асинхронной операции, должны быть переданы в неё в функции обратного вызова, иначе правильная последовательность их выполнения не гарантируется.

Если есть несколько асинхронных последовательных операций, то появляется цепочка вложенных функций обратного вызова, что порождает своеобразное ветвление кода.

Например, асинхронное последовательное создание, чтение, удаление файла выглядит следующим образом.
```js
const fs = require('fs');

fs.writeFile('./input.txt', 'Hello!', 'utf8', (writeErr) => {
  if (writeErr) {
    console.error('White file error occured: ', writeErr);
  } else {
    fs.readFile('./input.txt', 'Hello!', 'utf8', (readErr, data) => {
      if (readErr) {
        console.error('Read file error occured: ', readErr);
      } else {
        console.log(data.toString());
        fs.unlink('./input.txt', (removeError) => {
          if (removeError) {
            console.error('Remove file error occured: ', readErr);
          }
        });
      }
    });
  }
});
```
Такое ветвление называют **Callback Hell**, а в других языках программирования можно встретить аналогичное понятие **Pyramid of doom**. Чем больше последовательных асинхронных операций, тем сложнее работать с таким кодом.

### Способы разрешения Callback Hell

На сегодняшний день эффективным решением проблемы является использование `Promise` и `async..await` 

До их появляения разработчики пытались уменьшить негативное влияние *Callback Hell*, вынося функции обратного вызова в переменные или даже в отдельные модули.

Если вынести функцию не удаётся (например, в неё используются переменные из замыкания), можно использовать именованные функции вместо анонимных. Это особенно может упростить понимание кода, когда асинхронная функция принимает несколько функций обратного вызова.
```js
fs.writeFile('./input.txt', 'Hello!', 'utf8', function writeFileCallback(err) {
  /* ... */
});
```
Использование паттерна *Error-first callback* также помогает бороться с *Callback Hell*: в каждой функции обратного вызова обрабатывается именно свойственная ей ошибка. В противном случае довольно трудно было бы понять, где ошибка возникла.

## Промиссы

Есть *другой способ разрешения Callback Hell*: *промиссификация асинхронных функций* и объединение их в цепочку промиссов (promise chaining). 

Promise не заменяет функции обратного вызова совсем (они всё ещё передаются в `then` и `catch`), но код читать становится намного проще.

Например, промиссифицируем асинхронные функции создания, чтения и удаления файла.
```js
const fs = require('fs');

/* промиссификация вручную */
const writeFile = (filePath, fileData, encoding) => new Promise((resolve, reject) => {
  fs.writeFile(filePath, fileData, encoding, (err, data) => err ? reject(err) : resolve(data));
});

/* промиссификация с помощью promisify */
const promisify = fn => (...args) => new Promise((resolve, reject) => {    
  const callback = (err, data) => err ? reject(err) : resolve(data);
  fn(...args, callback);
});
const readFile = promisify(fs.readFile);
const removeFile = promisify(fs.unlink);
```
```js
writeFile('input.txt', 'Notes', 'utf-8')
  .then(() => readFile('input.txt', 'utf-8');
  .catch(writeErr => console.error('Write file error occured: ', writeErr))
  .then(() => removeFile('input.txt')
  .catch(readErr => console.error('Read file error occured: ', readErr))
  .catch(removeErr => console.error('Remove file error occured: ', readErr));
```

Начиная с Node v11.0.0 можно использовать встроенные промиссы.
```js
const fs = require('fs').promises;

fs.readFile('input.txt')
  .then(() => { /* ... */ })
  .catch(() => { /* ... */ });
```

## async..await

Самым современным способом решения **Callback Hell**, который вообще исключает использование функций обратного вызова, является `async..await`.

Эта конструкция позволяет писать асинхронный код в синхронном стиле, поскольку под капотом оборачивает его в промиссы.

`await` дожидается выполнения промисса или цепочки промиссов (вызывает `.then` до тех пор, пока не вернётся ошибка или примитивное значение). Использование `await` доступно только внутри `async`.

`async` оборачивает результат выполнения функции или метода в промисс. 

```js
const asyncFn = async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
  } catch (e) {
    console.log(e);
  }
};

asyncFn(); // Promise
```
При использовании `async..await` ошибка или данные так же, как и в случае с функциями обратного вызова, не могут быть возвращены в код, в котором была вызвана функция: в данном случае они не покидают промисс.
```js
const asyncFn = async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
    return data;
  } catch (e) {
    console.log(e);
    throw e;
  }
};

asyncFn
  .then(data => { /* ... */ })
  .catch(err => { /* ... */ })
```
Ничего глобально не изменилось, код просто стал чище.

## Цикл событий NodeJS

Цикл событий (Event Loop) позволяет NodeJS выполнять неблокирующие операции ввода-вывода, пока блокирующие операции выполняются вне NodeJS.

Цикл событий не блокирует старт основного скрипта, поскольку запускается только после его завершения. 

Если в скрипте встречается какая-то блокирующая операция, её выполнение выносится из основного потока, а её колбэк выносится в цикл событий. Это позволяет продолжить выполнение скрипта и больше не возвращаться в это же место. Когда скрипт завершает работу, начинается работа цикла событий (если операции заканчивают своё выполнение, то в основном потоке запускаются их колбэки). Когда колбэки заканчиваются в цикле событий, NodeJS усыпляет его до дальнейших указаний.

Цикл событий как в браузере, так в и NodeJS скрыт от программиста. Он является внутренней реализацией.

<!--

Код ниже отработает синхронно, последовательно.
```js
console.log('before');
console.log('after');
// выведет "before", "after"
```
Следующие два примера отработают асинхронно, непоследовательно.
```js
Promise.resolve('before').then(console.log);
console.log('after');
// выведет "after", "before"
```
```js
setTimeout(() => console.log('before'), 0);
Promise.resolve('after').then(console.log);
// выведет "after", "before"
```
Чтобы симулировать синхронное поведение (выполнить инструкции с логированием в правильном порядке), можно написать следующее.
```js
const after = () => console.log('after');

Promise.resolve('before')
  .then(console.log)
  .then(after);
// выведет "before", "after"

setTimeout((after) => {
  console.log('before');
  after();
}, 0, after);
// выведет "before", "after"
```
-->
