- [Что такое NodeJS](#что-такое-nodejs)
- [Операции ввод-вывода](#операции-ввода-вывода)
- [Однопоточность и многопоточность](#однопоточность-и-многопоточность)
- [Синхронное и асинхронное программирование](#синхронное-и-асинхронное-программирование)
- [Блокирующие и неблокирующие операции ввода-вывода](#блокирующие-и-неблокирующие-операции-ввода-вывода)
- [Функция обратного вызова](#функция-обратного-вызова)
  - [Error-first callback](#error-first-callback)
  - [Callback hell](#callback-hell)
- [Промиссы](#промиссы)
- [Цикл событий NodeJS](#цикл-событий-nodejs)

## Что такое NodeJS

**NodeJS** — асинхронная, управляемая событиями (event-driven) серверная среда выполнения JavaScript, построенная на JavaScript-движке V8, который используется в Google Chrome.

В NodeJS используется кроссплатформенная библиотека `libuv`, нацеленная на асинхронный ввод-вывод.

## Однопоточность и многопоточность

NodeJS, как и JavaScript, является **однопоточным** (single-threaded), то есть имеет *только один поток*, называемый **основным потоком** (main thread). 

Наличие единственного потока означает, что *в один момент времени* может исполняться *только одна операция*.


Большинство языков программирования, нацеленных на серверную разработку, являются **многопоточными** (multi-threaded), что означает использование нескольких потоков. Примеры многопоточных языков: Java, Go, C#, Rust.

Тем не менее, создатели NodeJS считают, что разработка с использованием нескольких потоков неэффективна и довольно сложна. 

Использование нескольких потоков заставляет решать программистов проблемы блокировки потоков (dead-locking): только один поток может использовать определённый ресурс в один момент времени, другие потоки должны ожидать освобождения ресурса.

## Операции ввода-вывода

**Ввод-вывод** (Input/Output, I/O) — взаимодействие обработчика информации (компьютера) с окружающим миром (человеком или другим компьютером).

**Ввод** (Input) — данные или сигналы, получаемые компьютером (системой). 

Ввод можно рассматривать как команду, которую получает система. Например, создание текстового файла.
```js
const fs = require('fs');
fs.writeFileSync('./NodeJS.md', 'Notes', 'utf-8');
```
**Вывод** (Output) — данные или сигналы, посланные системой.

Вывод можно рассматривать как результат действия системы. Например, данные прочитанного системой файла.
```js
const fs = require('fs');
const data = fs.readFileSync('./NodeJS.md', 'utf-8');
console.log(data.toString()); // 'Notes'
```

Фактически, любые действия в коде можно рассматривать как операции ввода-вывода (создание переменных, арифметические операции, логирование, отправка данных из одного места в другое и так далее).

В контексте NodeJS понятие операций ввода-вывода в основном относятся к взаимодействиям с системным диском и сетью (network), которые поддерживаются библиотекой `libuv`.

## Синхронное и асинхронное программирование

**Синхронное программирование** подразумевает синхронное (последовательное) выполнение операций в порядке их указания в коде. Следующая операция не может начать выполняться, пока не завершится текущая.

Большинство операций выполняется синхронно.
```js
console.log('start');
const sum = (a, b) => a + b;
console.log(sum(1, 7));
console.log('end');
// выведется 'start', 8, 'end'
```

**Асинхронное программирование** подразумевает последовательный запуск операций в порядке их указания в коде, при котором следующая операция не дожидается завершения предыдущей перед своим запуском (выполнение текущей операции не препятствует запуску следующей).

В следующем примере результат будет `1, 3, 2` несмотря на порядок в коде. Выполнение `setTimeout()` не препятствует запуску `console.log()`. Об подробнее будет рассказано далее.
```js
console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3');
// выведет 1, 3, 2
```

Понятие **асинхронной** (asyncronous, async) **операции** подразумевает, что *операция займёт какое-то время*, *выполнится в будущем, не прямо сейчас*.

## Блокирующие и неблокирующие операции ввода-вывода

**Блокировка** (Blocking) — ситуация, при которой блок JavaScript-кода не может быть запущен, поскольку основной поток находится в ожидании выполнения блока не JavaScript-кода.

Некоторые операции могут занимать довольно долгое время, что приводит к *блокировке основного потока*, поэтому их называют **блокирующими операциями ввода-выввода** (Blocking I/O). Операции, выполняющиеся достаточно быстро (арифметические операции, `console.log()` и многие другие), называют **неблокирующими операциями ввода-вывода** (Non-blocking I/O), поскольку они не блокируют основной поток.

Чаще всего блокирующими операциями (Input/Output, I/O): работа с файлами (пример ниже), с базами данных, асинхронные запросы и так далее.
```js
const fs = require('fs');

fs.writeFileSync('./input.txt', 'Hello!', 'utf8');
const data = fs.readFileSync('./input.txt', 'utf8');
console.log(data);
fs.unlinkSync('./input.txt');
```

С учётом того, что JavaScript ориентирован на события, одни из которых могут быть намного важнее других, очень важно не терять время на ожидание завершения запущенной операции, потому что во время ожидания могут быть выполнены другие, более важные вещи.

## Функция обратного вызова

**Функция обратного вызова** (Callback, cb) — *функция*, *передающаяся аргументом* в *другую функцию*. 

*Функции обратного вызова* могут быть использованы как *алгоритмы* для *решения задач*, имеющих *несколько способов решения*. Одной из таких задач является сортировка. 

В JavaScript метод `Array.prototype.sort(compareFunction)` принимает функцию обратного вызова `compareFunction`, использующуюся как алгоритм сравнения двух элементов массива.
```js
const compareFunction = (a, b) => a - b;
[1, 3, 2].sort(compareFunction); // [1, 2, 3]
```
Аналогично работают методы `find`, `filter` (поиск, фильтрация по заданному алгоритму) и многие другие.

Но чаще всего *функции обратного вызова* используются как какой-то *набор инструкций*, который нужно *выполнить после совершения* какого-то *действия* или *наступления события*.

*Параметры Promise executor* `resolve` и `reject` являются *функциями обратного вызова*.
```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('resolved'), 3000);
});

promise.then(result => console.log(result)); // resolved (через ~3 секунды)
```
Функция `setTimeout(callback, delay)` принимает *функцию обратного вызова*, которая вызовется *не ранее*, чем *через* `delay` *миллисекунд*.
```js
setTimeout(() => console.log('Notes', 300);
// выведется строка 'Notes' не ранее, чем через 300мс
```

В NodeJS функции обратного вызова являются одной из самый важных концепций, поскольку именно они позволяют реализовать асинхронность: когда блокирующая операция поступает на вход и запускается, переданная ей функция обратного вызова поступает в очередь, а оставшийся код может продолжить своё выполнение. Как только основной код завершит своё выполнение и блокирующая операция завершится, функция обратного вызова достанется из очереди и вызовется. Такой подход весьма эффективен, поскольку значительно увеличивает пропускную способность и скорость NodeJS-приложений.

## Error-first callback

Большинство асинхронных методов в *NodeJS* следуют *идиоматическому* (свойственному языку) *паттерну* **Error-first callback** (сперва ошибка).

*Идея паттерна* заключается в следующем
* *Функция обратного вызова* *передаётся последним аргументом* в метод, производящий некоторую *асинхронную операцию*.
* Если *операция завершается ошибкой*, *первым аргументом функции обратного вызова* станет *экземпляр* `Error`. 
* Если *операция завершается успешно*, *первым аргументом* станет `null`, а *результат операции* (данные) будет передан *последующими аргументами аргументом* (чаще всего только вторым аргументом).
```js
const asyncFn = (param1, param2, /* ... */, callback) => {
  if (/* error occurs */) {
    return callback(new Error('reason'));
  }
  /* ... */
  const data = { /* ... */ };
  callback(null, data, /* ... */);
}
```
```js
const callback = (err, data, /* ... */) => { /* ... */ };
asyncFn(1, 2, /* ... */, callback);
```

*Обработка ошибок* и *данных* на примере *асинхронного чтения файла*
```js
const fs = require('fs');

const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
    /* обработать ошибку здесь */
  } else {
    console.log(data);
    /* обработать данные здесь */
  }
};

/* асинхронное чтение файла */
fs.readFile('/* ... */', readFileCallback);
```

Попытка выбросить ошибку `err` из функции обратного вызова является распространённой ошибкой, поскольку к моменту вызова `readFileCallback` код вокруг `fs.readFile` завершит своё выполнение. Ошибка не попадёт в `try..catch` и, скорее всего, приведёт к краху всего приложения.
```js
const readFileCallback = (err, data) => {
  if (err) {
    throw err; // так лучше не делать
  } else {
    console.log(data);
  }
};

try {
  fs.readFile('/* ... */', readFileCallback);
} catch (err) {
  /* ошибка сюда не попадёт */
  console.log(err);
}
```
Аналогичная ситуация с данными `data`. Их возврат при помощи `return` ничего не даст. Функция `fs.readFile` просто вызовет операцию чтения, но код не будет ждать её выполнения и пойдёт дальше. Поэтому возвращённое значение будет `undefined`.
```js
const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
  } else {
    console.log(data);
    return data;
  }
};

const data = fs.readFile('/* ... */', readFileCallback);
console.log(data); // undefined
```

## Callback hell

Как мы уже выяснили, использование функций обратного вызова помогает сделать код асинхронным: асинхронные операции вызываются, но дальнейший код не ждёт их завершения, продолжая свою работу. В итоге ошибки и данные из функций обратного вызова не могут быть возвращены: их необходимо обрататывать на месте.

Операции, которые должны выполниться после асинхронной операции, должны быть переданы в неё в функции обратного вызова, иначе правильная последовательность их выполнения не гарантируется.

Если есть несколько асинхронных последовательных операций, то появляется цепочка вложенных функций обратного вызова, что порождает своеобразное ветвление кода.

Например, асинхронное последовательное создание, чтение, удаление файла выглядит следующим образом.
```js
const fs = require('fs');

fs.writeFile('./input.txt', 'Hello!', 'utf8', (writeErr) => {
  if (writeErr) {
    console.error('White file error occured: ', writeErr);
  } else {
    fs.readFile('./input.txt', 'Hello!', 'utf8', (readErr, data) => {
      if (readErr) {
        console.error('Read file error occured: ', readErr);
      } else {
        console.log(data.toString());
        fs.unlink('./input.txt', (removeError) => {
          if (removeError) {
            console.error('Remove file error occured: ', readErr);
          }
        });
      }
    });
  }
});
```
Такое ветвление называют **Callback Hell**, а в других языках программирования можно встретить аналогичное понятие **Pyramid of doom**. Чем больше последовательных асинхронных операций, тем сложнее работать с таким кодом.

### Способы разрешения Callback Hell

На сегодняшний день эффективным решением проблемы является использование `Promise` и `async..await` 

До их появляения разработчики пытались уменьшить негативное влияние *Callback Hell*, вынося функции обратного вызова в переменные или даже в отдельные модули.

Если вынести функцию не удаётся (например, в неё используются переменные из замыкания), можно использовать именованные функции вместо анонимных. Это особенно может упростить понимание кода, когда асинхронная функция принимает несколько функций обратного вызова.
```js
fs.writeFile('./input.txt', 'Hello!', 'utf8', function writeFileCallback(err) {
  /* ... */
});
```
Использование паттерна *Error-first callback* также помогает бороться с *Callback Hell*: в каждой функции обратного вызова обрабатывается именно свойственная ей ошибка. В противном случае довольно трудно было бы понять, где ошибка возникла.

## Промиссы

Есть *другой способ разрешения Callback Hell*: *промиссификация асинхронных функций* и объединение их в цепочку промиссов (promise chaining). 

Promise не заменяет функции обратного вызова совсем (они всё ещё передаются в `then` и `catch`), но код читать становится намного проще.

Например, промиссифицируем асинхронные функции создания, чтения и удаления файла.
```js
const fs = require('fs');

/* промиссификация вручную */
const writeFile = (filePath, fileData, encoding) => new Promise((resolve, reject) => {
  fs.writeFile(filePath, fileData, encoding, (err, data) => err ? reject(err) : resolve(data));
});

/* промиссификация с помощью promisify */
const promisify = fn => (...args) => new Promise((resolve, reject) => {    
  const callback = (err, data) => err ? reject(err) : resolve(data);
  fn(...args, callback);
});
const readFile = promisify(fs.readFile);
const removeFile = promisify(fs.unlink);
```
```js
writeFile('input.txt', 'Notes', 'utf-8')
  .then(() => readFile('input.txt', 'utf-8');
  .catch(writeErr => console.error('Write file error occured: ', writeErr))
  .then(() => removeFile('input.txt')
  .catch(readErr => console.error('Read file error occured: ', readErr))
  .catch(removeErr => console.error('Remove file error occured: ', readErr));
```

Начиная с Node v11.0.0 можно использовать встроенные промиссы.
```js
const fs = require('fs').promises;

fs.readFile('input.txt')
  .then(() => { /* ... */ })
  .catch(() => { /* ... */ });
```

## async..await

```js
(async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
  } catch (e) {
    console.log(e);
  }
})();
```

## Цикл событий NodeJS

<!--

Код ниже отработает синхронно, последовательно.
```js
console.log('before');
console.log('after');
// выведет "before", "after"
```
Следующие два примера отработают асинхронно, непоследовательно.
```js
Promise.resolve('before').then(console.log);
console.log('after');
// выведет "after", "before"
```
```js
setTimeout(() => console.log('before'), 0);
Promise.resolve('after').then(console.log);
// выведет "after", "before"
```
Чтобы симулировать синхронное поведение (выполнить инструкции с логированием в правильном порядке), можно написать следующее.
```js
const after = () => console.log('after');

Promise.resolve('before')
  .then(console.log)
  .then(after);
// выведет "before", "after"

setTimeout((after) => {
  console.log('before');
  after();
}, 0, after);
// выведет "before", "after"
```
-->
