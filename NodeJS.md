- [Операции ввод-вывода](#операции-ввода-вывода)
- [Синхронное и асинхронное программирование](#синхронное-и-асинхронное-программирование)
- [Функция обратного вызова](#функция-обратного-вызова)
- [Error-first callback](#error-first-callback)
- [Callback hell](#callback-hell)
- [Промиссификация](#промиссификация)

## Операции ввода-вывода

**Ввод-вывод** (Input/Output, I/O) — взаимодействие обработчика информации (компьютера) с окружающим миром (человеком или другим компьютером).

**Ввод** (Input) — данные или сигналы, получаемые компьютером (системой). 

Ввод можно рассматривать как команду, которую получает система. Например, создание текстового файла.
```js
const fs = require('fs');
fs.writeFileSync('./NodeJS.md', 'Notes', 'utf-8');
```
**Вывод** (Output) — данные или сигналы, посланные системой.

Вывод можно рассматривать как результат действия системы. Например, данные прочитанного системой файла.
```js
const fs = require('fs');
const data = fs.readFileSync('./NodeJS.md', 'utf-8');
console.log(data.toString()); // 'Notes'
```

Фактически, любые действия в коде можно рассматривать как операции ввода-вывода (создание переменных, арифметические операции, логирование, отправка данных из одного места в другое и так далее).

## Однопоточность

JavaScript имеет только один поток, называемый **основным потоком** (main thread). Это означает, что *в один момент времени* может исполняться *только одна операция*. 

## Синхронное и асинхронное программирование

**Синхронное программирование** подразумевает синхронное (последовательное) выполнение операций в порядке их указания в коде. Следующая операция не может начать выполняться, пока не завершится текущая.

Большинство операций совершается синхронно.
```js
console.log('start');
const sum = (a, b) => a + b;
console.log(sum(1, 7));
console.log('end');
// выведется 'start', 8, 'end'
```

**Блокировка** (Blocking) — ситуация, при которой блок JavaScript-кода не может запуститься, поскольку основной поток занят обработкой другого блока кода и не может выполнять другие действия.

Некоторые операции могут занимать довольно долгое время, что приводит к блокировке основного потока, поэтому такие операции называют **блокирующими** (blocking). Операции, выполняющиеся достаточно быстро (арифметические операции, `console.log()` и многие другие), называют **неблокирующими** (non-blocking), поскольку они не блокируют основной поток.

Чаще всего блокирующими операциями являются **операции ввода/вывода** (Input/Output, I/O): работа с файлами (пример ниже), с базами данных и так далее. JavaScript, являясь высокоуровневым языком, не работает с файлами напрямую, перекладывая это на библиотеку `libuv` и ей подобные.
```js
const fs = require('fs');

fs.writeFileSync('./input.txt', 'Hello!', 'utf8');
const data = fs.readFileSync('./input.txt', 'utf8');
console.log(data);
fs.unlinkSync('./input.txt');
```

С учётом того, что JavaScript ориентирован на события, одни из которых могут быть намного важнее других, очень важно не терять время на ожидание завершения запущенной операции, потому что во время ожидания могут быть выполнены другие, более важные вещи.

**Асинхронное программирование** подразумевает последовательный запуск операций в порядке их указания в коде, при котором следующая операция не дожидается завершения предыдущей перед своим запуском (выполнение текущей операции не препятствует запуску следующей).

В следующем примере результат будет `1, 3, 2` несмотря на порядок в коде. Выполнение `setTimeout()` не препятствует запуску `console.log()`. Об подробнее будет рассказано далее.
```js
console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3');
// выведет 1, 3, 2
```

## Функция обратного вызова

**Функция обратного вызова** (Callback, cb) — *функция*, *передающаяся аргументом* в *другую функцию*. 

*Функции обратного вызова* могут быть использованы как *алгоритмы* для *решения задач*, имеющих *несколько способов решения*. Одной из таких задач является сортировка. 

В JavaScript метод `Array.prototype.sort(compareFunction)` принимает функцию обратного вызова `compareFunction`, использующуюся как алгоритм сравнения двух элементов массива.
```js
const compareFunction = (a, b) => a - b;
[1, 3, 2].sort(compareFunction); // [1, 2, 3]
```
Аналогично работают методы `find`, `filter` (поиск, фильтрация по заданному алгоритму) и многие другие.

Чаще всего *функции обратного вызова* используются как какой-то *набор инструкций*, который нужно *выполнить после совершения* какого-то *действия* или *наступления события*.

*Параметры Promise executor* `resolve` и `reject` являются *функциями обратного вызова*.
```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('resolved'), 3000);
});

promise.then(result => console.log(result)); // resolved (через ~3 секунды)
```
Функция `setTimeout(callback, delay)` принимает *функцию обратного вызова*, которая вызовется *не ранее*, чем *через* `delay` *миллисекунд*.
```js
const `setTimeout`
```
Код ниже отработает синхронно, последовательно.
```js
console.log('before');
console.log('after');
// выведет "before", "after"
```
Следующие два примера отработают асинхронно, непоследовательно.
```js
Promise.resolve('before').then(console.log);
console.log('after');
// выведет "after", "before"
```
```js
setTimeout(() => console.log('before'), 0);
Promise.resolve('after').then(console.log);
// выведет "after", "before"
```
Чтобы симулировать синхронное поведение (выполнить инструкции с логированием в правильном порядке), можно написать следующее.
```js
const after = () => console.log('after');

Promise.resolve('before')
  .then(console.log)
  .then(after);
// выведет "before", "after"

setTimeout((after) => {
  console.log('before');
  after();
}, 0, after);
// выведет "before", "after"
```

## Error-first callback

Большинство асинхронных методов в *NodeJS* следуют *идиоматическому* (свойственному языку) *паттерну* **Error-first callback** (сперва ошибка).

*Идея паттерна* заключается в следующем
* *Функция обратного вызова* *передаётся* *аргументы метода* (*последним аргументом*), производящего некоторую *асинхронную операцию*.
* Если *операция завершается ошибкой*, *первым аргументом функции обратного вызова* станет *экземпляр* `Error`. 
* Если *операция завершается успешно*, *первым аргументом* станет `null`, а *результат операции* (данные) будет передан *вторым аргументом*.

*Обработка ошибок* и *данных* выглядит следующим образом
```js
const fs = require('fs');

const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
    /* обработать ошибку здесь */
  } else {
    console.log(data);
    /* обработать данные здесь */
  }
};

/* асинхронное чтение файла */
fs.readFile('/* ... */', readFileCallback);
```

Попытка выбросить ошибку `err` из функции обратного вызова является распространённой ошибкой, поскольку к моменту вызова `readFileCallback` код вокруг `fs.readFile` завершит своё выполнение. Ошибка не попадёт в `try..catch` и, скорее всего, приведёт к краху всего приложения.
```js
const readFileCallback = (err, data) => {
  if (err) {
    throw err; // так лучше не делать
  } else {
    console.log(data);
  }
};

try {
  fs.readFile('/* ... */', readFileCallback);
} catch (err) {
  /* ошибка сюда не попадёт */
  console.log(err);
}
```
Аналогичная ситуация с данными `data`. Их возврат при помощи `return` ничего не даст. Функция `fs.readFile` просто вызовет операцию чтения, но код не будет ждать её выполнения и пойдёт дальше. Поэтому возвращённое значение будет `undefined`.
```js
const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
  } else {
    console.log(data);
    return data;
  }
};

const data = fs.readFile('/* ... */', readFileCallback);
console.log(data); // undefined
```

## Callback hell

Как мы уже выяснили, использование функций обратного вызова помогает сделать код асинхронным: асинхронные операции вызываются, но код не ждёт их завершения, продолжая работать дальше. Ошибки и данные не возвращаются из функций обратного вызова. Нужно их обрататывать на месте и таким образом появляется ветвление кода. Если нам нужно сделат несколько асинхронных операций подряд, то 
```js
const asyncFn = () =>
```
## Промиссификация

Есть *другой способ*: *промиссифицировать асинхронную функцию*. Например, промиссифицируем функции чтения и удаления файла.
```js
const fs = require('fs');

const readFile = filePath => new Promise((resolve, reject) => {
  fs.readFile(filePath, (err, data) => err ? reject(err) : resolve(data));
});

const removeFile = filePath => new Promise((resolve, reject) => {
  fs.unlink(filePath, err => err ? reject(err) : resolve());
});
```
```js
(async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
  } catch (e) {
    console.log(e);
  }
})();
```
Начиная с Node v11.0.0 можно использовать встроенное решение.
```js
const fs = require('fs').promises;

(async () => {
  try {
    const data = await fs.readFile('input.txt');
    await fs.unlink('input.txt');
  } catch (e) {
    console.log(e);
  }
})();
```
