# Как всё устроено

Примечание: в браузерах Webkit (Chrome, Safari) и Gecko (Mozilla) *терминология* немного отличается.  
Далее *будет рассматриваться версия Webkit* с *пометками* о том, как это называется в *Gecko*.

## Построение объектных моделей (DOM, CSSOM)

**Байты** (bytes) -> **Символы** (characters) -> **Лексемы** -> **Токены** (tokens) -> **Узлы** (nodes) -> **Объектная модель** (object model)

Браузер загружает HTML-файл с диска или из сети.  
Первым делом он обрабатывает, парсит (parse) HTML, применяя следующий *алгоритм*:
1) **Преобразование байтов в символы**. Браузер преобразует байты из HTML-файла в символы, опираясь на заданную в файле кодировку (например, UTF-8).  
2) **Лексический анализ (lexing, tokenization)**. Браузер конвертирует строки символов в отдельные распознанные группы — **лексемы**, каждая из которых имеет определённый смысл. Затем лексемы преобразовываются в объекты — **токены**, имеющие определённые свойства и правила.  
3) **Построение объектной модели**. На основании информации токенов и их последовательности выясняется, из каких элементов состоит HTML и как они расположены по отношению друг к другу. Первое позволяет представить html-элементы в виде объектов. Второе — в виде дочерних и родительских элементов одного дерева. Поскольку в качестве узлов, вершин (nodes) дерева берутся объекты, полученная модель называется **объектной моделью**.  

Полученную модель называют **объектной моделью документа** (Document Object Model, DOM).  

Пример *разбиения HTML на лексемы*: `<div class="box"></div>`.  
`<` - начало тега, `div` - название тега, `class` - название атрибута, `=` - символ, объединяющий атрибут и его значение, `"` - начало значения атрибута, `box` - значение атрибута, `"` - конец значения атрибута, `>` - конец тега, `</` - начало закрывающего тега, `div` - название тега, `>` - конец тега.  

Этот алгоритм браузер проделывает каждый раз, когда нужно обработать HTML.

Теперь браузер загружает подключенные к HTML-документу ресурсы (делая к ним запросы): картинки, видео, иконки, шрифты, а также CSS.
```html
<link rel="stylesheet" type="text/css" href="/styles.css"/>
```

Любой CSS, присутствующий в документе (загруженный файлом или встроенный в документ при помощи `<style>`, `style=""`), браузер обрабатывает по тому же алгоритму, что и HTML.  
Получившееся в результате работы алгоритма представление в виде дерева называется **объектной моделью CSS** (CSS Object Model, CSSOM).

В CSS многие стили применяются не только к самому элементу, но и к его потомкам.  
Это называется наследованием: потомки наследуют свойства предка.  
Именно поэтому CSS имеет древовидную структуру.
```html
<body>
	<div>Title</div>
	<span>Title</span>
</body>
```
```css
body { font-size: 18px; }
span { font-size: 24px; }
div { color: red; }
```
В примере выше `<div>` и `<span>` получат размер шрифта в 20 пикселей, установленный в `<body>`.  
При этом `<span>` переопределяет размер шрифта и имеет в итоге 24 пикселя, а `<div>` определяет.  

Наследуются не все свойства.  
Например, не наследуются свойста блочной модели (`border`, `margin`, `padding`, `width`, `height`), `background`, `transform` и другие.  
Наследуемые свойства не имеют специфичности.  
Их может перезаписать даже универсальный селектор `*`, имеющий нулевую специфичность.  

Чтобы элемент унаследовал родительское свойство, можно использовать значение `inherit`.
```css
p { color: inherit; }
```

Пример *разбиения CSS на лексемы* : `.box { width: 40px; }`.  
`.` - начало селектора по классу, `box` - название класса, `{` - начало блока объявлений, `width` - свойство, `:` - символ, объединяющий свойство с его значением, `40px` - значение свойства, `;` - конец объявления, `}` - конец блока объявлений.

## Запуск JavaScript

JavaScript - блокирующий ресурс для отрисовки, поскольку может напрямую работать с DOM.

Если скрипт внешний, то файл сперва загружается, а потом запускается.
```js
<script src="/main.js"></script>
```
Если скрипт встроенный, то файл сразу запускается.
```js
<script>console.log('Hi')</script>
```

Если скрипт как-то повлиял на объектные модели, то в них вносятся соответствующие изменения.

<!-- * файл загружается
* код парсится и строится Абстрактное Синтаксическое Дерево
* код преобразуется в машинный
* запускается машинный код -->

## Построение дерева рендеринга

Деревья DOM и CSSOM вместе объединяются в **дерево рендеринга** (Render Tree).  

*Алгоритм построения дерева рендеринга*   
1) На рассмотрение берутся вершины DOM.
2) Из рассмотрения *исключаются вершины*, которые не видны на странице: `<head>` со своим содержимым, `<script>` и прочие подобные.  
3) Для каждой *оставшейся вершины* находятся соответствующие наборы правил в CSSOM.  
4) Из рассмотрения *исключаются вершины*, которые *скрыты* при помощи *CSS*: имеют *объявление* `dispalay: none`.  
5) Каждая оставшейся вершина DOM вместе со своими наборами правил становится вершиной дерева рендеринга.  

*Вершина дерева рендеринга* называется **объектом рендеринга** (Render Object).  

В браузерах на движке *Gecko дерево рендеринга* может также называться **деревом фреймов** (Frame Tree), а *вершина дерева* - **фреймом** (frame) или **боксом** (box).

После построения дерева рендеринга браузер знает, какие объекты видны на странице и какие стили к ним нужно применить.

## Рассчёт макета (Layout, Reflow)
При рассчёте **макета** (Layout) вычисляются расположение элементов на экране и занимаемое ими место.  

В первую очередь проверяется метатег viewport.
```css
<meta name="viewport" content="width=device-width, initial-scale=1">
```
**Виртуальное окно**, **вьюпорт** (viewport) - область окна, в которой виден контент.  
Обычно она не совпадает с отрендеренной страницей, поэтому появляются полосы прокрутки (scrollbars).

Для этого браузер обходит (traverse) дерево рендендеринга, начиная от его корня <html>.

