# Как всё устроено

Примечание: в браузерах Webkit (Chrome, Safari) и Gecko (Mozilla) *терминология* немного отличается.  
Далее *будет рассматриваться версия Webkit* с *пометками* о том, как это называется в *Gecko*.

## Построение объектных моделей (DOM, CSSOM)

**Байты** (bytes) → **Символы** (characters) → **Лексемы** → **Токены** (tokens) → **Узлы** (nodes) → **Объектная модель** (object model)

*Алгоритм обработки HTML*:
1) **Загрузка файла**. Браузер загружает файл (обычно из сети или локальной файловой системы, т.е. с диска), закодированный какой-то кодировкой, и получает поток байтов.
```css
EF BB BF EF B9 A4 68 74 6D 6C EF B9 A5
```
2) **Распознавание кодировки**. Сначала браузер пытается распознать кодировку. Он считывает первые три байта из потока в буфер и проверяет, являются ли они символом маркера последовательности байтов (Byte Order Mark, `U+FEFF`), который указывает кодировку. Если да, то оставшиеся символы расшифровываются с учётом этой кодировки, если нет, то браузер пытается распознать кодировку самостоятельно, в случае неудачи далее используется кодировка UTF-8.
```css
0xEF 0xB9 0xA4 → U+FEFF → кодировка UTF-8
```
2) **Преобразование байтов в символы (decoding)**. Браузер расшифровывает (decode) поток байтов (stream of bytes) в символы, опираясь на заданную кодировку (encoding). [Подробнее об алгоритме декодирования можно прочитать здесь](./Encoding.md).
```html
0xEF 0xB9 0xA4 → U+FE64 → "<"
0x68 → U+0068 → "h"
0x74 → U+0074 → "t"
0x6D → U+006D → "m"
0x6C → U+006C → "l"
0xEF 0xB9 0xA5 → U+FE65 → ">"

<html>
```
3) **Лексический анализ (lexing, tokenization)**. Браузер конвертирует строки символов в отдельные распознанные группы — **лексемы**, каждая из которых имеет определённый смысл. Затем лексемы преобразовываются в объекты — **токены**, имеющие определённые свойства и правила.  
4) **Построение объектной модели**. На основании информации токенов и их последовательности выясняется, из каких элементов состоит HTML и как они расположены по отношению друг к другу. Первое позволяет представить html-элементы в виде объектов. Второе — в виде дочерних и родительских элементов одного дерева. Поскольку в качестве узлов, вершин (nodes) дерева берутся объекты, полученная модель называется **объектной моделью**.  

Полученную модель называют **объектной моделью документа** (Document Object Model, DOM).  

Пример *разбиения HTML на лексемы*: `<div class="box"></div>`.  
`<` - начало тега, `div` - название тега, `class` - название атрибута, `=` - символ, объединяющий атрибут и его значение, `"` - начало значения атрибута, `box` - значение атрибута, `"` - конец значения атрибута, `>` - конец тега, `</` - начало закрывающего тега, `div` - название тега, `>` - конец тега.  

Этот алгоритм браузер проделывает каждый раз, когда нужно обработать HTML.

Теперь браузер загружает подключенные к HTML-документу ресурсы (делая к ним запросы): картинки, видео, иконки, шрифты, а также CSS.
```html
<link rel="stylesheet" type="text/css" href="/styles.css"/>
```

Любой CSS, присутствующий в документе (загруженный файлом или встроенный в документ при помощи `<style>`, `style=""`), браузер обрабатывает по тому же алгоритму, что и HTML.  
Получившееся в результате работы алгоритма представление в виде дерева называется **объектной моделью CSS** (CSS Object Model, CSSOM).

В CSS многие стили применяются не только к самому элементу, но и к его потомкам.  
Это называется наследованием: потомки наследуют свойства предка.  
Именно поэтому CSS имеет древовидную структуру.
```html
<body>
	<div>Title</div>
	<span>Title</span>
</body>
```
```css
body { font-size: 18px; }
span { font-size: 24px; }
div { color: red; }
```
В примере выше `<div>` и `<span>` получат размер шрифта в 20 пикселей, установленный в `<body>`.  
При этом `<span>` переопределяет размер шрифта и имеет в итоге 24 пикселя, а `<div>` определяет.  

Наследуются не все свойства.  
Например, не наследуются свойста блочной модели (`border`, `margin`, `padding`, `width`, `height`), `background`, `transform` и другие.  
Наследуемые свойства не имеют специфичности.  
Их может перезаписать даже универсальный селектор `*`, имеющий нулевую специфичность.  

Чтобы элемент унаследовал родительское свойство, можно использовать значение `inherit`.
```css
p { color: inherit; }
```

Пример *разбиения CSS на лексемы* : `.box { width: 40px; }`.  
`.` - начало селектора по классу, `box` - название класса, `{` - начало блока объявлений, `width` - свойство, `:` - символ, объединяющий свойство с его значением, `40px` - значение свойства, `;` - конец объявления, `}` - конец блока объявлений.

## Запуск JavaScript

JavaScript — блокирующий ресурс для отрисовки, поскольку может напрямую работать с DOM.

Если скрипт внешний, то файл сперва загружается, а потом запускается (evaluate).
```js
<script src="/main.js"></script>
```
Если скрипт встроенный, то файл сразу запускается.
```js
<script>console.log('Hi')</script>
```

Если скрипт как-то повлиял на объектные модели, то в них вносятся соответствующие изменения.

<!-- * файл загружается
* код парсится и строится Абстрактное Синтаксическое Дерево
* код преобразуется в машинный
* запускается машинный код -->

## Построение дерева рендеринга

Деревья DOM и CSSOM вместе объединяются в **дерево рендеринга** (Render Tree).  

*Алгоритм построения дерева рендеринга*   
1) На рассмотрение берутся вершины DOM.
2) Из рассмотрения *исключаются вершины*, которые не видны на странице: `<head>` со своим содержимым, `<script>` и прочие подобные.  
3) Для каждой *оставшейся вершины* находятся соответствующие наборы правил в CSSOM.  
4) Из рассмотрения *исключаются вершины*, которые *скрыты* при помощи *CSS*: имеют *объявление* `dispalay: none`.  
5) Каждая оставшейся вершина DOM вместе со своими наборами правил становится вершиной дерева рендеринга.  

*Вершина дерева рендеринга* называется **объектом рендеринга** (Render Object).  

В браузерах на движке *Gecko дерево рендеринга* может также называться **деревом фреймов** (Frame Tree), а *вершина дерева* - **фреймом** (frame) или **боксом** (box).

После построения дерева рендеринга браузер знает, какие объекты видны на странице и какие стили к ним нужно применить.

## Рассчёт макета (Layout, Reflow)
При **рассчёте макета** (Layout) *вычисляются расположение элементов на экране* и *занимаемое* ими *место*, то есть их *геометрия*.  

В первую очередь проверяется вьюпорт.  
Его значение берётся из соответствующего метатега, в случае его отсутствия браузером задаётся значение по умолчанию.  
```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```
Значения высоты и ширины вьюпорта берутся как базовые, затем браузер обходит (traverse) дерево рендендеринга, начиная от его корня `<html>`, вычисляя все значения элементов: часто значения дочерних элементов зависят от родительских.

Пусть ширина вьюпорта составляет 800px.
```html
<body>
	<div class="parent">
		<div class="child"></div>
	</div>
</body>
```
```css
html {
  width: 50%; /* 400px, 50% от viewport */
}
body {
  width: 25%; /* 100px, 25% от html */
}
.parent {
  width: 100vw; /* 800px, 100% от viewport */
}
.child {
  width: 10%; /* 80px, 10% от parent */
}
```

После рассчёта макета каждый элемент на странице имеет свою блочную модель (box model), а все величины измерения переводятся в пиксели.  
## Прорисовка, отрисовка (Painting, Paint)

**Прорисовка** (Painting) – это процесс заполнения пикселей на экране.  
Иногда этот процесс называют **растеризацией, растрированием** (rasterisation, rasterization).

<!-- **Растеризация (информатика)** - один из методов рендеринга, при котором визуализация проводится проецированием объектов сцены на экран без сохранения эффекта перспективы -->

Он подразумевает вывод текста, цветов, изображений, границ и теней, по сути – всех визуальных частей элементов. Прорисовка обычно выполняется на нескольких поверхностях, которые называются слоями.

