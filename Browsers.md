# Файлы

<!-- Физическая память компьютера имеет байтовую структуру – единицей адресации является байт -->

**Файл** (file) — определенное количество информации (программа или данные), имеющее имя и хранящееся во внешней памяти компьютера.

**Текстовый** файл содержит текстовые данные (символы, составлящие слова, формулы и прочее).

**Двоичный, бинарный** файл содержит последовательность байт (состоящих из бит), которая что-то может значить.

Обычно принято *разделять файлы* на *текстовые* и *бинарные*, но оба этих типа хранятся в памяти компьютера одинаково: как последовательность байт.  
Текстовый файл просто интерпретируется в текст, но на самом деле является частным случаем бинарного файла.

**Имя файла** (filename) состоит из двух частей, разделенных точкой: название файла и расширение (тип).

**Файловая система** (file system) — система хранения файлов и организации каталогов.

# Как всё устроено

Примечание: в браузерах Webkit (Chrome, Safari) и Gecko (Mozilla) *терминология* немного отличается.  
Далее *будет рассматриваться версия Webkit* с *пометками* о том, как это называется в *Gecko*.

## Адресная строка браузера

**Uniform Resource Locator** (URL) — ссылка на веб-ресурс (документ, изображение и прочее), определяющая его расположение в компьютерной сети и способ его получения (зависит от протокола).

**Адресная строка** (address bar, URL bar) — элемент интерфейса веб-браузера, который отображает текущий URL и позволяет изменять его на любой другой.

Следующая схема URL описывает большинство случаев использования адресной строки.
```
protocol:[//hostname[:port]][/path][?query]
```
Допустим, пользователь ввёл URL и нажал Enter.

### Parse URL

**Лексема** — последовательность допустимых символов языка, имеющая определённый смысл для транслятора.

Браузер принимает введённую пользователем строку и пытается понять, из чего она состоит — разбивает её на лексемы (за счёт наличия `:`, `//`, `/`, `?`).  

Пример *разбиения URL на лексемы* http://localhost:3000.  
`http` - протокол, `localhost` - hostname, `3000` - порт.

Пример *разбиения URL на лексемы* https://twitter.com/favicon.ico.  
`https` - протокол, `twitter.com` - hostname, `favicon.ico` - путь.

Пример *разбиения URL на лексемы* https://github.com/Max-Starling?from=2018-12-01&to=2018-12-31.  
`https` - протокол, `github.com` - hostname, `Max-Starling` - путь, `from=2018-12-01&to=2018-12-31` - query.

При наличии в URL корректного hostname и отсутствии протокола, браузер подставляет нужный протокол самостоятельно (по умолчанию HTTP, HTTPS для сайтов).

Если отсутствует протокол и браузеру не удаётся найти корректный hostname в строке, то она воспринимается как поисковой запрос.  

Например, если пользователь ввёл в адресную строку `hello world`, то браузер с поисковиком Chrome по умолчанию перейдёт на https://www.google.com/search?q=hello%20world.

### Этап поиска DNS

**Domain Name System** (DNS) — иерархичесая децентрализованная система именования, хранящая информацию о доменах. Обычно её используют для получения IP-адреса по имени хоста.

Сперва браузер проверяет локальный кэш DNS.

В случае отсутствия кэша, для поиска (lookup) браузер вызывает функцию `gethostbyname`, которая работает по-разному в зависимости от операционной системы.

Функция `gethostbyname` сперва проверяет локальный файл `hosts` (текстовый файл, содержащий базу данных доменных имён и используемый для их трансляции в IP-адреса), содержимое которого задаётся администрартором компьютера.
```css
/* файл hosts */
127.0.0.1       localhost
```

Если файл `hosts` не содержит нужного домена, делается запрос к DNS-серверу, адрес которого хранится в системных настройках (system preferences).

Есть два популярных DNS-сервера: `1.1.1.1` — Cloudflare, `8.8.8.8` — Google), однако большинство людей используют DNS-сервер, предоставленный интернет-провайдером.

Браузер выполняет DNS-запрос по протоколу UDP.

## Построение объектных моделей (DOM, CSSOM)

**Байты** (bytes) → **Символы** (characters) → **Лексемы** → **Токены** (tokens) → **Узлы** (nodes) → **Объектная модель** (object model)

*Алгоритм обработки HTML-файла*:
1) **Загрузка файла**. Браузер загружает файл (обычно из сети или локальной файловой системы, т.е. с диска), закодированный какой-то кодировкой. В компьютерной памяти все файлы представляются байтами, поэтому при загрузке файла браузер получает поток байтов.
```css
EF BB BF EF B9 A4 68 74 6D 6C EF B9 A5
```
2) **Распознавание кодировки**. Сначала браузер пытается распознать кодировку. Он считывает первые три байта из потока в буфер и проверяет, являются ли они символом маркера последовательности байтов (Byte Order Mark, `U+FEFF`), который указывает кодировку. Если да, то оставшиеся символы расшифровываются с учётом этой кодировки, если нет, то браузер пытается распознать кодировку самостоятельно, в случае неудачи далее используется кодировка UTF-8.
```css
0xEF 0xB9 0xA4 → U+FEFF → маркер кодировки UTF-8
```
3) **Преобразование байтов в символы (decoding)**. Браузер расшифровывает (decode) поток байтов (stream of bytes) в символы, опираясь на заданную кодировку (encoding). [Подробнее об алгоритме декодирования можно прочитать здесь](./Encoding.md).
```html
0xEF 0xB9 0xA4 → U+FE64 → "<"
0x68 → U+0068 → "h"
0x74 → U+0074 → "t"
0x6D → U+006D → "m"
0x6C → U+006C → "l"
0xEF 0xB9 0xA5 → U+FE65 → ">"

<html>
```
4) **Лексический анализ (lexing, tokenization)**. Браузер конвертирует последовательности символов в отдельные распознанные группы — **лексемы**, каждая из которых имеет определённый смысл. Затем лексемы преобразовываются в объекты — **токены**, имеющие определённые свойства и правила.  

Пример *разбиения HTML на лексемы*: `<div class="box"></div>`.  
`<` - начало тега, `div` - название тега, `class` - название атрибута, `=` - символ, объединяющий атрибут и его значение, `"` - начало значения атрибута, `box` - значение атрибута, `"` - конец значения атрибута, `>` - конец тега, `</` - начало закрывающего тега, `div` - название тега, `>` - конец тега.  

5) **Построение объектной модели**. На основании информации токенов и их последовательности выясняется, из каких элементов состоит HTML и как они расположены по отношению друг к другу. Первое позволяет представить html-элементы в виде объектов. Второе — в виде дочерних и родительских элементов одного дерева. Поскольку в качестве узлов, вершин (nodes) дерева берутся объекты, полученная модель называется **объектной моделью**.  

Полученную модель называют **объектной моделью документа** (Document Object Model, DOM).  

Этот алгоритм браузер проделывает каждый раз, когда нужно обработать HTML.

Теперь браузер загружает подключенные к HTML-документу ресурсы (делая к ним запросы): картинки, видео, иконки, шрифты, а также CSS.
```html
<link rel="stylesheet" type="text/css" href="/styles.css"/>
```

Любой CSS, присутствующий в документе (загруженный файлом или встроенный в документ при помощи `<style>`, `style=""`), браузер обрабатывает по тому же алгоритму, что и HTML.  
Получившееся в результате работы алгоритма представление в виде дерева называется **объектной моделью CSS** (CSS Object Model, CSSOM).

Пример *разбиения CSS на лексемы* : `.box { width: 40px; }`.  
`.` - начало селектора по классу, `box` - название класса, `{` - начало блока объявлений, `width` - свойство, `:` - символ, объединяющий свойство с его значением, `40px` - значение свойства, `;` - конец объявления, `}` - конец блока объявлений.

В CSS многие стили применяются не только к самому элементу, но и к его потомкам.  
Это называется наследованием: потомки наследуют свойства предка.  
Именно поэтому CSS имеет древовидную структуру.
```html
<body>
	<div>Title</div>
	<span>Title</span>
</body>
```
```css
body { font-size: 18px; }
span { font-size: 24px; }
div { color: red; }
```
В примере выше `<div>` и `<span>` получат размер шрифта в 20 пикселей, установленный в `<body>`.  
При этом `<span>` переопределяет размер шрифта и имеет в итоге 24 пикселя, а `<div>` дополнительно устанавливает себе красный цвет.  

Наследуются не все свойства.  
Например, не наследуются свойста блочной модели (`border`, `margin`, `padding`, `width`, `height`), `background`, `transform` и другие.  
Наследуемые свойства не имеют специфичности.  
Их может перезаписать даже универсальный селектор `*`, имеющий нулевую специфичность.  

Чтобы элемент унаследовал родительское свойство, можно использовать значение `inherit`.
```css
p { color: inherit; }
```

## Запуск JavaScript

JavaScript — блокирующий ресурс для отрисовки, поскольку может напрямую работать с DOM.

Если скрипт внешний, то файл сперва загружается, а потом запускается (evaluate).
```js
<script src="/main.js"></script>
```
Если скрипт встроенный, то файл сразу запускается.
```js
<script>console.log('Hi')</script>
```

Если скрипт как-то повлиял на объектные модели, то в них вносятся соответствующие изменения.

<!-- * файл загружается
* код парсится и строится Абстрактное Синтаксическое Дерево
* код преобразуется в машинный
* запускается машинный код -->

## Построение дерева рендеринга

Деревья DOM и CSSOM вместе объединяются в **дерево рендеринга** (Render Tree).  

*Алгоритм построения дерева рендеринга*   
1) На рассмотрение берутся вершины DOM.
2) Из рассмотрения *исключаются вершины*, которые не видны на странице: `<head>` со своим содержимым, `<script>` и прочие подобные.  
3) Для каждой *оставшейся вершины* находятся соответствующие наборы правил в CSSOM.  
4) Из рассмотрения *исключаются вершины*, которые *скрыты* при помощи *CSS*: имеют *объявление* `dispalay: none`.  
5) Каждая оставшейся вершина DOM вместе со своими наборами правил становится вершиной дерева рендеринга.  

*Вершина дерева рендеринга* называется **объектом рендеринга** (Render Object).  

В браузерах на движке *Gecko дерево рендеринга* может также называться **деревом фреймов** (Frame Tree), а *вершина дерева* - **фреймом** (frame) или **боксом** (box).

После построения дерева рендеринга браузер знает, какие объекты видны на странице и какие стили к ним нужно применить.

## Рассчёт макета (Layout, Reflow)
При **рассчёте макета** (Layout) *вычисляются расположение элементов на экране* и *занимаемое* ими *место*, то есть их *геометрия*.  

В первую очередь проверяется вьюпорт.  
Его значение берётся из соответствующего метатега, в случае его отсутствия браузером задаётся значение по умолчанию.  
```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```
Значения высоты и ширины вьюпорта берутся как базовые, затем браузер обходит (traverse) дерево рендендеринга, начиная от его корня `<html>`, вычисляя все значения элементов: часто значения дочерних элементов зависят от родительских.

Пусть ширина вьюпорта составляет 800px.
```html
<body>
	<div class="parent">
		<div class="child"></div>
	</div>
</body>
```
```css
html {
  width: 50%; /* 400px, 50% от viewport */
}
body {
  width: 25%; /* 100px, 25% от html */
}
.parent {
  width: 100vw; /* 800px, 100% от viewport */
}
.child {
  width: 10%; /* 80px, 10% от parent */
}
```

После рассчёта макета каждый элемент на странице имеет свою блочную модель (box model), а все величины измерения переводятся в пиксели.  
## Прорисовка, отрисовка (Painting, Paint)

**Прорисовка** (Painting) – это процесс заполнения пикселей на экране.  
Иногда этот процесс называют **растеризацией, растрированием** (rasterisation, rasterization).

<!-- **Растеризация (информатика)** - один из методов рендеринга, при котором визуализация проводится проецированием объектов сцены на экран без сохранения эффекта перспективы -->

Он подразумевает вывод текста, цветов, изображений, границ и теней, по сути – всех визуальных частей элементов. Прорисовка обычно выполняется на нескольких поверхностях, которые называются слоями.

