# Оглавление
- [Информация и данные](#информация-и-данные)
- [Кодирование информации](#кодирование-информации)
- [Метаданные](#метаданные)


<!--
План: 
2) метод деления пополам
3) сжатие данных
4) logical unit
5) traversal
-->



# Информация и данные
- [Об информации и данных](#об-информации-и-данных)
- [Измерение информации](#измерение-информации)
- [Символ, алфавит и сообщение](#символ-алфавит-и-сообщение)
- [Количество информации (формула Хартли)](#количество-информации-формула-хартли)

## Об информации и данных

<!--
У *информации* существует *множество определений* в зависимости от *области применения* этого *термина*. Я *решил остановиться* на приведённом *ниже*.
-->

**Информация** (англ. information) - это *сведения* (*знания*) о некотором *объекте*, которые *не зависят от формы* их *представления*. Одна и та же *информация* может быть *представлена текстом, голосом, графически* и другими способами.

*Информация* отвечает на *вопросы*: “*Чем является* рассматриваемый *объект*? *Какие* он имеет *свойства*?”.

<!--
Например, в *теории информации* *информацией* называют *упорядоченную последовательность символов* некоторого *алфавита*.
-->

**Данные** (англ. data) - это *форма представления информации* в *цифровом виде*. 

Фактически, *данные* представляют собой *последовательность символов*, а каждый *символ* имеет *цифровое представление* в виде *последовательности нулей и единиц*, которая *задаётся кодировкой символа*.

<!-- Пример предложения и его цифрового представления в некоторой кодировке -->

Над *данными* можно *производить операции* на *ЭВМ*, в том числе *хранить*, *считывать*, *изменять*, *передавать*, *анализировать*, *шифровать* и многие другие.

*Информация* - это *смысл*, который *содержится* в *данных*. По сути говоря, *информация* является *абстракцией*, а *данные* являются её *реализацией*, хотя достаточно *часто* понятия “*данные*” и “*информация*” используют как *синонимы*.

## Измерение информации
- [Бит и байт](#бит-и-байт)
- [Системы измерения информации](#системы-измерения-информации)


### Бит и байт

**Битом** (англ. **bi**nary digi**t**, bit) или **двоичным разрядом** называют *минимальную, неделимую более единицу измерения информации*.

*Один бит* может *хранить* в себе *одно* из *двух возможных логических значений*. Чаще всего в *качестве значений* используются `1` (*единица*) и `0` (*ноль*) из *двоичной системы счисления*, но так же *допустимы значения*: `истина` и `ложь`, `да` и `нет`, `включено` и `выключено` и другие.

**Двоичной строкой** (англ. bit string), **двоичной последовательностью** называют *упорядоченную последовательность бит* (двоичных разрядов).

**Длиной двоичной строки** называют *количество бит* этой *строки*.

**Байтом** (англ. byte) или **октетом** (англ. octet) называют *последовательность* из *8 бит*. Например, *байтом* является *последовательность* `10111001`.

Всего *существует* `2^8 = 256` *комбинаций битов* в *одном байте*, что *несложно доказывается комбинаторно* (*доказательство ниже*). 
```
00000000
00000001
00000010
...
11111101
11111110
11111111
```

#### Доказательство
*Байт* можно рассматривать как *упорядоченный набор с повторениями* *длины* `8`, *состоящий* из *элементов множества* `A = { 0, 1 }`. *Мощность множества* `A` *равна* `2`. Тогда *число всевозможных* *наборов соответствует числу размещений с повторениями*: `A(8, 2) = 2^8 = 256`.

### Системы измерения информации

Существует *две системы измерения информации* в *битах* (*байтах*): **десятичная** (англ. decimal) и **двоичная**, **бинарная** (англ. binary).

*Десятичная система измерения* использует **десятичные префиксы** (англ. decimal prefixes, SI prefixes), *степени десятки*. Например, `kilo` - это `10^3`.

#### Десятичная система измерения информации (англ.)
Название | Обозначение | Значение
:--: | :--: | :--:
bit | b | 1 b
byte | B | 8 b = 1 B
kilobyte | KB | 10^3 B = 1000 B
megabyte | MB | 10^6 B = 1000 KB
gigabyte | GB | 10^9 B = 1000 MB
terabyte | TB | 10^12 B = 1000 GB
petabyte | PB | 10^15 B = 1000 TB

*Двоичная система измерения* использует **двоичные префиксы** (англ. binary prefixes, IEC prefixes), *степени двойки*. Например, `kibi` (`kilo binary`) - это `2^10`.

#### Двоичная система измерения информации (англ.)

Название | Обозначение | Значение
:--: | :--: | :--:
bit | b | 1 b
byte | B | 8 b = 1 B
kibibyte | KiB | 2^10 B = 1024 B
mebibyte | MiB | 2^20 B = 1024 KiB
gibibyte | GiB | 2^30 B = 1024 MiB
tebibyte | TiB | 2^40 B = 1024 GiB
pebibyte | PiB | 2^50 B = 1024 TiB

Можно составить *аналогичные таблицы*, используя *биты вместо байт* (`kilobit`, `megabit` и так далее).

*Большинство оборудования* в *наши дни* использует *десятичную систему измерения информации*.

#### Исключение для измерения RAM
При *измерении оперативной памяти (RAM)* всегда *используется бинарная система измерения информации*, но при этом *названия* обычно берутся из *десятичной системы измерения*.

Таким образом, при *измерении оперативной памяти*: `1 GB = 1024 MB = 2^10 B`.

## Символ, алфавит и сообщение
- [Символ](#символ)
- [Алфавит](#алфавит)
- [Сообщение](#сообщение)

### Символ

**Символом** (англ. character) называют *условный знак*, которым *обозначают* одно или несколько *понятий*.

Например, *символом* `“+”` *обозначают начало номера телефона* и *оператор сложения*, *символ* `“z”` *представляет* собой *определённую букву английского алфавита* с её *уникальным звучанием*, а *символ* `“7”` *представляет* собой *определённую арабскую цифру*.

### Алфавит
*Рекомендуется* прочитать: [Множество](), [Мощность множества](), [Набор элементов]().

Напомним, что *множество* - это *неупорядоченный набор уникальных элементов*.

**Алфавитом** (англ. alphabet) называют *конечное непустое множество символов*. 

Пример *алфавита* `A`, *каждый символ* которого *обозначает арифметическую операцию*: `{ “+”, “-”, “•”, “÷” }`.

**Мощностью |A| алфавита `A`** называют *количество символов алфавита*.

Например, *алфавит* `A` из *примера выше* имеет *мощность* `|A| = 4`.

### Сообщение
Одним из самых распространённых *способов передачи информации* является *сообщение*.

**Сообщением** (англ. message) называют *упорядоченный набор символов* (*элементов*) *с повторениями*, *составленный* из *символов* некоторого *алфавита* `A`.

Под *определение выше* также подходят *понятия* “**текст**” и “**строка**”.

Примеры *сообщений*, *составленных* из *символов алфавита* `A = { a, e, p, r }`: `pear`, `are`, `rap`, `prrr`.

**Длиной сообщения** называют *количество символов* этого *сообщения*.

<!-- удалить раздел ниже? -->

#### Число сообщений фиксированной длины

<!--
*Рекомендуется* прочитать: [Размещения с повторениями (комбинаторика)]().
-->

**Число сообщений длины `k` из символов алфавита мощности `n`** *соответствует* **числу размещений с повторениями из `n` по `k`**, а именно **`A(n, k) = n^k`**.

Например, *число сообщений длины* `k = 3` из символов *алфавита мощности* `n = 4` *равно* `4^3 = 64`.

## Количество информации (формула Хартли)
- [Формула Хартли](#формула-хартли)


### Формула Хартли
*Рекомендуется* прочитать: [Логарифм]().

Пусть *имеется* некоторый **алфавит `A`** **мощности `n`**, *символы* которого *используются* при *составлении сообщений*. 

**Формулой Хартли** называют *формулу*, по которой *вычисляется* **количество информации `I` в** некотором **сообщении длины `k`**, *составленном* из *символов алфавита* `A` *мощности* `n`:  
**`I = k • log2(n)`**.

Тогда **количество информации `i` в одном символе** *алфавита* `A` вычисляется по *формуле*:  
**`i = I ÷ k = log2(n)`**.

В качестве *единиц измерения* для `I` и `i` используются **биты**.

Из *последней формулы* и *свойств логарифма* *следует*, что *мощность алфавита* `A`:  
**`n = 2^i`**.

Поскольку *бит* является *минимальной* (*неделимой*) величиной, *количество информации округляется* до *целого числа*. Причём, происходит *округление вверх* (*к большему целому*, *математическое округление*), чтобы *не было потерь информации*:  
**`i = ⌈ log2(n) ⌉`**, **`I = k • i`**.

Например, в *английским языке* `26` *букв*, то есть `52` *символа*, если *учитывать* и *строчные*, и *прописные буквы*. Возьмём *английский алфавит в качестве алфавита* `A`, тогда `|A| = n = 52` и *количество информации* в *одном символе алфавита* `A` *равно* `i = ⌈ log2(52) ⌉ = log2(64) = 6` *бит*. В таком случае, *любое сообщение длины* `k = 7`, *составленное* из *символов алфавита* `A`, *займёт* `I = k • i = 42` *бит*.


# Кодирование информации
- [Кодирование и декодирование](#кодирование-и-декодирование)
- [Набор символов и кодировка](#набор-символов-и-кодировка)
- [Код](#код)
- [Разновидности кодировок](#разновидности-кодировок)
- [О кодировке ASCII](#о-кодировке-ascii)
- [О стандарте Unicode](#о-стандарте-unicode)

## Кодирование и декодирование

**Кодированием** (англ. encoding) называют *процесс преобразования последовательности символов некоторого алфавита* `A` в *последовательность символов другого алфавита* `B`. 

**Декодированием** (англ. decoding) называют *процесс обратного преобразования* из *последовательности символов алфавита* `B` в *последовательность символов алфавита* `A`. 

Фактически, можно рассматривать *кодирование* как *преобразование информации* в *данные*, а *декодирование* как *преобразование данных* в *информацию*.

## Набор символов и кодировка

**Набором символов** (англ. character set, charset) называют некоторый *алфавит*, *символы* которого *могут* быть *использованы* во многих *других алфавитах*.

Например, некоторый *набор символов* может *содержать символы латинского алфавита* `{ ..., a, b, ..., z, ... }`, а *многие* из этих *символов используются* в *английском*, *немецком*, *французском*, *итальянском* и других алфавитах.

**Кодировкой символов** (англ. character encoding) или просто **кодировкой** (англ. encoding) называют *закодированный набор символов*, то есть такую *таблицу*, в которой *каждому символу* из *набора символов* *ставится* в *соответствие последовательность из одного или нескольких символов* некоторого *другого алфавита*. 

Обычно в *кодировке* *каждому символу* из *набора символов* ставится в *соответствие* некоторое *целое число* *аналогично* тому, как *каждому элементу массива* (*коллекции*) ставится в *соответствие* его *индекс*. Это *целое число* обычно *представляют* в *одной* из *трёх форм*:
1) В **десятичной системе счисления** (10 с/с), которая *привычна человеку*.
2) В **двоичной системе счисления** (2 с/с), чтобы показать, *как компьютер видит* данное *число*.
3) В **шестнадцатиричной системе счисления** (16 с/с) для *краткости записи длинных чисел*.

Например, в некотором *закодированном наборе символов* `A` *символу* `'#'` *может соответствовать десятичное число* `124` (в *2 с/с* - `01111100`, в *16 с/с* - `7c`), а *символу* `'$'` - *десятичное число* `255` (в *2 с/с* - `11111111`, в *16 с/с* - `ff`).

*Одному набору символов может соответствовать несколько кодировок*.


<!-- набор символов - коллекция символов -->

## Код
- [О коде](#о-коде)
- [Формальное определение кода и его расширения](#формальное-определение-кода-и-его-расширения)

### О коде

**Кодом** (англ. code) называют некоторый *алгоритм* (*последовательность действий*, *набор инструкций*), который *преобразует символ одного алфавита* `A` в *определённую последовательность символов* другого *алфавита* `B`. 

*Алфавит* `A` называют **исходным алфавитом** (англ. source alphabet), а *алфавит* `B` - **целевым алфавитом** (англ. target alphabet). 

*Если целевой алфавит* `B` *содержит лишь два символа* (*может закодировать лишь два состояния*), то *код* называют **двоичным** или **бинарным кодом** (англ. binary code). Чаще всего *целевой алфавит бинарного кода состоит* из *нуля и единицы*, то есть `B = { 0, 1 }`, что приводит нас к *использованию двоичной системы счисления* (англ. the binary number system).

**Кодом символа** будем называть *закодированное представление* этого *символа*.

### Формальное определение кода и его расширения

Пусть *имеются* *исходный* и *целевой алфавиты* `A` и `B`. Пусть также *имеются бесконечные множества* `A*` и `B*`, являющиеся *множествами всевозможных последовательностей символов алфавитов* `A` и `B` *соответствено*.

**Кодом** называют такую *функцию* (*отображение*) **`c: A → B*`**, которая *преобразует* (англ. map) *каждый символ алфавита* `A` в некоторую *последовательность символов алфавита* `B`. Такая *последовательность однозначно определяется заданным алгоритмом* (*набором символов*).

**Расширением кода `c`** (англ. extension) называют *функцию* **`c*: A* → B*`**, которая *преобразует любую последовательность символов алфавита* `A` в *определённую последовательность символов алфавита* `B`. 

<!--
`f(x) = y`, где `x` - *упорядоченный набор (кортеж) символов алфавита* `A`, а `y` - *упорядоченный набор (кортеж) символов алфавита* `B`. Тогда *пример выше* можно *записать* как `f('a') = 01000001`.
-->

#### Пример кода и его расширения

Пусть *имеется исходный алфавит* `A = { r, s, t }` и *целевой алфавит* `B = { 0, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9 }`.


По определению, *кодом* является *функция* **`c: A → B*`**, которая *принимает символ алфавита* `A` и *возвращает последовательность символов алфавита* `B` (*десятичное число*) по *заданному правилу*.


Пусть теперь *последовательность символов алфавита* `B` задаётся *кодировкой ANSII*.
Символ | Десятичный код символа
:--: | :--:
r | 162
s | 163
t | 164

В таком случае *справедливо следующее*
```
с('r') = 162,
c('s') = 163,
c('t') = 164,
```
что так же *можно записать*
```
c = { r ↦ 162, s ↦ 163, t ↦ 164 },
```
где `r, s, t ∈ A` и `162, 163, 163 ∈ B*`.

Рассмотрим теперь *расширение кода* в виде *функции* **`c*: A* → B*`**, которая *принимает последовательность символов исходного алфавита* `A` и *преобразует* её в *последовательность символов целевого алфавита* `B` по тому же *правилу*, что и *код* `c: A → B*` .

Например, пусть `ts, ssr ∈ A*`, тогда
```
c* = { ts ↦ 164162, ssr ↦ 16316312 },
```
где `164162, 16316312 ∈ B*`.

<!--
Из примера выше понятно, что для *декодирования* необходимо знать фиксированную длину кода символа, иначе разделить последовательность не получится
Например, можно установить длину = 3, тогда в случае двухзначного числа впереди добавится 0
-->


<!--

Со временем пришли к тому, что 256 символов не достаточно, поэтому в один символ строки теперь выделяют 2-4 байта. Например, выделение 2 байт на один символ позволяет использовать алфавит, содержащий до 2^16 = 65536 символов.
-->


## Разновидности кодировок

- [Однобайтовые кодировки](#однобайтовые-кодировки)
- [Преимущества и недостатки однобайтовых кодировок](#преимущества-и-недостатки-однобайтовых-кодировок)


*Кодировки* можно *разделить* на *несколько типов* в *зависимости* от *затрачиваемой* ими *памяти* на *каждый символ*:  
1) *Фиксированный размер* для *всех символов*. *Кодировки* с *фиксированным размером подразделяются* на *однобайтовые* и *многобайтовые* (обычно, *2-4 байта*).
2) *Динамический размер символа*.

### Однобайтовые кодировки

*Размер представления* любого *символа* в самых *первых кодировках не превышал одного байта*. Наиболее яркими *примерами таких кодировок выступают* **семибитная кодировка ASCII** и **восьмибитная** (*однобайтовая*) **расширенная кодировка ASCII**. *Кодировка ASCII* является *стандартом* в *языке C* и часто *встречается* при работе с языком *C++*.

Используя *формулу* *количества информации* `i` в *одном символе* *алфавита* `A` *мощности* `n`: `i = log2(n)`, *приходим* к тому, что **`n = 2^i`**, откуда *следует*, что **семибитная кодировка** позволяет *закодировать* лишь *набор* из **`2^7 = 128`** *и менее* **символов**, а **однобайтовая кодировка** - *набор* из **`2^8 = 256`** *и менее* **символов**.

Поскольку *минимально адресуемая единица памяти* на *большинстве современных компьютеров* равна *одному байту*, для *двоичного представления символов ASCII* чаще всего используют *8-битные последовательности вместо 7-битных*. Как следствие, *кодировку ASCII* так же можно считать *однобайтовой*.

### Преимущества и недостатки однобайтовых кодировок

*Однобайтовая кодировка* *проста* в *реализации*, *закодированный* с её помощью *текст* имеет *наименьший размер* и этот *размер* можно довольно *просто рассчитать* (`1 символ = 1 байт`). 

*С другой стороны*, *однобайтовая кодировка* сильно *ограничена*, поскольку *такая кодировка* может *вместить* очень *мало языков*. 

*Когда это* может быть *важно*? Например, в *тексте* с *цитатами* из *оригинальных источников* на *иностранных языках*. Если *кодировка не поддерживает* некоторый *язык*, определённые *фрагменты текста* будут *представлять собой* нечто вроде `"Ñ†ÑƒÐ°Ñ‹Ð²"`, что *свидетельствует* о *неправильном декодировании* и что *невозможно разобрать*. *Можно*, конечно, *переключить кодировку*, но тогда уже *другая часть текста станет неразборчивой*. Более того, в *однобайтовую кодировку не вмещаются* даже *все символы китайского языка*.


Как *итог*, *однобайтовая кодировка идеально подходит* для *небольшой локальной системы*, в которой *представление всей информации не выходит* за *пределы ограниченного множества символов*. Когда *две и более* такие *системы* с *различными кодировками* начинают *взаимодействовать друг с другом*, что и *подразумевает* под собой *интернет*, *появляются проблемы*.


Очевидным *решением проблемы* стало *расширение кодировки ASCII*. Так *появилась* **расширенная кодировка ASCII** (англ. Extended ASCII), которая может *закодировать* до `256` *символов*, но и *её* вскоре оказалось *не достаточно* из-за *быстрого развития компьютерных сетей*. Это *привело* к *созданию* **стандарта Unicode**, который *поддерживает* почти *все существующие* в мире *символы*.


<!--
но это *не работает*, когда *две* и более *различные системы взаимодействуют* друг с другом, а именно *такое взаимодействие* и *подразумевает* под собой *интернет*. 
-->

## О кодировке ASCII

**Кодировка ASCII** (англ. American Standard Code for Information Interchange) была *разработана* для *управления средствами обмена информацией* (например, *телетайп*) ещё *до появления компьютера*.

Большинство *современных кодировок обратно совместимы* с *кодировкой ASCII*.

*Кодировка ASCII содержит*:
1) **Управляющие символы** (англ. Control characters). Например, `Backspace`, `Space`, `Delete`, `\n`.
2) **Печатные символы** (англ. Printable characters), *включающие* в себя *строчные* и *прописные буквы латинского алфавита*, *цифры*, *знаки препинания* и некоторые *другие наиболее распространённые символы* (`#`, `&`, `@`, `$`, `=` и *так далее*).

*Каждому символу кодировки ASCII ставится* в *соответствие целое число* (*код символа*) *от* `0` *до* `127`, которое может быть *представлено 7-битной строкой*. 

Тем не менее, поскольку *минимально адресуемая единица памяти* на *большинстве современных компьютеров* равна *одному байту*, для *двоичного представления символов ASCII* чаще всего используют *8-битные последовательности вместо 7-битных*. Для этого в *начало двоичной последовательности* *добавляется один нулевой бит*. Например, *вместо* `1000110` *записывают* `01000110`

*Ниже выборочно представлены символы* и *их коды* в *кодировке ASCII*:
Код символа | Двоичный код символа | Символ
:--: | :--: | :--:
0 | 00000000 | "\0" (Null)
8 | 00001000 | "\b" (Backspace, BS)
9 | 00001001 | "\t" (Horizontal Tab, HT)
10 | 00001010 | "\n" (Line Feed, LF)
13 | 00001101 | "\r" (Carriage Return, CR)
40 | 00100000 | Space
49 | 00110001 | "1"
50 | 00110010 | "2"
57 | 00111001 | "9"
65 | 01000001 | "A"
66 | 01000010 | "B"
90 | 01011010 | "Z"
97 | 01100001 | "a"
98 | 01100010 | "b"
122 | 01111010 | "z"
127 | 01111111 | Delete


## О стандарте Unicode
- [Универсальный набор символов (UCS)](#универсальный-набор-символов-ucs)
- [Форматы Unicode (UTF)](#форматы-unicode-utf)

### Универсальный набор символов (UCS)

В наши дни *самым* широко *используемым набором символов* является **универсальный набор символов** (англ. Universal character set, UCS), *являющийся частью стандарта Unicode*. *Этот набор символов содержит* почти все *зарегистрированные символы мира*, в том числе *символы всех существующих разговорных языков*.

*Благодаря* такой *широкой поддержке символов*, в *одном файле* с *кодировкой* стандарта *Unicode может использоваться сколько угодно языков*. В случае же *использования однобайтовой кодировки*, *пришлось* бы *переключать кодовые страницы* (*кодировки*), чтобы *распознать* (*декодировать*) отдельные *фрагменты текста*.

### Форматы Unicode (UTF)

*Стандарт Unicode предоставляет* целое **семейство кодировок UTF** (англ. Unicode transformation format), *каждая* из *которых* имеет *свой алгоритм кодирования символов* *универсального набора*.

*Символы Unicode представляются целыми неотрицательными числами*, которые обычно *записываются* в *шестнадцатиричной системе счисления* (16 с/с) для *компактности*.

*Основными



<!--
позволяющих *ограничить диапазон используемых символов набора* (*уменшить количество символов* в *наборе*) и таким образом *уменьшить затраты памяти* на *один символ*.
-->











# Метаданные

**Метаданными** (англ. metadata) называют *данные*, которые *несут* в себе *информацию* о *других данных*. Иначе говоря, *метаданные* - это *“данные о данных”*.

Например, *текстовый файл* может *иметь* следующие *метаданные*:
* *имя пользователя*, *создавшего* файл,
* *дата создания* файла,
* *дата последнего изменения* файла,
* *размер файла* (например, `73 KB`),
* *полная расшифровка формата* файла (например, `.pdf` - *Portable Document Format*),
* *количество символов* (строк) в файле*,
* *кодировка файла* (например, `UTF-8`),
* *возможность чтения* файла *и записи* в файл.

Например, *реляционная база данных хранит информацию* (*метаданные*) о том, *какие* *таблицы* в ней *имеются*, *какой размер* они *занимают* и *сколько строк содержится* в *каждой* из них.







;
