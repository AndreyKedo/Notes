# Оглавление
- [Информация и данные](#информация-и-данные)
- [Кодирование информации](#кодирование-информации)
- [Типы данных](#типы-данных)
- [Метаданные](#метаданные)


<!--
План: 
2) метод деления пополам
3) сжатие данных
4) logical unit
5) traversal
-->



# Информация и данные
- [Об информации и данных](#об-информации-и-данных)
- [Измерение информации](#измерение-информации)
- [Символ, алфавит и сообщение](#символ-алфавит-и-сообщение)
- [Количество информации (формула Хартли)](#количество-информации-формула-хартли)

## Об информации и данных

<!--
У *информации* существует *множество определений* в зависимости от *области применения* этого *термина*. Я *решил остановиться* на приведённом *ниже*.
-->

**Информация** (англ. information) - это *сведения* (*знания*) о некотором *объекте*, которые *не зависят от формы* их *представления*. Одна и та же *информация* может быть *представлена текстом, голосом, графически* и другими способами.

*Информация* отвечает на *вопрос*: “*Чем является* рассматриваемый *объект* и *какие* он имеет *свойства*?”.

<!--
Например, в *теории информации* *информацией* называют *упорядоченную последовательность символов* некоторого *алфавита*.
-->

**Данные** (англ. data) - это *форма представления информации* в *цифровом виде*. 

Фактически, *данные* представляют собой *последовательность символов*, а каждый *символ* имеет *цифровое представление* в виде *последовательности нулей и единиц*, которая *задаётся кодировкой символа*.

<!-- Пример предложения и его цифрового представления в некоторой кодировке -->

Над *данными* можно *производить операции* на *ЭВМ*, в том числе *хранить*, *считывать*, *изменять*, *передавать*, *анализировать*, *шифровать* и многие другие.

*Информация* - это *смысл*, который *содержится* в *данных*. По сути говоря, *информация* является *абстракцией*, а *данные* являются её *реализацией*, хотя достаточно *часто* понятия “*данные*” и “*информация*” используют как *синонимы*.

## Измерение информации
- [Бит и байт](#бит-и-байт)
- [Системы измерения информации](#системы-измерения-информации)


### Бит и байт

**Битом** (англ. **bi**nary digi**t**, bit) или **двоичным разрядом** называют *минимальную, неделимую более единицу измерения информации*.

*Один бит* может *хранить* в себе *одно* из *двух возможных логических значений*. Чаще всего в *качестве значений* используются `1` (*единица*) и `0` (*ноль*) из *двоичной системы счисления*, но так же *допустимы значения*: `истина` и `ложь`, `да` и `нет`, `включено` и `выключено` и другие.

**Двоичной строкой** (англ. bit string) называют *упорядоченную последовательность бит* (двоичных разрядов).

*Последовательность* из *8 бит* называют **байтом** (англ. byte) или **октетом** (англ. octet). Например, *байтом* является *последовательность* `10111001`.

Всего *существует* `256` *комбинаций битов* в *одном байте*. 
```
00000000
00000001
00000010
...
11111101
11111110
11111111
```
*Утверждение выше* можно легко *доказать комбинаторно*. *Байт* является *упорядоченным набором с повторениями* *длины* `8` с *элементами*, *выбранными* из *множества* `A = { 0, 1 }` (*мощность множества* `A` *равна* `2`), что соответствует *числу размещений с повторениями*: `A(8, 2) = 2^8 = 256`.

### Системы измерения информации

Существует *две системы измерения информации* в *битах* (*байтах*): **десятичная** (англ. decimal) и **двоичная**, **бинарная** (англ. binary).

*Десятичная система измерения* использует **десятичные префиксы** (англ. decimal prefixes, SI prefixes), *степени десятки*. Например, `kilo` - это `10^3`.

#### Десятичная система измерения информации (англ.)
Название | Обозначение | Значение
:--: | :--: | :--:
bit | b | 1 b
byte | B | 8 b = 1 B
kilobyte | KB | 10^3 B = 1000 B
megabyte | MB | 10^6 B = 1000 KB
gigabyte | GB | 10^9 B = 1000 MB
terabyte | TB | 10^12 B = 1000 GB
petabyte | PB | 10^15 B = 1000 TB

*Двоичная система измерения* использует **двоичные префиксы** (англ. binary prefixes, IEC prefixes), *степени двойки*. Например, `kibi` (`kilo binary`) - это `2^10`.

#### Двоичная система измерения информации (англ.)

Название | Обозначение | Значение
:--: | :--: | :--:
bit | b | 1 b
byte | B | 8 b = 1 B
kibibyte | KiB | 2^10 B = 1024 B
mebibyte | MiB | 2^20 B = 1024 KiB
gibibyte | GiB | 2^30 B = 1024 MiB
tebibyte | TiB | 2^40 B = 1024 GiB
pebibyte | PiB | 2^50 B = 1024 TiB

Для *бит* можно составить *аналогичные таблицы* с *теми же префиксами* (`kilobit`, `megabit` и так далее).

*Большинство оборудования* в *наши дни* использует *десятичную систему измерения информации*.

#### Исключение для измерения RAM
При *измерении оперативной памяти (RAM)* всегда *используется бинарная система измерения информации*, но при этом *названия* обычно берутся из *десятичной системы измерения*.

Таким образом, при *измерении оперативной памяти*: `1 GB = 1024 MB = 2^10 B`.

## Символ, алфавит и сообщение
- [Символ](#символ)
- [Алфавит](#алфавит)
- [Сообщение](#сообщение)

### Символ

**Символом** (англ. character) называют *условный знак*, которым *обозначают* одно или несколько *понятий*.

Например, *символом* `“+”` *обозначают начало номера телефона* и *оператор сложения*, *символ* `“z”` *представляет* собой *определённую букву английского алфавита* с её *уникальным звучанием*, а *символ* `“7”` *представляет* собой *определённую арабскую цифру*.

### Алфавит
*Рекомендуется* прочитать: [Множество](), [Мощность множества](), [Набор элементов]().

Напомним, что *множество* - это *неупорядоченный набор уникальных элементов*.

**Алфавитом** (англ. alphabet) называют *конечное непустое множество символов*. 

Пример *алфавита* `A`, *каждый символ* которого *обозначает арифметическую операцию*: `{ “+”, “-”, “•”, “÷” }`.

**Мощностью |A| алфавита `A`** называют *количество символов алфавита*.

Например, *алфавит* `A` из *примера выше* имеет *мощность* `|A| = 4`.

### Сообщение
Одним из самых распространённых *способов передачи информации* является *сообщение*.

**Сообщением** (англ. message) называют *упорядоченный набор символов* (*элементов*) *с повторениями*, *составленный* из *символов* некоторого *алфавита* `A`.

Под *определение выше* также подходят *понятия* “**текст**” и “**строка**”.

Примеры *сообщений*, *составленных* из *символов алфавита* `A = { a, e, p, r }`: `pear`, `are`, `rap`, `prrr`.

**Длиной сообщения** называют *количество символов* этого *сообщения*.

<!-- удалить раздел ниже? -->

#### Число сообщений фиксированной длины

<!--
*Рекомендуется* прочитать: [Размещения с повторениями (комбинаторика)]().
-->

**Число сообщений длины `k` из символов алфавита мощности `n`** *соответствует* **числу размещений с повторениями из `n` по `k`**, а именно **`A(n, k) = n^k`**.

Например, *число сообщений длины* `k = 3` из символов *алфавита мощности* `n = 4` *равно* `4^3 = 64`.

## Количество информации (формула Хартли)
- [Формула Хартли](#формула-хартли)


### Формула Хартли
*Рекомендуется* прочитать: [Логарифм]().

Пусть *имеется* некоторый **алфавит `A`** **мощности `n`**, *символы* которого *используются* при *составлении сообщений*. 

**Формулой Хартли** называют *формулу*, по которой *вычисляется* **количество информации `I` в** некотором **сообщении длины `k`**, *составленном* из *символов алфавита* `A` *мощности* `n`:  
**`I = k • log2(n)`**.

Тогда **количество информации `i` в одном символе** *алфавита* `A` вычисляется по *формуле*:  
**`i = I ÷ k = log2(n)`**.

В качестве *единиц измерения* для `I` и `i` используются **биты**.

Из *последней формулы* и *свойств логарифма* *следует*, что *мощность алфавита* `A`:  
**`n = 2^i`**.

Поскольку *бит* является *минимальной* (*неделимой*) величиной, *количество информации округляется* до *целого числа*. Причём, происходит *округление вверх* (*к большему целому*, *математическое округление*), чтобы *не было потерь информации*:  
**`i = ⌈ log2(n) ⌉`**, **`I = k • i`**.

Например, в *английским языке* `26` *букв*, то есть `52` *символа*, если *учитывать* и *строчные*, и *прописные буквы*. Возьмём *английский алфавит в качестве алфавита* `A`, тогда `|A| = n = 52` и *количество информации* в *одном символе алфавита* `A` *равно* `i = ⌈ log2(52) ⌉ = log2(64) = 6` *бит*. В таком случае, *любое сообщение длины* `k = 7`, *составленное* из *символов алфавита* `A`, *займёт* `I = k • i = 42` *бит*.


# Кодирование информации
- [Кодирование и декодирование](#кодирование-и-декодирование)
- [Набор символов и кодировка](#набор-символов-и-кодировка)
- [Код](#код)
- [Разновидности кодировок](#разновидности-кодировок)
- [О кодировке ASCII](#о-кодировке-ascii)
- [О стандарте Unicode](#о-стандарте-unicode)

## Кодирование и декодирование

**Кодированием** (англ. encoding) называют *процесс преобразования последовательности символов некоторого алфавита* `A` в *последовательность символов другого алфавита* `B`. 

**Декодированием** (англ. decoding) называют *процесс обратного преобразования* из *последовательности символов алфавита* `B` в *последовательность символов алфавита* `A`. 

Фактически, можно рассматривать *кодирование* как *преобразование информации* в *данные*, а *декодирование* как *преобразование данных* в *информацию*.

## Набор символов и кодировка

**Набором символов** (англ. character set, charset) называют некоторый *алфавит*, *символы* которого *могут* быть *использованы* во многих *других алфавитах*.

Например, некоторый *набор символов* может *содержать символы латинского алфавита* `{ ..., a, b, ..., z, ... }`, а *многие* из этих *символов используются* в *английском*, *немецком*, *французском*, *итальянском* и других алфавитах.

**Кодировкой символов** (англ. character encoding) или просто **кодировкой** (англ. encoding) называют *закодированный набор символов*, то есть такую *таблицу*, в которой *каждому символу* из *набора символов* *ставится* в *соответствие последовательность из одного или нескольких символов* некоторого *другого алфавита*. 

Обычно в *кодировке* *каждому символу* из *набора символов* ставится в *соответствие* некоторое *целое число* *аналогично* тому, как *каждому элементу массива* (*коллекции*) ставится в *соответствие* его *индекс*. Это *целое число* обычно *представляют* в *одной* из *трёх форм*:
1) В **десятичной системе счисления** (10 с/с), которая *привычна человеку*.
2) В **двоичной системе счисления** (2 с/с), чтобы показать, *как компьютер видит* данное *число*.
3) В **шестнадцатиричной системе счисления** (16 с/с) для *краткости записи длинных чисел*.

Например, в некотором *закодированном наборе символов* `A` *символу* `'#'` *может соответствовать десятичное число* `124` (в *2 с/с* - `01111100`, в *16 с/с* - `7c`), а *символу* `'$'` - *десятичное число* `255` (в *2 с/с* - `11111111`, в *16 с/с* - `ff`).

*Одному набору символов может соответствовать несколько кодировок*.


<!-- набор символов - коллекция символов -->

## Код
- [О коде](#о-коде)
- [Формальное определение кода и его расширения](#формальное-определение-кода-и-его-расширения)

### О коде

**Кодом** (англ. code) называют некоторый *алгоритм* (*последовательность действий*, *набор инструкций*), который *преобразует символ одного алфавита* `A` в *определённую последовательность символов* другого *алфавита* `B`. 

*Алфавит* `A` называют **исходным алфавитом** (англ. source alphabet), а *алфавит* `B` - **целевым алфавитом** (англ. target alphabet). 

*Если целевой алфавит* `B` *содержит лишь два символа* (*может закодировать лишь два состояния*), то *код* называют **двоичным** или **бинарным кодом** (англ. binary code). Чаще всего *целевой алфавит бинарного кода состоит* из *нуля и единицы*, то есть `B = { 0, 1 }`, что приводит нас к *использованию двоичной системы счисления* (англ. the binary number system).

**Кодом символа** будем называть *закодированное представление* этого *символа*.

### Формальное определение кода и его расширения

Пусть *имеются* *исходный* и *целевой алфавиты* `A` и `B`. Пусть также *имеются бесконечные множества* `A*` и `B*`, являющиеся *множествами всевозможных последовательностей символов алфавитов* `A` и `B` *соответствено*.

**Кодом** называют такую *функцию* (*отображение*) **`c: A → B*`**, которая *преобразует* (англ. map) *каждый символ алфавита* `A` в некоторую *последовательность символов алфавита* `B`. Такая *последовательность однозначно определяется заданным алгоритмом* (*набором символов*).

**Расширением кода `c`** (англ. extension) называют *функцию* **`c*: A* → B*`**, которая *преобразует любую последовательность символов алфавита* `A` в *определённую последовательность символов алфавита* `B`. 

<!--
`f(x) = y`, где `x` - *упорядоченный набор (кортеж) символов алфавита* `A`, а `y` - *упорядоченный набор (кортеж) символов алфавита* `B`. Тогда *пример выше* можно *записать* как `f('a') = 01000001`.
-->

#### Пример кода и его расширения

Пусть *имеется исходный алфавит* `A = { r, s, t }` и *целевой алфавит* `B = { 0, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9 }`.


По определению, *кодом* является *функция* **`c: A → B*`**, которая *принимает символ алфавита* `A` и *возвращает последовательность символов алфавита* `B` (*десятичное число*) по *заданному правилу*.


Пусть теперь *последовательность символов алфавита* `B` задаётся *кодировкой ANSII*.
Символ | Десятичный код символа
:--: | :--:
r | 162
s | 163
t | 164

В таком случае *справедливо следующее*
```
с('r') = 162,
c('s') = 163,
c('t') = 164,
```
что так же *можно записать*
```
c = { r ↦ 162, s ↦ 163, t ↦ 164 },
```
где `r, s, t ∈ A` и `162, 163, 163 ∈ B*`.

Рассмотрим теперь *расширение кода* в виде *функции* **`c*: A* → B*`**, которая *принимает последовательность символов исходного алфавита* `A` и *преобразует* её в *последовательность символов целевого алфавита* `B` по тому же *правилу*, что и *код* `c: A → B*` .

Например, пусть `ts, ssr ∈ A*`, тогда
```
c* = { ts ↦ 164162, ssr ↦ 16316312 },
```
где `164162, 16316312 ∈ B*`.

<!--
Из примера выше понятно, что для *декодирования* необходимо знать фиксированную длину кода символа, иначе разделить последовательность не получится
Например, можно установить длину = 3, тогда в случае двухзначного числа впереди добавится 0
-->


<!--

Со временем пришли к тому, что 256 символов не достаточно, поэтому в один символ строки теперь выделяют 2-4 байта. Например, выделение 2 байт на один символ позволяет использовать алфавит, содержащий до 2^16 = 65536 символов.
-->


## Разновидности кодировок

- [Однобайтовые кодировки](#однобайтовые-кодировки)
- [Преимущества и недостатки однобайтовых кодировок](#преимущества-и-недостатки-однобайтовых-кодировок)


*Кодировки* можно *разделить* на *несколько типов* в *зависимости* от *затрачиваемой* ими *памяти* на *каждый символ*:  
1) *Фиксированный размер* для *всех символов*. *Кодировки* с *фиксированным размером подразделяются* на *однобайтовые* и *многобайтовые* (обычно, *2-4 байта*).
2) *Динамический размер символа*.

### Однобайтовые кодировки

*Размер представления* любого *символа* в самых *первых кодировках не превышал одного байта*. Наиболее яркими *примерами таких кодировок выступают* **семибитная кодировка ASCII** и **восьмибитная** (*однобайтовая*) **расширенная кодировка ASCII**. *Кодировка ASCII* является *стандартом* в *языке C* и часто *встречается* при работе с языком *C++*.

Используя *формулу* *количества информации* `i` в *одном символе* *алфавита* `A` *мощности* `n`: `i = log2(n)`, *приходим* к тому, что **`n = 2^i`**, откуда *следует*, что **семибитная кодировка** позволяет *закодировать* лишь *набор* из **`2^7 = 128`** *и менее* **символов**, а **однобайтовая кодировка** - *набор* из **`2^8 = 256`** *и менее* **символов**.

Поскольку *минимально адресуемая единица памяти* на *большинстве современных компьютеров* равна *одному байту*, для *двоичного представления символов ASCII* чаще всего используют *8-битные последовательности вместо 7-битных*. Как следствие, *кодировку ASCII* так же можно считать *однобайтовой*.

### Преимущества и недостатки однобайтовых кодировок

*Однобайтовая кодировка* *проста* в *реализации*, *закодированный* с её помощью *текст* имеет *наименьший размер* и этот *размер* можно довольно *просто рассчитать* (`1 символ = 1 байт`). 

*С другой стороны*, *однобайтовая кодировка* сильно *ограничена*, поскольку *такая кодировка* может *вместить* очень *мало языков*. 

*Когда это* может быть *важно*? Например, в *тексте* с *цитатами* из *оригинальных источников* на *иностранных языках*. Если *кодировка не поддерживает* некоторый *язык*, определённые *фрагменты текста* будут *представлять собой* нечто вроде `"Ñ†ÑƒÐ°Ñ‹Ð²"`, что *свидетельствует* о *неправильном декодировании* и что *невозможно разобрать*. *Можно*, конечно, *переключить кодировку*, но тогда уже *другая часть текста станет неразборчивой*. Более того, в *однобайтовую кодировку не вмещаются* даже *все символы китайского языка*.


Как *итог*, *однобайтовая кодировка идеально подходит* для *небольшой локальной системы*, в которой *представление всей информации не выходит* за *пределы ограниченного множества символов*. Когда *две и более* такие *системы* с *различными кодировками* начинают *взаимодействовать друг с другом*, что и *подразумевает* под собой *интернет*, *появляются проблемы*.


Очевидным *решением проблемы* стало *расширение кодировки ASCII*. Так *появилась* **расширенная кодировка ASCII** (англ. Extended ASCII), которая может *закодировать* до `256` *символов*, но и *её* вскоре оказалось *не достаточно* из-за *быстрого развития компьютерных сетей*. Это *привело* к *созданию* **стандарта Unicode**, который *поддерживает* почти *все существующие* в мире *символы*.


<!--
но это *не работает*, когда *две* и более *различные системы взаимодействуют* друг с другом, а именно *такое взаимодействие* и *подразумевает* под собой *интернет*. 
-->

## О кодировке ASCII

**Кодировка ASCII** (англ. American Standard Code for Information Interchange) была *разработана* для *управления средствами обмена информацией* (например, *телетайп*) ещё *до появления компьютера*.

Большинство *современных кодировок обратно совместимы* с *кодировкой ASCII*.

*Кодировка ASCII содержит*:
1) **Управляющие символы** (англ. Control characters). Например, `Backspace`, `Space`, `Delete`, `\n`.
2) **Печатные символы** (англ. Printable characters), *включающие* в себя *строчные* и *прописные буквы латинского алфавита*, *цифры*, *знаки препинания* и некоторые *другие наиболее распространённые символы* (`#`, `&`, `@`, `$`, `=` и *так далее*).

*Каждому символу кодировки ASCII ставится* в *соответствие целое число* (*код символа*) *от* `0` *до* `127`, которое может быть *представлено 7-битной строкой*. 

Тем не менее, поскольку *минимально адресуемая единица памяти* на *большинстве современных компьютеров* равна *одному байту*, для *двоичного представления символов ASCII* чаще всего используют *8-битные последовательности вместо 7-битных*. Для этого в *начало двоичной последовательности* *добавляется один нулевой бит*. Например, *вместо* `1000110` *записывают* `01000110`

*Ниже выборочно представлены символы* и *их коды* в *кодировке ASCII*:
Код символа | Двоичный код символа | Символ
:--: | :--: | :--:
0 | 00000000 | "\0" (Null)
8 | 00001000 | "\b" (Backspace, BS)
9 | 00001001 | "\t" (Horizontal Tab, HT)
10 | 00001010 | "\n" (Line Feed, LF)
13 | 00001101 | "\r" (Carriage Return, CR)
40 | 00100000 | Space
49 | 00110001 | "1"
50 | 00110010 | "2"
57 | 00111001 | "9"
65 | 01000001 | "A"
66 | 01000010 | "B"
90 | 01011010 | "Z"
97 | 01100001 | "a"
98 | 01100010 | "b"
122 | 01111010 | "z"
127 | 01111111 | Delete


## О стандарте Unicode
- [Универсальный набор символов (UCS)](#универсальный-набор-символов-ucs)
- [Форматы Unicode (UTF)](#форматы-unicode-utf)

### Универсальный набор символов (UCS)

В наши дни *самым* широко *используемым набором символов* является **универсальный набор символов** (англ. Universal character set, UCS), *являющийся частью стандарта Unicode*. *Этот набор символов содержит* почти все *зарегистрированные символы мира*, в том числе *символы всех существующих разговорных языков*.

*Благодаря* такой *широкой поддержке символов*, в *одном файле* с *кодировкой* стандарта *Unicode может использоваться сколько угодно языков*. В случае же *использования однобайтовой кодировки*, *пришлось* бы *переключать кодовые страницы* (*кодировки*), чтобы *распознать* (*декодировать*) отдельные *фрагменты текста*.

### Форматы Unicode (UTF)

*Стандарт Unicode предоставляет* целое **семейство кодировок UTF** (англ. Unicode transformation format), *каждая* из *которых* имеет *свой алгоритм кодирования символов* *универсального набора*.

*Символы Unicode представляются целыми неотрицательными числами*, которые обычно *записываются* в *шестнадцатиричной системе счисления* (16 с/с) для *компактности*.

*Основными



<!--
позволяющих *ограничить диапазон используемых символов набора* (*уменшить количество символов* в *наборе*) и таким образом *уменьшить затраты памяти* на *один символ*.
-->



# Типы данных
- [О типе данных](#о-типе-данных)
- [Классификация типов данных](#классификация-типов-данных)
- [Логический тип](#логический-тип)
- [Строковый тип](#строковый-тип)
- [Символьный тип](#символьный-тип)
- [Целочисленный тип](#целочисленный-тип)

<!-- дополнительно: -->

## О типе данных
*Рекомендуется* прочитать: [Множество (дискретная математика)]().

**Типом данных** (англ. data type) или просто **типом** (англ. type) называют *множество* (*допустимых*) *значений* и *совокупность операций* над этими *значениями*.

*Тип данных* подсказывает *компьютеру*, как *следует обращаться* с этими *данными*.

## Классификация типов данных

*Большинство языков программирования поддерживает* **3 основных типа данных**:  
1) **Логический тип**. Содержит *логическое значение*: *истина* или *ложь*. Например, `true` или `false`, `1` или `0`, `да` или `нет`.  
2) **Строковый тип**. Содержит *текст*. Например, `'По ту сторону изгороди'`, `"письма незнакомке"`.  
3) **Числовой тип**. Содержит *число*. Например, `7`, `-3`, `3.14`.

*Эти типы данных* также *называют* **примитивными** или **базовыми типами**.

## Логический тип
- [О логическом типе](#о-логическом-типе)
- [Логические операции](#логические-операции)
- [Представление логического значения в памяти компьютера](#представление-логического-значения-в-памяти-компьютера)

### О логическом типе

В *основу логический типа данных* легла *математическая логика*.

**Логическим типом** (англ. Boolean) называют *тип данных*, который *принимает одно* из *двух логических значений*, называемых **истиной** (англ. true) и **ложью** (англ. false). *Эти значения* должны быть *противоположны друг другу*. Например, этими *значениями* могут быть: *да* и *нет*, *включено* и *выключено*, *присутствует* и *отсутствует* и так далее. 

*Удобнее* всего *представлять истину* в виде `1` (*логическая единица*), а *ложь* в виде `0` (*логический ноль*).

В *компьютере значение логического типа* можно *задать одним битом*.

### Логические операции
- [Унарные логические операции](#унарные-логические-операции)
- [Бинарные логические операции](#бинарные-логические-операции)
- [Тернарная условная операция](#тернарная-условная-операция)

*Операции над логическими значениями* называются **логическими операциями** (англ. Boolean algebraic operations).

*Ниже* будут *представлены лишь* те *логические операции*, которые *используются* в *большинстве языков программирования*. С *полным списком логических операций* можно *ознакомиться* в *соответствующем разделе математической логики*.

#### Унарные логические операции
* **Отрицание** (англ. negation). *Обозначение отрицания* `x`: `!x`, `NOT x`. *Свойства отрицания*: `!0 = 1`, `!1 = 0`, `!!x = x` (*закон двойного отрицания*). *Подробнее* об *отрицании* и его *свойствах*.

#### Бинарные логические операции
* **Логическое “И”** (англ. logical “AND”), **конъюнкция** (англ. conjunction). *Обозначение конъюнкции* `x` и `y`: `x && y`, `x AND y`. *Свойства конъюнкции*: `x && x = x`, `x && y = y && x`, `0 && 0 = 0`, `0 && 1 = 0`, `1 && 1 = 1`.  
* **Логическое “ИЛИ”** (англ. logical “OR”), **дизъюнкция** (англ. disjunction). *Обозначение дизъюнкции* `x` и `y`: `x || y`, `x OR y`. *Свойства дизъюнкции*: `x || x = x`, `x || y = y || x`, `0 || 0 = 0`, `0 || 1 = 1`, `1 || 1 = 1`.  
* **Эквиваленция** (англ. equivalence). *Обозначение эквиваленции* `x` и `y`: `x == y`, `x EQV y`. *Свойства эквиваленции*: `(x == x) = 1`, `(x == y) = (y == x)`, `(0 == 0) = 1`, `(1 == 1) = 1`, `(0 == 1) = 0`.  
* **Исключающее “ИЛИ”** (англ. exclusive “OR”), **отрицание эквиваленции** (англ. non-equivalence). *Обозначение эквиваленции* `x` и `y`: `x != y`, `x XOR y`, `x NEQV y`. *Свойства отрицания эквиваленции*: `(x != x) = 0`, `(x != y) = (y != x)`, `(0 != 0) = 0`, `(1 != 1) = 0`, `(0 != 1) = 1`.  

*Подробнее* о *конъюнкции*, *дизъюнкции*, *эквиваленции*, *исключающем “ИЛИ”* и их *свойствах* можно прочитать в [*математической логике*]().

<!-- сравнения -->

#### Тернарная условная операция

**Тернарной условной операцией** или просто **тернарной операцией** (англ. ternary operation) называют *операцию*, которая *принимает три операнда* (*логическое выражение* `x` и *два значения любого типа* `y`, `z`) и *производит* над ними *следующее*: если *логическое выражение истинно* (`x == 1`), то *возвращается значение* `y`, в *противном случае возвращается значение* `z`. Более *кратко*, “*если* `x`, *то* `y`, *иначе* `z`”.

*Обозначение тернарной операции* с *операндами* `x`, `y`, `z`:  
* `x ? y : z`,
* `if x then y else z`.

*Свойства тернарной операции* с *операндами* `x`, `y`, `z`:  
* Если `x == 1`, то `(x ? y : z) == y`.
* Если `x == 0`, то `(x ? y : z) == z`.

*Тернарная операция соответствует условной дизъюнкции* в *математической логике*.

### Представление логического значения в памяти компьютера

Для *представления логического значения* в *памяти компьютера достаточно одного бита*, поскольку *один бит может принять любые два возможных состояния*. В таком случае, `1` - это *истина*, `0` - это *ложь*.

*Реализовать* сам *бит* в *компьютере* достаточно *просто*: например, *подача напряжения* по *проводу* - это `1` (*истина*), *отсуствие напряжения* на *проводе* - `0` (*ложь*).



## Строковый тип
- [О строковом типе](#о-строковом-типе)
- [Обозначение строки](#обозначение-строки)
- [Операции над строками](#операции-над-строками)
- [Сравнение строк](#сравнение-строк)
- [Представление строк в памяти компьютера](#представление-строк-в-памяти-компьютера)
- [Размер строки](#размер-строки)


### О строковом типе

**Строковым типом** (англ. String) называют *тип данных*, *каждое значение* которого *представляет* собой *последовательность символов* некоторого *алфавита*. 

*Значение строкового типа* называют **строкой** (англ. string). 

<!-- *Строка* *представляет* собой *упорядоченный набор элементов с повторениями*. -->

*Количество символов строки* называют **длиной строки** (англ. string length).

### Обозначение строки

В *программном коде значения строкового типа* (*строки*) обычно *заключаются* в *кавычки*:
1) **Одинарные**: `'Мартин Иден'`, `'evergreen'`.
2) **Двойные**: `"Унесённые ветром"`, `"inhale"`.
3) **Косые**: \``Триумфальная арка`\`, \``Round Robin`\`.


### Операции над строками

*Над строками* можно *выполнять* следующие *операции*:
* *Вычисление длины* строки. Например, `("Notes").length --> 5`.
* *Получение символа* из строки по *индексу*. Например, `("Notes").find("t") --> 2`.
* *Конкатенация* (*сложение*) *строк*. Например, `"No" + "tes" --> "Notes"`.
* *[Сравнение](#сравнение-строк)* двух *строк*. Например, `"No" == "tes" --> false`.
* *Поиск подстроки* в строке. Например, `("Notes").includes("tes") --> true`.
* *Замена подстроки* в строке. Например, `("Notes").replace("es", "ion") --> "Notion"`.

В *большинстве языков программирования* *данные операции над строками встроены по умолчанию* или же их *можно подключить вместе* с *библиотекой*.

### Сравнение строк

В *программировании* символы `<`, `<=`, `==`, `>=`, `>` *представляют* собой *операторы* (не *отношения*, как в *теории множеств*), которые *являются частью операций сравнения*. 

*Операция сравнения* является *бинарной операцией*, которая *принимает два операнда любого типа* и *возвращает результат логического типа*, называемый *результатом сравнения*.

*Сравнение строк производится* в *лексикографическом порядке* (*посимвольно*), то есть *символы двух строк сравниваются попарно* по их *числовым кодам*. *Коды символов* *задаются кодировкой*. 

*Больше* считается *та строка*, чей *код символа оказался больше* на *некотором шаге алгоритма сравнения*.

Например, `"music" > "museum"`, поскольку *код символа* `'i'` *больше кода символа* `'e'`. Ниже представлена *таблица* для *наглядности сравнения сравнения*. *Коды символов* взяты из *кодировки ASCII*.

Индекс символа | Символ первой строки | Символ второй строки | Сравнение кодов символов
:--: | :-: | :--: | :-:
0 | `'m'` | `'m'` | `109` = `109`
1 | `'u'` | `'u'` | `117` = `117`
2 | `'s'` | `'s'` | `115` = `115`
3 | `'e'` | `'i'` | `101` < `105`
4 | `'u'` | `'c'` | 
5 | `'m'` |   | 

Аналогично, `"музыка" > "музей"` (`'ы' > 'е'`), `”волк < "тигр"` (`'в' < 'т'`), `"близнец" = "близнец"`.

#### Алгоритм сравнения строк

Пусть *сравниваются две строки* `a` и `b`.

Если *хотя бы одна* из *строк* `a` и `b` *пуста*, то *результат сравнения* можно *определить сразу*:
1) Если *обе строки пусты*, то `a = b`.
2) Если *одна строка пуста*, то *больше непустая строка*.

*Далее считаем*, что `a` и `b` *не пусты*.

Сначала берётся *код первого символа строки* `a`, *код первого символа строки* `b` и *осуществляется их сравнение*:
  * Если *код символа строки* `a` *больше кода символа строки* `b`, то `a > b`. 
  * Если *код символа строки* `a` *меньше кода символа строки* `b`, то `a < b`.
  * Если *коды символов совпали*, то *выполнение алгоритма продолжается*.
  * Если *достигнут конец* хотя бы *одной строки*, то *сравнение заканчивается*:
    * Если *все предыдущие символы совпали* и *длины строк* `a` и `b` *совпадают*, то `a = b`.
    * Если *все предыдущие символы совпали* и *длины строк* `a` и `b` *не совпадают*, то *больше та строка*, в *которой больше символов*.
  * *Берётся код следующего символа* из *каждой строки* и *выполнение алгоритма начинается сначала*.

### Представление строк в памяти компьютера

<!-- перенести в programming -->

Существует *два способа представить строку* в *памяти компьютера*:  
* *[Массив символов](#массив-символов)*.
* *[Нуль-терминированная строка](#нуль-терминированная-строка)*.

#### Массив символов

**Массивом символов** называют *способ представления* **строки длины `n`** в *памяти компьютера* как **массива** из **`n + 1` элементов**, в котором *символы строки* занимают *индексы массива от* `1` *до* `n`, а *элемент* с *нулевым индексом хранит длину строки* (*количество символов*) или *размер строки* (*количество байт*).

<!--
Например, можно представить слово `Notes` как \u004e\u006f\u0074\u0065\u0073
 Символ (код символа)
-->

*Представление строки* `"Notes"` *массивом символов*:
Индексы элементов массива | 0 (длина строки) | 1 | 2 | 3 | 4 | 5
:--: | :--: | :--: | :--: | :--: | :--: | :--:
Элементы массива | 5 | `'N'` | `'o'` | `'t'` | `'e'` | `'s'`

<!--
Элементы массива, строка `"море"` | 4 | `'м'` | `'о'` | `'р'` | `'е'` | -
-->

#### Нуль-терминированная строка

**Нуль-терминированной строкой** называют *способ представления строки* в *памяти компьютера*, при котором *строка представляется непрерывной последовательностью байт*, которая *оканчивается специальным* *нуль-символом* (*признаком конца строки*, *завершающим байтом*). 

**Нуль-символ** *представляет* собой *любой символ алфавита*, который был *выбран* в *качестве признака конца строки*. Например, в *алфавите ANSI* *нуль-символом выступает символ* `NUL`, имеющий *код* `0`.

Если *выделяется один байт на один символ алфавита*, то *нуль-терминированная строка* из **`n` символов** *занимает* **`n + 1` байт**.

*Нуль-терминированные строки* являются *стандартом* в *языке C*, поэтому их *иногда называют* **C-строками**.

### Размер строки

**Размер строки** зависит от *длины* этой *строки* (*количества символов* в ней), от *размера одного символа* (*размер задаётся кодировкой*) и от *способа представления строки* в *памяти компьютера* (например, если *строка* *нуль-терминированная*, то её общий *размер увеличивается на один байт*).

Например, при *использовании однобайтовой кодировки ASCII* *нуль-терминировання строка* `"Notes"` *займёт* `5 + 1 = 6 байт`. Кстати говоря, *столько же* вышло бы при *использовании* *кодировки UTF-8*, поскольку она *обратно совместима* с *кодировкой ASCII*


Например, при *использовании кодировки UTF-8* *нуль-терминированная строка* `"Роза"` *займёт* `4 • 2 + 1 = 9 байт`, поскольку *каждый символ кириллицы* в *кодировке UTF-8 представляется двумя байтами*.

*Представление нуль-терминированной строки* `"Notes"` *последовательностью байт*, *записанных* в *шестнадцатиричной системе счисления*:
```
0x4e 0x6f 0x74 0x65 0x73 0x00
N    o    t    e    s    NUL
```

## Символьный тип

**Символьным типом** (англ. Char) называют *тип данных*, *каждое значение* которого *представляет* собой *один* **символ** (англ. character) некоторого *алфавита* (некоторой *кодировки*).

Например, *значениями символьного типа* являются: `'%'`, `'g'`, `'/'`.

*Значение символьного типа занимает столько памяти*, *сколько* должен занимать *символ соответствующей кодировки* . Например, для *ANSII* это всегда `1 байт`, для *кодировок семейства UTF размер варьируется от* `1` *до* `4 байт`.

Например, в *языке C нет строкового типа*, поэтому *строки рассматриваются* в нём как *массивы символов* (`char[]` или `char*`).

## Целочисленный тип
- [О целочисленном типе](#о-целочисленном-типе)
- [Беззнаковые целые числа и целые числа со знаком](беззнаковые-целые-числа-и-целые-числа-со-знаком)
- [Представление целого числа в памяти компьютера](#представление-целого-числа-в-памяти-компьютера)
- [Типы целочисленных значений](#типы-целочисленных-значений)
- [Арифметические операции над целыми числами](#арифметические-операции-над-целыми-числами)
- [Битовые операции над целыми числами](#битовые-операции-над-целыми-числами)

### О целочисленном типе

**Целочисленным типом** (англ. Integer, Integral data type, Int) называют *тип данных*, *каждое значение* которого *представляет* некоторое *число* из *множества целых чисел* `Z`.

*Значение целочисленного типа* называют **целочисленным значением** или **целым числом**.

Например, *целочисленным значениями* являются: `17`, `-3`, `0`.

### Беззнаковые целые числа и целые числа со знаком

В *программировании целые числа подразделяют* на *беззнаковые целые числа* и *целые числа со знаком*

**Беззнаковое целое число** (англ. unsigned integer) *представляет* только *неотрицательные целые числа*:  
`0, 1, 2, 3, ...`.

**Целым числом со знаком** (англ. signed integer) *представляюет любое целое число* (*положительное*, *отрицательное* или *ноль*). Например, `-37`, `8`, `0`.


### Представление целого числа в памяти компьютера

*Математическое множество целых чисел* `Z`, вообще говоря, *бесконечно*. При этом *ресурсы компьютера ограничены*. *Компьютер не способен хранить* что-либо *бесконечное*, поэтому *представление множества целых чисел* в *компьютере ограничивается сверху* и *снизу максимальным* и *минимальным значениями*. 

*Целое число представляется* в *памяти компьютера* *последовательностью байт* (*бит*).

### Кодирование целых чисел
- [Кодирование беззнаковых целых чисел](#кодирование-беззнаковых-целых-чисел)
- [Кодирование целых чисел со знаком](#кодирование-целых-чисел-со-знаком)

Для *кодирования целого числа кодировка не нужна*: *достаточно* применить *алгоритм перевода чисел из десятичной системы счисления* в *двоичную*.

#### Кодирование беззнаковых целых чисел

Всего *существует* `m = 2^n` *n-битных двоичных последовательностей*, что *можно* легко *доказать комбинаторно*, используя *размещения с повторениями*. Этими `m` *двоичными последовательностями* можно *представить беззнаковые целые числа* от `0` до `m - 1`. 

*Число* `0` называют **минимальным беззнаковым целым числом** (*нижняя граница множества*), а *число* `m - 1 = 2^n - 1` называют **максимальным беззнаковым целым числом** (*верхняя граница множества*).

Например, *одним байтом* (`8 бит`) можно *представить беззнаковые целые числа от* `0` *до* `2^8 - 1 = 255`. 

В *таблице ниже беззнаковые целые числа закодированы одним байтом*.

Беззнаковое целое число | Двоичный код числа
:--: | :--:
0 | 00000000
1 | 00000001
2 | 00000010
3 | 00000011
127 | 01111111
128 | 10000000
254 | 11111110
255 | 11111111

#### Кодирование целых чисел со знаком

На *кодирование знака числа выделяется один бит* - *старший бит* (*первый бит последовательности*):  
* `0` - *знак* `+`, *соответствует положительному числу*
* `1` - *знак* `-`, *соответствует отрицательному числу*.


Всего *существует* `m = 2^n` *n-битных двоичных последовательностей*. Этими `m` *двоичными последовательностями* можно *представить целые числа со знаком* от `- (m / 2)` до `(m / 2) - 1`. 

*Число* `- (m / 2) = - 2^(n - 1)` называют **минимальным целым числом со знаком** (*нижняя граница множества*), а *число* `m - 1 = 2^(n - 1) - 1` называют **максимальным целым числом со знаком** (*верхняя граница множества*).

Например, при *представлении целого числа со знаком одним байтом*: *выделяется* `1 бит` на *знак* и *остаётся* `7 бит` на само *число*. Таким образом, *одним байтом* могут быть *представлены целые числа со знаком от* `0` *до* `127`.

В *таблице ниже целые числа со знаком закодированы одним байтом*.

Целое число со знаком | Двоичный код числа
:--: | :--:
0 | 00000000
1 | 00000001
-1 | 10000001
2 | 00000010
-2 | 10000010
127 | 01111111
-127 | 11111111


<!--

### Перевод чисел 

Десятичная с/с | Двоичная с/с
:--: | :--:
0 | 00000000
1 | 00000001
2 | 00000010
3 | 00000011
4 | 00000100
7 | 00000111
8 | 00001000
15 | 00001111
16 | 00010000
31 | 00011111
32 | 00100000
63 | 00111111
64 | 01000000
127 | 01111111
128 | 10000000
255 | 11111111

-->

### Типы целочисленных значений

В зависимости от *количества байт*, используемых на *представление целого числа*, выделяют *несколько типов целочисленных значений*. 

Подтип | Размер  | Диапазон допустимых значений
:--: | :--: | :--:
**Ниббл** (англ. **nibble**), **полуоктет** (англ. **semioctet**) | `половина байта` (`4 бит`) | *Беззнаковый*: *от* `0` *до* `2^4 - 1 = 15`, *знаковый*: *от* `-2^3 = -8` до `2^3 - 1 = 7`
**Байт** (англ. **byte**),  **октет** (англ. **octet**) | `1 байт` (`8 бит`) | *Беззнаковый*: *от* `0` *до* `2^8 - 1 = 255`, *знаковый*: *от* `-2^7 = -128` до `2^7 - 1 = 127`
**Полуслово** (англ. **halfword**), (англ. **short**) | `2 байта` (`16 бит`) | *Беззнаковый*: *от* `0` *до* `2^16 - 1 = 65535`, *знаковый*: *от* `-2^15 = -32768` до `2^15 - 1 = 32767`
**Слово** (англ. **word**),  (англ. **long**) | `4 байта` (`32 бит`) | *Беззнаковый*: *от* `0` *до* `2^32 - 1`, *знаковый*: *от* `-2^31` до `2^31 - 1`
**Длинное слово** (англ. **longword**),  **двойное слово** (англ. **doubleword**), (англ. **quadword**, **qword**) | `8 байт` (`64 бит`) | *Беззнаковый*: *от* `0` *до* `2^64 - 1`, *знаковый*: *от* `-2^63` до `2^63 - 1`



### Арифметические операции над целыми числами


#### Унарные арифметические операции
* **Инкремент** (англ. **inc**rement) - *увеличение значения на единицу*. *Обозначение инкремента числа* `x`: `x++` или `++x`. Например, `++6 = 7`.
* **Декремент** (англ. **dec**rement) - *увеличение значения на единицу*. *Обозначение инкремента числа* `x`: `x--` или `--x`. Например, `--4 = 3`.
* **Модуль** (англ. **abs**olute value) - *значение числа без* учёта *знака*. *Обозначение модуля числа* `x`: `|x|` (мат.), `abs(x)` (прог.). Например, `|-5| = 5`.
* **Отрицание** (англ. **neg**ation) - *смена знака числа* на *противоположный*. *Обозначение отрицания числа* `x`: `-x`, `neg(x)` (прог.). Например, *отрицание числа* `8`: `-8`, *отрицание числа* `-2`: `2`.
* **Взятие квадратного корня** (англ. **sq**uare **r**oo**t**). *Обозначение квадратного корня числа* `x`: `√x` (мат.), `sqrt(x)` (прог.). Например, `√49 = 7`, то есть `7 • 7 = 49`.
* **Натуральный логарифм** (англ. **log**arithm). *Обозначение натурального логарифма числа* `x`: `ln(x)`, `log(x)` (прог.). Например, `ln(7) = 1.94591`, то есть `e^(1.94591) = 7`.

#### Бинарные арифметические операции
* **Сложение** (англ. **add**ition). *Обозначение сложения чисел* `x` и `y`: `x + y`. Например, `7 + 6 = 13`.
* **Разность** (англ. **sub**traction). ). *Обозначение вычитания числа* `y` из *числа* `x`: `x - y`. Например, `7 - 6 = 1`.
* **Умножение** (англ. **mul**tiplication). *Обозначение умножения чисел* `x` и `y`: `x • y` (мат.), `x * y` (прог.). Например, `6 • 7 = 42`.
* **Деление** (англ. **div**ision). *Обозначение деления числа* `x` на *число* `y`: `x ÷ y` (мат.), `x / y` (прог.). Например, `42 ÷ 6 = 7`.
* **Возведение в степень** (англ. **pow**er). *Обозначение возведения числа* `x` в *степень* `y`: `x ^ y` (мат.), `x ** y` (прог.), `pow(x, y)` (прог.). Например, `2 ^ 4 = 16`.

### Битовые операции над целыми числами
- [О битовых операциях](#о-битовых-операциях)
- [Различие битовых и логических операций](#различие-битовых-и-логических-операций)
- [Битовые сдвиги](#битовые-сдвиги)

#### О битовых операциях

**Битовые операции** *предназначены* для работы с *последовательностями бит*.

Поскольку *целое число* можно *представить* в *двоичной системе счисления* (как *двоичное число*), к нему *применимы битовые операции*.

*Первый бит двоичной последовательности* называют **старшим битом**, *последний бит* - **младшим битом**. 

*Старший* и *младший биты* называют **крайними битами**, *оставшиеся биты последовательности* называют **средними битами**.

#### Различие битовых и логических операций

**Логические операции** *принимают операнды логического типа* (или *операнды приводятся* к *данному типу*) и *возвращают результат логического типа*.

В *большинстве языков программирования логические значения представлены значениями* `true` и `false` (иногда `1` и `0`).

**Битовые операции** *принимают* в качестве *операндов последовательности бит* (или *операнды приводятся* к *последовательностям бит*) и *возвращают последовательность бит*.

<!--
**Битовые операции** *предназначены* для работы с *последовательностями бит*. 
-->

Например, такими *двоичными последовательностями* являются `01110111`, `1110` и другие.


#### Битовые сдвиги

**Битовым сдвигом** называют *изменение позиции бит* в *двоичной последовательности*.

Различают *несколько видов сдвигов*.
##### Сдвиги по *направлению движения бит*
* **Битовый сдвиг влево** (*сдвиг* от *младшего* к *старшему*) подразумевает *смещение* (*перестановку*) *кадого* из *значений средних бит* на *1 бит влево*.
* **Битовый сдвиг вправо** (*сдвиг* от *старшего* к *младшему*) подразумевает *смещение* *кадого* из *значений средних бит* на *1 бит вправо*.

##### Сдвиги по *поведению крайних бит*
* При **логическом сдвиге** *один* из *крайних битов выпадает* из *последовательности*, *другой принимает нулевое значение*. 
```
>> 10001111 = 01000111
>> 01000111 = 00100011

<< 10001111 = 00011110
<< 00011110 = 00111100
```
* При **арифметическом сдвиге** *сохраняется знак числа*, который *хранится* в *старшем бите*, а значит *сохраняется значение старшего бита*. В *остальном арифметический сдвиг аналогичен логическому*.
```
>> 10001111 = 11000111
>> 11000111 = 11100011

>> 01000111 = 00100011

<< 10001111 = 00011110
<< 00011110 = 00111100
```
* При **циклическом сдвиге** *значение одного крайнего бита переносится* в *другой крайний бит*, то есть *производится [круговая перестановка]()*.
```
>> 10001111 = 11000111
>> 11000111 = 11100011
>> 11100011 = 11110001

<< 10001111 = 00011111
<< 00011111 = 00111110
<< 00111110 = 01111100
```

### Сравнение целых чисел
Рекомендуется прочитать: [Операция](), [Отношение]().

В *отличие математики*, где *сравнение представляет* собой *отношение*, в *программировании сравнение* является *операцией*, то есть оно *обязательно возвращает результат* (обычно *логического типа*).











<!--
# Системы счисления

## Двоичная система счисления

-->






# Метаданные

**Метаданными** (англ. metadata) называют *данные*, которые *несут* в себе *информацию* о *других данных*. Иначе говоря, *метаданные* - это *“данные о данных”*.

Например, *текстовый файл* может *иметь* следующие *метаданные*:
* *имя пользователя*, *создавшего* файл,
* *дата создания* файла,
* *дата последнего изменения* файла,
* *размер файла* (например, `73 KB`),
* *полная расшифровка формата* файла (например, `.pdf` - *Portable Document Format*),
* *количество символов* (строк) в файле*,
* *кодировка файла* (например, `UTF-8`),
* *возможность чтения* файла *и записи* в файл.

Например, *реляционная база данных хранит информацию* (*метаданные*) о том, *какие* *таблицы* в ней *имеются*, *какой размер* они *занимают* и *сколько строк содержится* в *каждой* из них.







;
