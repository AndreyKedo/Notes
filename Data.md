# Оглавление
- [Информация и данные](#информация-и-данные)
- [Кодирование информации](#кодирование-информации)
- [Типы данных](#типы-данных)
- [Структуры данных](#структуры-данных)
- [Метаданные](#метаданные)


<!--
План: 
1) количество информации в utf
2) метод деления пополам
3) сжатие данных
4) logical unit
5) traversal
-->


# Информация и данные
- [Об информации и данных](#об-информации-и-данных)
- [Измерение информации](#измерение-информации)
- [Символ, алфавит и сообщение](#символ-алфавит-и-сообщение)
- [Количество информации (формула Хартли)](#количество-информации-формула-хартли)


## Об информации и данных

<!--
У *информации* существует *множество определений* в зависимости от *области применения* этого *термина*. Я *решил остановиться* на приведённом *ниже*.
-->

**Информация** (англ. information) - это *сведения* (*знания*) о некотором *объекте*, которые *не зависят от формы* их *представления*. Одна и та же *информация* может быть *представлена текстом, голосом, графически* и другими способами.

*Информация* отвечает на *вопрос*: “*Чем является* рассматриваемый *объект* и *какие* он имеет *свойства*?”.

<!--
Например, в *теории информации* *информацией* называют *упорядоченную последовательность символов* некоторого *алфавита*.
-->

**Данные** (англ. data) - это *форма представления информации* в *цифровом виде*. 

Фактически, *данные* представляют собой *последовательность символов*, а каждый *символ* имеет *цифровое представление* в виде *последовательности нулей и единиц*, которая *задаётся кодировкой символа*.

<!-- Пример предложения и его цифрового представления в некоторой кодировке -->

Над *данными* можно *производить операции* на *ЭВМ*, в том числе *хранить*, *считывать*, *изменять*, *передавать*, *анализировать*, *шифровать* и многие другие.

*Информация* - это *смысл*, который *содержится* в *данных*. По сути говоря, *информация* является *абстракцией*, а *данные* являются её *реализацией*, хотя достаточно *часто* понятия “*данные*” и “*информация*” используют как *синонимы*.

## Измерение информации
- [Бит и байт](#бит-и-байт)
- [Системы измерения информации](#системы-измерения-информации)


### Бит и байт

**Битом** (англ. **bi**nary digi**t**, bit) или **двоичным разрядом** называют *минимальную, неделимую более единицу измерения информации*.

*Один бит* может *хранить* в себе *одно* из *двух возможных логических значений*. Чаще всего в *качестве значений* используются `1` (*единица*) и `0` (*ноль*) из *двоичной системы счисления*, но так же *допустимы значения*: `истина` и `ложь`, `да` и `нет`, `включено` и `выключено` и другие.

**Двоичной строкой** (англ. bit string) называют *упорядоченную последовательность бит* (двоичных разрядов).

*Последовательность* из *8 бит* называют **байтом** (англ. byte) или **октетом** (англ. octet). Например, *байтом* является *последовательность* `10111001`.

Всего *существует* `256` *комбинаций битов* в *одном байте*. 
```
00000000
00000001
00000010
...
11111101
11111110
11111111
```
*Утверждение выше* можно легко *доказать комбинаторно*. *Байт* является *упорядоченным набором с повторениями* *длины* `8` с *элементами*, *выбранными* из *множества* `A = { 0, 1 }` (*мощность множества* `A` *равна* `2`), что соответствует *числу размещений с повторениями*: `A(8, 2) = 2^8 = 256`.

### Системы измерения информации

Существует *две системы измерения информации* в *битах* (*байтах*): **десятичная** (англ. decimal) и **двоичная**, **бинарная** (англ. binary).

*Десятичная система измерения* использует **десятичные префиксы** (англ. decimal prefixes, SI prefixes), *степени десятки*. Например, `kilo` - это `10^3`.

#### Десятичная система измерения информации (англ.)
Название | Обозначение | Значение
:--: | :--: | :--:
bit | b | 1 b
byte | B | 8 b = 1 B
kilobyte | KB | 10^3 B = 1000 B
megabyte | MB | 10^6 B = 1000 KB
gigabyte | GB | 10^9 B = 1000 MB
terabyte | TB | 10^12 B = 1000 GB
petabyte | PB | 10^15 B = 1000 TB

*Двоичная система измерения* использует **двоичные префиксы** (англ. binary prefixes, IEC prefixes), *степени двойки*. Например, `kibi` (`kilo binary`) - это `2^10`.

#### Двоичная система измерения информации (англ.)

Название | Обозначение | Значение
:--: | :--: | :--:
bit | b | 1 b
byte | B | 8 b = 1 B
kibibyte | KiB | 2^10 B = 1024 B
mebibyte | MiB | 2^20 B = 1024 KiB
gibibyte | GiB | 2^30 B = 1024 MiB
tebibyte | TiB | 2^40 B = 1024 GiB
pebibyte | PiB | 2^50 B = 1024 TiB

Для *бит* можно составить *аналогичные таблицы* с *теми же префиксами* (`kilobit`, `megabit` и так далее).

*Большинство оборудования* в *наши дни* использует *десятичную систему измерения информации*.

#### Исключение для измерения RAM
При *измерении оперативной памяти (RAM)* всегда *используется бинарная система измерения информации*, но при этом *названия* обычно берутся из *десятичной системы измерения*.

Таким образом, при *измерении оперативной памяти*: `1 GB = 1024 MB = 2^10 B`.

## Символ, алфавит и сообщение
- [Символ](#символ)
- [Алфавит](#алфавит)
- [Сообщение](#сообщение)

### Символ

**Символом** (англ. character) называют *условный знак*, которым *обозначают* одно или несколько *понятий*.

Например, *символом* `“+”` *обозначают начало номера телефона* и *оператор сложения*, *символ* `“z”` *представляет* собой *определённую букву английского алфавита* с её *уникальным звучанием*, а *символ* `“7”` *представляет* собой *определённую арабскую цифру*.

### Алфавит
*Рекомендуется* прочитать: [Множество](), [Мощность множества](), [Набор элементов]().

Напомним, что *множество* - это *неупорядоченный набор уникальных элементов*.

**Алфавитом** (англ. alphabet) называют *конечное непустое множество символов*. 

Пример *алфавита* `A`, *каждый символ* которого *обозначает арифметическую операцию*: `{ “+”, “-”, “•”, “÷” }`.

**Мощностью |A| алфавита `A`** называют *количество символов алфавита*.

Например, *алфавит* `A` из *примера выше* имеет *мощность* `|A| = 4`.

### Сообщение
Одним из самых распространённых *способов передачи информации* является *сообщение*.

**Сообщением** (англ. message) называют *упорядоченный набор символов* (*элементов*) *с повторениями*, *составленный* из *символов* некоторого *алфавита* `A`.

Под *определение выше* также подходят *понятия* “**текст**” и “**строка**”.

Примеры *сообщений*, *составленных* из *символов алфавита* `A = { a, e, p, r }`: `pear`, `are`, `rap`, `prrr`.

**Длиной сообщения** называют *количество символов* этого *сообщения*.

<!-- удалить раздел ниже? -->

#### Число сообщений фиксированной длины

<!--
*Рекомендуется* прочитать: [Размещения с повторениями (комбинаторика)]().
-->

**Число сообщений длины `k` из символов алфавита мощности `n`** *соответствует* **числу размещений с повторениями из `n` по `k`**, а именно **`A(n, k) = n^k`**.

Например, *число сообщений длины* `k = 3` из символов *алфавита мощности* `n = 4` *равно* `4^3 = 64`.

## Количество информации (формула Хартли)
- [Формула Хартли](#формула-хартли)


### Формула Хартли
*Рекомендуется* прочитать: [Логарифм]().

Пусть *имеется* некоторый **алфавит `A`** **мощности `n`**, *символы* которого *используются* при *составлении сообщений*. 

**Формулой Хартли** называют *формулу*, по которой *вычисляется* **количество информации `I` в** некотором **сообщении длины `k`**, *составленном* из *символов алфавита* `A` *мощности* `n`:  
**`I = k • log2(n)`**.

Тогда **количество информации `i` в одном символе** *алфавита* `A` вычисляется по *формуле*:  
**`i = I ÷ k = log2(n)`**.

В качестве *единиц измерения* для `I` и `i` используются **биты**.

Из *последней формулы* и *свойств логарифма* *следует*, что *мощность алфавита* `A`:  
**`n = 2^i`**.

Поскольку *бит* является *минимальной* (*неделимой*) величиной, *количество информации округляется* до *целого числа*. Причём, происходит *округление вверх* (*к большему целому*, *математическое округление*), чтобы *не было потерь информации*:  
**`i = ⌈ log2(n) ⌉`**, **`I = k • i`**.

Например, в *английским языке* `26` *букв*, то есть `52` *символа*, если *учитывать* и *строчные*, и *прописные буквы*. Возьмём *английский алфавит в качестве алфавита* `A`, тогда `|A| = n = 52` и *количество информации* в *одном символе алфавита* `A` *равно* `i = ⌈ log2(52) ⌉ = log2(64) = 6` *бит*. В таком случае, *любое сообщение длины* `k = 7`, *составленное* из *символов алфавита* `A`, *займёт* `I = k • i = 42` *бит*.


# Кодирование информации
- [Кодирование и декодирование](#кодирование-и-декодирование)
- [Набор символов и кодировка](#набор-символов-и-кодировка)
- [Код](#код)
- [Разновидности кодировок](#разновидности-кодировок)
- [О кодировке ASCII](#о-кодировке-ascii)
- [О стандарте Unicode](#о-стандарте-unicode)

## Кодирование и декодирование

**Кодированием** (англ. encoding) называют *процесс преобразования последовательности символов некоторого алфавита* `A` в *последовательность символов другого алфавита* `B`. 

**Декодированием** (англ. decoding) называют *процесс обратного преобразования* из *последовательности символов алфавита* `B` в *последовательность символов алфавита* `A`. 

Фактически, можно рассматривать *кодирование* как *преобразование информации* в *данные*, а *декодирование* как *преобразование данных* в *информацию*.

## Набор символов и кодировка

**Набором символов** (англ. character set, charset) называют некоторый *алфавит*, *символы* которого *могут* быть *использованы* во многих *других алфавитах*.

Например, некоторый *набор символов* может *содержать символы латинского алфавита* `{ ..., a, b, ..., z, ... }`, а *многие* из этих *символов используются* в *английском*, *немецком*, *французском*, *итальянском* и других алфавитах.

**Кодировкой символов** (англ. character encoding) или просто **кодировкой** (англ. encoding) называют *закодированный набор символов*, то есть такую *таблицу*, в которой *каждому символу* из *набора символов* *ставится* в *соответствие последовательность из одного или нескольких символов* некоторого *другого алфавита*. 

Обычно в *кодировке* *каждому символу* из *набора символов* ставится в *соответствие* некоторое *целое число* *аналогично* тому, как *каждому элементу массива* (*коллекции*) ставится в *соответствие* его *индекс*. Это *целое число* обычно *представляют* в *одной* из *трёх форм*:
1) В **десятичной системе счисления** (10 с/с), которая *привычна человеку*.
2) В **двоичной системе счисления** (2 с/с), чтобы показать, *как компьютер видит* данное *число*.
3) В **шестнадцатиричной системе счисления** (16 с/с) для *краткости записи длинных чисел*.

Например, в некотором *закодированном наборе символов* `A` *символу* `'#'` *может соответствовать десятичное число* `124` (в *2 с/с* - `01111100`, в *16 с/с* - `7c`), а *символу* `'$'` - *десятичное число* `255` (в *2 с/с* - `11111111`, в *16 с/с* - `ff`).

*Одному набору символов может соответствовать несколько кодировок*.


<!-- набор символов - коллекция символов -->

## Код
- [О коде](#о-коде)
- [Формальное определение кода и его расширения](#формальное-определение-кода-и-его-расширения)

### О коде

**Кодом** (англ. code) называют некоторый *алгоритм* (*последовательность действий*, *набор инструкций*), который *преобразует символ одного алфавита* `A` в *определённую последовательность символов* другого *алфавита* `B`. 

*Алфавит* `A` называют **исходным алфавитом** (англ. source alphabet), а *алфавит* `B` - **целевым алфавитом** (англ. target alphabet). 

*Если целевой алфавит* `B` *содержит лишь два символа* (*может закодировать лишь два состояния*), то *код* называют **двоичным** или **бинарным кодом** (англ. binary code). Чаще всего *целевой алфавит бинарного кода состоит* из *нуля и единицы*, то есть `B = { 0, 1 }`, что приводит нас к *использованию двоичной системы счисления* (англ. the binary number system).

**Кодом символа** будем называть *закодированное представление* этого *символа*.

### Формальное определение кода и его расширения

Пусть *имеются* *исходный* и *целевой алфавиты* `A` и `B`. Пусть также *имеются бесконечные множества* `A*` и `B*`, являющиеся *множествами всевозможных последовательностей символов алфавитов* `A` и `B` *соответствено*.

**Кодом** называют такую *функцию* (*отображение*) **`c: A → B*`**, которая *преобразует* (англ. map) *каждый символ алфавита* `A` в некоторую *последовательность символов алфавита* `B`. Такая *последовательность однозначно определяется заданным алгоритмом* (*набором символов*).

**Расширением кода `c`** (англ. extension) называют *функцию* **`c*: A* → B*`**, которая *преобразует любую последовательность символов алфавита* `A` в *определённую последовательность символов алфавита* `B`. 

<!--
`f(x) = y`, где `x` - *упорядоченный набор (кортеж) символов алфавита* `A`, а `y` - *упорядоченный набор (кортеж) символов алфавита* `B`. Тогда *пример выше* можно *записать* как `f('a') = 01000001`.
-->

#### Пример кода и его расширения

Пусть *имеется исходный алфавит* `A = { r, s, t }` и *целевой алфавит* `B = { 0, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9 }`.


По определению, *кодом* является *функция* **`c: A → B*`**, которая *принимает символ алфавита* `A` и *возвращает последовательность символов алфавита* `B` (*десятичное число*) по *заданному правилу*.


Пусть теперь *последовательность символов алфавита* `B` задаётся *кодировкой ANSII*.
Символ | Десятичный код символа
:--: | :--:
r | 162
s | 163
t | 164

В таком случае *справедливо следующее*
```
с('r') = 162,
c('s') = 163,
c('t') = 164,
```
что так же *можно записать*
```
c = { r ↦ 162, s ↦ 163, t ↦ 164 },
```
где `r, s, t ∈ A` и `162, 163, 163 ∈ B*`.

Рассмотрим теперь *расширение кода* в виде *функции* **`c*: A* → B*`**, которая *принимает последовательность символов исходного алфавита* `A` и *преобразует* её в *последовательность символов целевого алфавита* `B` по тому же *правилу*, что и *код* `c: A → B*` .

Например, пусть `ts, ssr ∈ A*`, тогда
```
c* = { ts ↦ 164162, ssr ↦ 16316312 },
```
где `164162, 16316312 ∈ B*`.

<!--
Из примера выше понятно, что для *декодирования* необходимо знать фиксированную длину кода символа, иначе разделить последовательность не получится
Например, можно установить длину = 3, тогда в случае двухзначного числа впереди добавится 0
-->


<!--

Со временем пришли к тому, что 256 символов не достаточно, поэтому в один символ строки теперь выделяют 2-4 байта. Например, выделение 2 байт на один символ позволяет использовать алфавит, содержащий до 2^16 = 65536 символов.
-->


## Разновидности кодировок

*Кодировки* можно *разделить* на *несколько видов* по тому, *сколько памяти* в них *выделяется* для *представления символов* и *как* это *выделение осуществляется*.

### Кодировки с малым количеством бит

*Размер представления* любого *символа* в *первых кодировках не превышал одного байта*. Наиболее яркими *примерами таких кодировок выступают* **семибитная кодировка ASCII** и **восьмибитная** (*однобайтовая*) **расширенная кодировка ASCII** (англ. Extended ANSII). *Последняя* является *стандартом* в *языке C* и часто *встречается* при работе с языком *C++*.

Используя *формулу* *количества информации* `i` в *одном символе* *алфавита* `A` *мощности* `n`: `i = log2(n)`, *приходим* к тому, что **`n = 2^i`**, откуда *следует*, что **семибитная кодировка** позволяет *закодировать* лишь *набор* из **`2^7 = 128`** *и менее* **символов**, а **однобайтовая кодировка** - *набор* из **`2^8 = 256`** *и менее* **символов**.

### Преимущества и недостатки использования кодировок с малым количеством бит

*Кодировки с малым количеством бит* обладают *преимуществом* в *простоте реализации* и *легковестности кода*. *Восьмибитная кодировка* также отличается *простотой подсчёта размера сообщения* (`1 символ` *занимает* ровно `1 байт`).

*С другой стороны*, *кодировка с малым количеством бит* сильно *ограничена*, поскольку *такая кодировка* может *вместить лишь несколько языков*. 

Как *следствие*, для *каждого разговорного языка* создавалась *своя*, *отдельная кодировка*, которая также *включала набор основных специальных символов* и *цифры*. Это может быть *удобно* в *рамках* одной *локальной системы*, где *все операции производятся* на *одном языке*, но это *не работает*, когда *две* и более *различные системы взаимодействуют* друг с другом, а именно *такое взаимодействие* и *подразумевает* под собой *интернет*. 

Так, например, *без соответствующей кодировки* *текстовый файл*, *напечатанный* на *одном компьютере*, *невозможно разобрать* на *другом компьютере*.


<!--
### Кодировки с малым количеством бит (ASCII)

*Раньше* активно *использовались кодировки*, в которых *код символа* занимает *малое количество бит*. Например, *семибитные* и *восьмибитные* (*однобайтовые*) *кодировки*.
, то есть такие *наборы символов*, *каждый символ* которых *занимает один байт*.


*Ранее* мы *выяснили*, что *один байт* можно *представить 256*-ю *способами расстановки* *нулей* и *единиц*, а это значит, что *однобайтовая кодировка* позволяет *закодировать не более 256 символов*.

Кодировка ASCII содержит символы латинского алфавита

-->

## О кодировке ASCII

**Кодировка ASCII** (англ. American Standard Code for Information Interchange) была *разработана* для...

*Кодировка ASCII содержит*:
1) **Управляющие символы** (англ. Control characters). Например, `Backspace`, `Space`, `Delete`, `\n`.
2) **Печатные символы** (англ. Printable characters), *включающие* в себя *строчные* и *прописные буквы латинского алфавита*, *цифры*, *знаки препинания* и некоторые *другие наиболее распространённые символы* (`#`, `&`, `@`, `$`, `=` и *другие*).

*Каждому символу кодировки ASCII ставится* в *соответствие целое число от* `0` *до* `127`, которое может быть *представлено 7-битной строкой*.

*Ниже выборочно представлены символы* и *их коды* в *кодировке ASCII*:
Код символа | Двоичный код символа | Символ
:--: | :--: | :--:
0 | 0000000 | "\0" (Null)
8 | 0001000 | "\b" (Backspace)
10 | 0001010 | "\n" (Line Feed, LF)
13 | 0001101 | "\r" (Carriage Return, CR)
40 | 0100000 | Space
49 | 0110001 | "1"
50 | 0110010 | "2"
57 | 0111001 | "9"
65 | 1000001 | "A"
66 | 1000010 | "B"
90 | 1011010 | "Z"
97 | 1100001 | "a"
98 | 1100010 | "b"
122 | 1111010 | "z"
127 | 1111111 | Delete


<!--
На каждый язык своя версия кодировки, переключение между ними
-->

## О стандарте Unicode


Описанную проблему можно было решить лишь созданием кодировки, которая содержала бы все символы мира. Так *появился стандарт Unicode*.

В наши дни *самым* широко *используемым набором символов* является **универсальный набор символов** (англ. Universal character set, UCS), *являющийся частью стандарта Unicode*. 

*Стандарт Unicode* предоставляет несколько **форматов**, позволяющих *ограничить диапазон используемых символов набора* (*уменшить количество символов* в *наборе*) и таким образом *уменьшить затраты памяти* на *один символ*.




# Типы данных
- [О типе данных](#о-типе-данных)
- [Классификация типов данных](#классификация-типов-данных)
- [Логический тип](#логический-тип)
- [Строковый тип](#строковый-тип)
- [Символьный тип](#символьный-тип)
- [Целочисленный тип](#целочисленный-тип)

## О типе данных
*Рекомендуется* прочитать: [Множество (дискретная математика)]().

**Типом данных** (англ. data type) или просто **типом** (англ. type) называют *множество* (*допустимых*) *значений* и *совокупность операций* над этими *значениями*.

*Тип данных* подсказывает *компьютеру*, как *следует обращаться* с этими *данными*.

## Классификация типов данных

*Большинство языков программирования поддерживает* **3 основных типа данных**:  
1) **Логический тип**. Содержит *значение логического типа*: *истина* или *ложь*. Эти Например, `true` или `false`, `1` или `0`.  
2) **Строковый тип**. Содержит *текст*. Например, `'По ту сторону изгороди'`, `"письма незнакомке"`.  
3) **Числовой тип** . Содержит *число*. Например, `7`, `-3`, `3.14`.

*Эти типы данных* также *называют* **примитивными** или **базовыми типами**.

## Логический тип
- [О логическом типе](#о-логическом-типе)
- [Операции](#операции)

### О логическом типе



## Строковый тип
- [О строковом типе](#о-строковом-типе)
- [Обозначение строки](#обозначение-строки)
- [Операции над строками](#операции-над-строками)
- [Представление строк в памяти компьютера](#представление-строк-в-памяти-компьютера)

### О строковом типе

**Строковым типом** (англ. String) называют *тип данных*, *каждое значение* которого *представляет* собой *последовательность символов* некоторого *алфавита*. 

*Значение строкового типа* называют **строкой** (англ. string). *Строка* *представляет* собой *упорядоченный набор элементов с повторениями*.

*Количество символов строки* называют **длиной строки**.


### Обозначение строки

В *программном коде значения строкового типа* (*строки*) обычно *заключаются* в *кавычки*:
1) **Одинарные**: `'Мартин Иден'`, `'evergreen'`.
2) **Двойные**: `"Унесённые ветром"`, `"inhale"`.
3) **Косые**: \``Триумфальная арка`\`, \``Round Robin`\`.


### Размер строки
*Ранее выделяли* `1 байт = 8 бит` *памяти* на *каждый символ строки*. Как было *показано ранее*, *один байт* может быть *представлен* `2^8 = 256` *различными последовательностями* из *восьми бит*. Таким образом, *выделение одного байта* на *один символ* позволяет использовать *алфавит*, *содержащий до* `256` *символов*.

Со временем пришли к тому, что `256` *символов не достаточно*, поэтому на *один символ строки* стали *выделять* `2-4 байта`. Например, *выделение* `2 байт` на *один символ* позволяет *использовать алфавит*, *содержащий* до `2^16 = 65536` *символов*.

<!-- unicode, ansi -->

### Операции над строками

*Над строками* можно *выполнять* следующие *операции*:
* *Вычисление длины* строки. Например, `"Notes".length --> 5`.
* *Получение символа* из строки по *индексу*. Например, `"Notes".find("t") --> 2`.
* *Конкатенация* (*сложение*) *строк*. Например, `"No" + "tes" --> "Notes"`.
* *Сравнение* двух *строк*. Например, `"No" == "tes" --> false`.
* *Поиск подстроки* в строке. Например, `"Notes".includes("tes") --> true`.
* *Замена подстроки* в строке. Например, `"Notes".replace("es", "ion") --> "Notion"`.

*Все* (или *почти все*) из *перечисленных операций над строками по умолчанию встроены* в *большинство языков программирования*. В *противном случае* их *можно подключить* вместе с некоторой *библиотекой*.

### Сравнение строк

<!--
Лексикографически, посимвольно, коды символов
-->

### Представление строк в памяти компьютера

<!-- перенести в programming -->

Существует *два способа представить строку* в *памяти компьютера*:  
* *Массив символов*.
* *Нуль-терминированная строка*.

#### Массив символов

**Массивом символов** называют *способ представления* в *памяти компьютера* **строки** из **`n` символов** как **массива** из **`n + 1` элементов**, в котором *символы строки* занимают *индексы от* `1` *до* `n`, а *элемент массива* с *нулевым индексом содержит длину строки* (*количество символов*) или *размер строки* (*количество байт*).

<!--
Например, можно представить слово `Notes` как \u004e\u006f\u0074\u0065\u0073
Символы
Коды символов
Биты
Индексы элементов массива
Элементы массива
-->

#### Нуль-терминированная строка

**Нуль-терминированной строкой** называют *способ представления строки* в *памяти компьютера*, при котором *строка представляется непрерывной последовательностью байт*, которая *оканчивается специальным* *нуль-символом* (*признаком конца строки*, *завершающим байтом*). 

**Нуль-символ** *представляет* собой *любой символ алфавита*, который был *выбран* в *качестве признака конца строки*. Например, в *алфавите ANSI* *нуль-символом выступает символ* `NUL`, имеющий *код* `0`.

Если *выделяется один байт на один символ алфавита*, то *нуль-терминированная строка* из **`n` символов** *занимает* **`n + 1` байт**.

*Нуль-терминированные строки* являются *стандартом* в *языке C*, поэтому их *иногда называют* **C-строками**.

## Символьный тип

**Символьным типом** (англ. Char) называют *тип данных*, *каждое значение* которого *представляет* собой *один* **символ** (англ. character) некоторого *алфавита* (некоторой *кодировки*).

Например, *значениями символьного типа* являются: `'%'`, `'g'`, `'/'`.

*Значение символьного типа занимает столько памяти*, *сколько* должен занимать *символ соответствующей кодировки* . Например, для *ANSII* это `1 байт`, для *Unicode* - `2-4 байт`.

Например, в *языке C нет строкового типа*, поэтому *строки рассматриваются* в нём как *массивы символов* (`char[]` или `char*`).

## Целочисленный тип
- [О целочисленном типе](#о-целочисленном-типе)
- [Размер значения целочисленного типа](#размер-значения-целочисленного-типа)

### О целочисленном типе

**Целочисленным типом** (англ. Integer, Int) называют *тип данных*, *каждое значение* которого *представляет* собой *целое число*.

Например, *значениями целочисленного типа* являются: `17`, `-3`, `0`.

### Размер значения целочисленного типа

Вообще говоря, *математическое множество целых чисел* `Z` *бесконечно*. Но, *из-за ограниченности ресурсов*, *компьютер не способен хранить* что-либо *бесконечное*, поэтому *множество целочисленных значений конечно* в *компьютерном представлении* и *ограничивается сверху* и *снизу максимальным* и *минимальным значениями*. 

### Арифметические операции над целыми числами


#### Унарные арифметические операции над целыми числами
* **Инкремент** (англ. **inc**rement) - *увеличение значения на единицу*. *Обозначение инкремента числа* `x`: `x++` или `++x`. Например, `++6 = 7`.
* **Декремент** (англ. **dec**rement) - *увеличение значения на единицу*. *Обозначение инкремента числа* `x`: `x--` или `--x`. Например, `--4 = 3`.
* **Модуль** (англ. **abs**olute value) - *значение числа без* учёта *знака*. *Обозначение модуля числа* `x`: `|x|` (мат.), `abs(x)` (прог.). Например, `|-5| = 5`.
* **Отрицание** (англ. **neg**ation) - *смена знака числа* на *противоположный*. *Обозначение отрицания числа* `x`: `-x`, `neg(x)` (прог.). Например, *отрицание числа* `8`: `-8`, *отрицание числа* `-2`: `2`.
* **Взятие квадратного корня** (англ. **sq**uare **r**oo**t**). *Обозначение квадратного корня числа* `x`: `√x` (мат.), `sqrt(x)` (прог.). Например, `√49 = 7`, то есть `7 • 7 = 49`.
* **Натуральный логарифм** (англ. **log**arithm). *Обозначение натурального логарифма числа* `x`: `ln(x)`, `log(x)` (прог.). Например, `ln(7) = 1.94591`, то есть `e^(1.94591) = 7`.

#### Бинарные арифметические операции над целыми числами
* **Сложение** (англ. **add**ition). *Обозначение сложения чисел* `x` и `y`: `x + y`. Например, `7 + 6 = 13`.
* **Разность** (англ. **sub**traction). ). *Обозначение вычитания числа* `y` из *числа* `x`: `x - y`. Например, `7 - 6 = 1`.
* **Умножение** (англ. **mul**tiplication). *Обозначение умножения чисел* `x` и `y`: `x • y` (мат.), `x * y` (прог.). Например, `6 • 7 = 42`.
* **Деление** (англ. **div**ision). *Обозначение деления числа* `x` на *число* `y`: `x ÷ y` (мат.), `x / y` (прог.). Например, `42 ÷ 6 = 7`.
* **Возведение в степень** (англ. **pow**er). *Обозначение возведения числа* `x` в *степень* `y`: `x ^ y` (мат.), `x ** y` (прог.), `pow(x, y)` (прог.). Например, `2 ^ 4 = 16`.

### Сравнение целых чисел
Рекомендуется прочитать: [Операция](), [Отношение]().

В *отличие математики*, где *сравнение представляет* собой *отношение*, в *программировании сравнение* является *операцией*, то есть оно *обязательно возвращает результат* (обычно *логического типа*).


# Структуры данных

**Структура данных** (англ. data structure) - это *набор значений* некоторых *логически связанных данных*, *отношения между этими данными* и *доступные операции*, которые *можно к ним применить*.



















# Метаданные

**Метаданными** (англ. metadata) называют *данные*, которые *несут* в себе *информацию* о *других данных*. Иначе говоря, *метаданные* - это *“данные о данных”*.

Например, *текстовый файл* может *иметь* следующие *метаданные*:
* *имя пользователя*, *создавшего* файл,
* *дата создания* файла,
* *дата последнего изменения* файла,
* *размер файла* (например, `73 KB`),
* *полная расшифровка формата* файла (например, `.pdf` - *Portable Document Format*),
* *количество символов* (строк) в файле*,
* *кодировка файла* (например, `UTF-8`),
* *возможность чтения* файла *и записи* в файл.

Например, *реляционная база данных хранит информацию* (*метаданные*) о том, *какие* *таблицы* в ней *имеются*, *какой размер* они *занимают* и *сколько строк содержится* в *каждой* из них.








